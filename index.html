<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GemFinder Alpha Screener</title>
  <style>
    :root {
      color-scheme: dark light;
      --bg: #0c1116;
      --panel: #111922;
      --accent: #33aaff;
      --accent-muted: #23597f;
      --danger: #d25f5f;
      --success: #5fd286;
      --warning: #d2b75f;
      --text: #f5f7fa;
      --text-muted: #a0aec0;
      --border: #1c2835;
      --radius: 12px;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f7fb;
        --panel: #ffffff;
        --accent: #0066cc;
        --accent-muted: #d5e9ff;
        --text: #0b1623;
        --text-muted: #4b5568;
        --border: #d8dee8;
      }
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-size: 15px;
      line-height: 1.45;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(12, 17, 22, 0.9);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    header .top-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }

    h1 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
    }

    .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      letter-spacing: 0.01em;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .pill.ok { color: var(--success); border-color: color-mix(in srgb, var(--success) 45%, transparent); }
    .pill.err { color: var(--danger); border-color: color-mix(in srgb, var(--danger) 45%, transparent); }
    .pill.warn { color: var(--warning); border-color: color-mix(in srgb, var(--warning) 45%, transparent); }

    .controls {
      display: grid;
      gap: 12px;
    }

    .segmented {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: var(--panel);
    }

    .segmented button {
      appearance: none;
      border: none;
      padding: 10px 6px;
      font: inherit;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .segmented button.active {
      background: var(--accent);
      color: white;
    }

    .filters, .universe {
      display: grid;
      gap: 12px;
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 12px;
    }

    .filters h2, .universe h2 {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .filters-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    select, input, textarea {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 95%, black 5%);
      color: inherit;
      font: inherit;
    }

    textarea { min-height: 70px; resize: vertical; }

    button.action {
      appearance: none;
      border: none;
      border-radius: 10px;
      background: var(--accent);
      color: white;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: filter 0.2s ease;
    }

    button.action:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    main {
      flex: 1;
      padding: 16px;
      display: grid;
      gap: 16px;
    }

    .results-panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 320px;
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }

    .virtual-list {
      position: relative;
      overflow-y: auto;
      flex: 1;
    }

    .row {
      display: grid;
      grid-template-columns: 90px 100px repeat(4, minmax(0, 1fr)) 80px;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .row:hover { background: color-mix(in srgb, var(--panel) 85%, var(--accent) 15%); }

    .row .ticker { font-weight: 600; }
    .row .alpha { font-weight: 600; color: var(--accent); }

    .row.expanded {
      grid-template-columns: 1fr;
      background: color-mix(in srgb, var(--panel) 92%, var(--accent) 8%);
    }

    .row.expanded > div { grid-column: span 1; }

    .dossier {
      display: grid;
      gap: 12px;
      padding: 12px 0;
    }

    .sparkline { width: 100%; height: 56px; }
    .volume-bars { width: 100%; height: 40px; }

    .subscores {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
    }

    .subscores .score-box {
      padding: 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      text-align: center;
      font-size: 0.85rem;
    }

    .catalysts, .evidence, .risks {
      display: grid;
      gap: 4px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .watchlist-panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 12px;
      display: grid;
      gap: 12px;
    }

    .watchlist-items {
      display: grid;
      gap: 6px;
      font-size: 0.85rem;
    }

    .watchlist-items button {
      justify-self: start;
      border: none;
      padding: 4px 8px;
      border-radius: 6px;
      background: var(--accent-muted);
      color: var(--text);
      cursor: pointer;
    }

    .diagnostics {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 14, 0.75);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      backdrop-filter: blur(6px);
    }

    .diagnostics[aria-hidden="false"] { display: flex; }

    .diagnostics-dialog {
      background: var(--panel);
      border-radius: var(--radius);
      max-width: min(620px, 90vw);
      max-height: min(80vh, 620px);
      overflow: hidden;
      border: 1px solid var(--border);
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    .diagnostics-dialog header {
      position: static;
      border-bottom: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 85%, transparent);
    }

    .diagnostics-dialog main {
      padding: 16px;
      overflow: auto;
    }

    .diagnostics-dialog footer {
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
    }

    table.meta-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    table.meta-table td, table.meta-table th {
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }

    .status-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .flex-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .flush-btn {
      background: transparent;
      color: var(--accent);
      border: 1px solid color-mix(in srgb, var(--accent) 60%, transparent);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
    }

    footer.disclaimer {
      padding: 12px 16px 24px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      border: 0;
    }

    @media (min-width: 900px) {
      header { flex-direction: column; }
      main { grid-template-columns: 2.5fr 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="top-row">
      <div>
        <h1>GemFinder Alpha Screener</h1>
        <div class="meta">
          <span id="asOf">As of —</span>
          <button class="flush-btn" id="flushCache" aria-label="Flush cached data">Flush Cache</button>
          <button class="flush-btn" id="openDiagnostics" aria-haspopup="dialog">Diagnostics</button>
        </div>
      </div>
      <div class="status-group" id="sourceStatus">
        <span class="pill" data-source="stooq">Stooq</span>
        <span class="pill" data-source="gdelt">GDELT</span>
        <span class="pill" data-source="sec">SEC</span>
        <span class="pill" data-source="reddit">Reddit</span>
        <span class="pill" data-source="wiki">Wiki</span>
      </div>
    </div>
    <div class="controls" role="group" aria-label="Controls">
      <div class="segmented" role="tablist" aria-label="Horizons">
        <button role="tab" data-horizon="Week" class="active">Week</button>
        <button role="tab" data-horizon="NextWeek">Next Week</button>
        <button role="tab" data-horizon="Month">Month</button>
        <button role="tab" data-horizon="LongTerm">Long-Term</button>
      </div>
      <div class="filters">
        <h2>Filters</h2>
        <div class="filters-grid">
          <label>Sector
            <select id="sectorFilter">
              <option value="all">All</option>
            </select>
          </label>
          <label>Market Cap
            <select id="capFilter">
              <option value="all">All</option>
              <option value="mega">Mega (&gt; $200B)</option>
              <option value="large">Large ($10B–$200B)</option>
              <option value="mid">Mid ($2B–$10B)</option>
              <option value="small">Small (&lt;$2B)</option>
            </select>
          </label>
          <label>Min Liquidity ($M)
            <input type="number" id="liquidityFilter" min="0" step="0.5" value="1" />
          </label>
          <label>Min Relative Strength
            <input type="number" id="rsFilter" min="-100" max="100" step="1" value="-20" />
          </label>
          <label>Sentiment Threshold
            <input type="number" id="sentimentFilter" min="0" max="100" step="5" value="30" />
          </label>
          <label>
            <input type="checkbox" id="excludeEtfs" checked />
            <span>Exclude ETFs</span>
          </label>
        </div>
      </div>
      <div class="universe">
        <h2>Universe</h2>
        <div class="filters-grid">
          <label>Universe Source
            <select id="universeSource">
              <option value="sp500">S&amp;P 500</option>
              <option value="sp400">S&amp;P 400 Mid Cap</option>
              <option value="sp600">S&amp;P 600 Small Cap</option>
              <option value="custom">Paste Tickers</option>
            </select>
          </label>
          <label>Paste tickers (comma / newline)
            <textarea id="customTickers" placeholder="AAPL, MSFT, ..."></textarea>
          </label>
          <label>Watchlist
            <select id="watchlistSelect">
              <option value="">None</option>
            </select>
          </label>
        </div>
        <div class="flex-row">
          <button class="action" id="runScreen">Run Screener</button>
          <span id="universeSummary" class="meta">Universe: 0 tickers</span>
        </div>
      </div>
    </div>
  </header>
  <main>
    <section class="results-panel" aria-live="polite">
      <div class="results-header">
        <div>
          <strong>Ranked Opportunities</strong>
          <div class="meta" id="resultsMeta">Awaiting run…</div>
        </div>
        <div class="meta" id="qualityGateSummary">Quality gates enforced</div>
      </div>
      <div class="virtual-list" id="resultsList" role="list"></div>
    </section>
    <aside class="watchlist-panel">
      <div class="flex-row" style="justify-content:space-between; align-items:center;">
        <h2>Watchlist</h2>
        <button class="flush-btn" id="exportWatchlist">Export</button>
      </div>
      <div class="watchlist-items" id="watchlistItems"></div>
      <label>Import JSON
        <input type="file" id="importWatchlist" accept="application/json" />
      </label>
    </aside>
  </main>
  <footer class="disclaimer">
    Informational only. Not investment advice. Live sources may fail or be incomplete. Data cached for resiliency. Asynchronous fetches obey 10s timeouts and retries.
  </footer>

  <div class="diagnostics" id="diagnostics" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="diagnosticsTitle">
    <div class="diagnostics-dialog">
      <header>
        <h2 id="diagnosticsTitle">Diagnostics</h2>
      </header>
      <main>
        <table class="meta-table" id="diagnosticsTable" aria-live="polite"></table>
      </main>
      <footer>
        <button class="flush-btn" id="closeDiagnostics">Close</button>
      </footer>
    </div>
  </div>

  <script>
    /* ======================================================
       Utility helpers
    ====================================================== */
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

    const formatNumber = (value, options = {}) => {
      if (value === null || value === undefined || Number.isNaN(value)) return '—';
      return new Intl.NumberFormat('en-US', options).format(value);
    };

    const logistic = x => 1 / (1 + Math.exp(-x));
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    const median = arr => {
      if (!arr.length) return 0;
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    };

    const mad = arr => {
      if (!arr.length) return 0;
      const med = median(arr);
      return median(arr.map(v => Math.abs(v - med))) || 1e-9;
    };

    const robustZ = arr => {
      if (!arr.length) return [];
      const med = median(arr);
      const m = mad(arr) * 1.4826 || 1e-6;
      return arr.map(v => (v - med) / m);
    };

    const percentileRank = (arr, value) => {
      if (!arr.length) return 0;
      const less = arr.filter(v => v <= value).length;
      return (less / arr.length) * 100;
    };

    const colorForScore = score => {
      if (score === null || score === undefined || Number.isNaN(score)) return 'var(--text-muted)';
      if (score >= 75) return 'var(--success)';
      if (score >= 50) return 'var(--accent)';
      if (score >= 25) return 'var(--warning)';
      return 'var(--danger)';
    };

    const setStatus = (source, status, message = '') => {
      const pill = document.querySelector(`.pill[data-source="${source}"]`);
      if (!pill) return;
      pill.classList.remove('ok', 'err', 'warn');
      if (status === 'ok') pill.classList.add('ok');
      if (status === 'err') pill.classList.add('err');
      if (status === 'warn') pill.classList.add('warn');
      pill.textContent = message ? `${source.toUpperCase()} ${message}` : source.toUpperCase();
    };

    const statusLabelFromResponse = (res, fallback = 'live') => {
      if (!res || !res.proxyLabel) return fallback;
      return res.proxyLabel === 'live' ? fallback : 'proxy';
    };

    const nowIso = () => new Date().toISOString();

    const parseCSV = (csv) => {
      const lines = csv.trim().split(/\r?\n/);
      const headers = lines.shift().split(',');
      return lines
        .map(line => line.split(',').reduce((acc, cur, idx) => {
          acc[headers[idx]] = cur;
          return acc;
        }, {}))
        .map(row => ({
          date: row.Date,
          open: Number(row.Open),
          high: Number(row.High),
          low: Number(row.Low),
          close: Number(row.Close),
          volume: Number(row.Volume)
        }))
        .filter(row => !Number.isNaN(row.close));
    };

    /* ======================================================
       Storage Layer
    ====================================================== */
    const STORAGE_KEYS = {
      SETTINGS: 'gemfinder_settings',
      CACHE: 'gemfinder_cache',
      WATCHLIST: 'gemfinder_watchlist',
      DIAGNOSTICS: 'gemfinder_diagnostics'
    };

    const CacheStore = (() => {
      let memory = new Map();
      const ttlHours = 6;
      const keyPrefix = 'GF_CACHE::';

      const load = () => {
        try {
          const raw = localStorage.getItem(STORAGE_KEYS.CACHE);
          if (raw) memory = new Map(Object.entries(JSON.parse(raw)));
        } catch (err) {
          console.warn('Failed to load cache', err);
        }
      };

      const persist = () => {
        try {
          localStorage.setItem(STORAGE_KEYS.CACHE, JSON.stringify(Object.fromEntries(memory)));
        } catch (err) {
          console.warn('Persist cache error', err);
        }
      };

      const key = (scope, id) => `${keyPrefix}${scope}::${id}`;
      load();
      return {
        get(scope, id) {
          const k = key(scope, id);
          if (!memory.has(k)) return null;
          const { timestamp, data } = memory.get(k);
          if (Date.now() - timestamp > ttlHours * 3600 * 1000) {
            memory.delete(k);
            persist();
            return null;
          }
          return data;
        },
        set(scope, id, data) {
          memory.set(key(scope, id), { data, timestamp: Date.now() });
          persist();
        },
        flush() {
          memory.clear();
          persist();
        },
        snapshot() {
          return Array.from(memory.entries()).map(([k, v]) => ({ key: k, ageMinutes: ((Date.now() - v.timestamp) / 60000).toFixed(1) }));
        }
      };
    })();

    /* ======================================================
       Fetch queue with retries + timeout + concurrency
    ====================================================== */
    class FetchPool {
      constructor(maxConcurrent = 6) {
        this.maxConcurrent = maxConcurrent;
        this.queue = [];
        this.active = 0;
      }
      async enqueue(task) {
        return new Promise((resolve, reject) => {
          this.queue.push({ task, resolve, reject });
          this.process();
        });
      }
      async process() {
        if (this.active >= this.maxConcurrent) return;
        const next = this.queue.shift();
        if (!next) return;
        this.active++;
        try {
          const result = await next.task();
          next.resolve(result);
        } catch (err) {
          next.reject(err);
        } finally {
          this.active--;
          if (this.queue.length) this.process();
        }
      }
    }

    const proxyChain = [
      { label: 'live', apply: url => url },
      {
        label: 'jina',
        apply: url => {
          if (/^https?:\/\//i.test(url)) return `https://r.jina.ai/${url}`;
          return `https://r.jina.ai/https://${url.replace(/^\/+/, '')}`;
        }
      },
      { label: 'isomorphic', apply: url => `https://cors.isomorphic-git.org/${url}` }
    ];

    const fetchWithRetry = async (url, options = {}, retries = 3) => {
      let lastError = null;
      for (const proxy of proxyChain) {
        for (let attempt = 0; attempt <= retries; attempt++) {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), 10000);
          try {
            const targetUrl = proxy.apply(url);
            const res = await fetch(targetUrl, { ...options, signal: controller.signal });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            res.proxyLabel = proxy.label;
            return res;
          } catch (err) {
            lastError = err;
            if (attempt === retries) break;
            const delayMs = (2 ** attempt) * 500 + Math.random() * 400;
            await delay(delayMs);
          } finally {
            clearTimeout(id);
          }
        }
      }
      throw lastError || new Error('Network error');
    };

    /* ======================================================
       Universe builders
    ====================================================== */
    const wikipediaSources = {
      sp500: { url: 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies', tableIndex: 0 },
      sp400: { url: 'https://en.wikipedia.org/wiki/List_of_S%26P_400_companies', tableIndex: 0 },
      sp600: { url: 'https://en.wikipedia.org/wiki/List_of_S%26P_600_companies', tableIndex: 0 }
    };

    const parseUniverseTable = (html, tableIndex = 0) => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const tables = doc.querySelectorAll('table.wikitable');
      if (!tables.length) return [];
      const table = tables[tableIndex] || tables[0];
      return Array.from(table.querySelectorAll('tbody tr')).map(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length < 2) return null;
        const ticker = cells[0].textContent.trim().replace(/\./g, '-');
        const name = cells[1].textContent.trim();
        const sector = cells[3] ? cells[3].textContent.trim() : 'Unknown';
        if (!ticker || ticker.length > 10) return null;
        return { ticker, name, sector };
      }).filter(Boolean);
    };

    const loadUniverse = async (key) => {
      const source = wikipediaSources[key];
      if (!source) return [];
      const cacheKey = `wiki-${key}`;
      const cached = CacheStore.get('wiki', cacheKey);
      if (cached) {
        setStatus('wiki', 'ok', 'cached');
        return cached;
      }
      try {
        const res = await fetchWithRetry(source.url, { headers: { 'Accept': 'text/html' } });
        const html = await res.text();
        const universe = parseUniverseTable(html, source.tableIndex);
        CacheStore.set('wiki', cacheKey, universe);
        setStatus('wiki', 'ok', statusLabelFromResponse(res));
        return universe;
      } catch (err) {
        console.error('Wiki fetch failed', err);
        setStatus('wiki', 'err', 'error');
        return [];
      }
    };
    /* ======================================================
       Market data & indicators
    ====================================================== */
    const computeSMA = (series, window) => {
      const result = [];
      for (let i = 0; i < series.length; i++) {
        if (i + 1 < window) {
          result.push(null);
          continue;
        }
        const slice = series.slice(i + 1 - window, i + 1);
        result.push(slice.reduce((sum, v) => sum + v, 0) / window);
      }
      return result;
    };

    const computeRS = (series, spySeries, lookback) => {
      if (series.length < lookback + 1 || spySeries.length < lookback + 1) return 0;
      const latest = series.at(-1);
      const prev = series.at(-(lookback + 1));
      const spyLatest = spySeries.at(-1);
      const spyPrev = spySeries.at(-(lookback + 1));
      if (!prev || !spyPrev) return 0;
      return (latest / prev) / (spyLatest / spyPrev) - 1;
    };

    const computeATR = (data, window = 14) => {
      const trs = [];
      for (let i = 0; i < data.length; i++) {
        if (i === 0) {
          trs.push(null);
          continue;
        }
        const high = data[i].high;
        const low = data[i].low;
        const prevClose = data[i - 1].close;
        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
        trs.push(tr);
      }
      return trs.map((_, idx) => {
        if (idx + 1 < window) return null;
        const slice = trs.slice(idx + 1 - window, idx + 1).filter(Boolean);
        return slice.length ? slice.reduce((a, b) => a + b, 0) / slice.length : null;
      });
    };

    const computeBBW = (closes, window = 20) => {
      const sma = computeSMA(closes, window);
      const stdev = closes.map((_, idx) => {
        if (idx + 1 < window) return null;
        const slice = closes.slice(idx + 1 - window, idx + 1);
        const mean = slice.reduce((acc, v) => acc + v, 0) / slice.length;
        const variance = slice.reduce((acc, v) => acc + (v - mean) ** 2, 0) / slice.length;
        return Math.sqrt(variance);
      });
      return closes.map((_, idx) => {
        if (idx + 1 < window) return null;
        return (2 * stdev[idx]) / (sma[idx] || 1);
      });
    };

    const detectSqueeze = (bbw, closes, volumes) => {
      const recent = bbw.slice(-40);
      const valid = recent.filter(Boolean);
      if (!valid.length) return { squeeze: false, points: 0, lastTrigger: null };
      let triggerIndex = null;
      for (let i = recent.length - 1; i >= 5; i--) {
        const window = recent.slice(i - 5, i);
        const lowRank = window.filter(v => v && percentileRank(valid, v) <= 20).length;
        const closeIndex = closes.length - recent.length + i;
        const high20 = Math.max(...closes.slice(closeIndex - 20, closeIndex + 1));
        const volMedian = median(volumes.slice(-20));
        const breakout = closes[closeIndex] >= high20;
        const volSpike = volumes[closeIndex] > 1.5 * volMedian;
        if (lowRank >= 5 && breakout && volSpike) {
          triggerIndex = closeIndex;
          break;
        }
      }
      if (triggerIndex === null) return { squeeze: false, points: 0, lastTrigger: null };
      const distance = closes.length - 1 - triggerIndex;
      const decay = clamp(1 - distance / 15, 0, 1);
      return { squeeze: true, points: 15 * decay, lastTrigger: triggerIndex };
    };

    const avwapProxy = (data) => {
      if (data.length < 3) return { reclaimed: false, points: 0 };
      const anchor = Math.max(0, data.length - 30);
      let pv = 0;
      let vol = 0;
      for (let i = anchor; i < data.length; i++) {
        pv += data[i].close * data[i].volume;
        vol += data[i].volume;
      }
      const vwap = vol ? pv / vol : data.at(-1).close;
      const closes = data.slice(-3).map(d => d.close);
      const reclaimed = closes.every(close => close >= vwap * 0.995);
      return { reclaimed, points: reclaimed ? 10 : 0 };
    };

    const parabolicPenalty = (data) => {
      if (data.length < 5) return 0;
      const atrSeries = computeATR(data).map((atr, idx) => atr ? atr / (data[idx].close || 1) : 0).filter(Boolean);
      const z = robustZ(atrSeries);
      const lastZ = z.at(-1) || 0;
      const gap = data.at(-1).open / data.at(-2).close - 1;
      const volMedian = median(data.slice(-20).map(d => d.volume));
      if (lastZ > 2 && gap > 0.06 && data.at(-1).volume < volMedian) return -10;
      return 0;
    };

    /* ======================================================
       External Data adapters
    ====================================================== */
    const fetchStooq = async (ticker, interval = 'd') => {
      const cacheKey = `${ticker}-${interval}`;
      const cached = CacheStore.get('stooq', cacheKey);
      if (cached) return { data: cached, cached: true };
      const url = `https://stooq.com/q/d/l/?s=${ticker.toLowerCase()}&i=${interval}`;
      try {
        const res = await fetchWithRetry(url, { headers: { 'Accept': 'text/csv' } });
        const text = await res.text();
        const parsed = parseCSV(text);
        CacheStore.set('stooq', cacheKey, parsed);
        setStatus('stooq', 'ok', statusLabelFromResponse(res));
        return { data: parsed, cached: false };
      } catch (err) {
        console.error('Stooq error', ticker, err);
        setStatus('stooq', 'err', 'error');
        return { data: [], error: err };
      }
    };

    const fetchGdelt = async (query) => {
      const cached = CacheStore.get('gdelt', query);
      if (cached) return { data: cached, cached: true };
      const url = `https://api.gdeltproject.org/api/v2/doc/doc?format=json&query=${encodeURIComponent(query)}&maxrecords=50&sort=DateDesc`;
      try {
        const res = await fetchWithRetry(url, { headers: { 'Accept': 'application/json' } });
        const json = await res.json();
        CacheStore.set('gdelt', query, json);
        setStatus('gdelt', 'ok', statusLabelFromResponse(res));
        return { data: json, cached: false };
      } catch (err) {
        console.error('GDELT error', query, err);
        setStatus('gdelt', 'err', 'error');
        return { data: null, error: err };
      }
    };

    const SECIndex = {
      index: null,
      async ensureIndex() {
        if (this.index) return this.index;
        const cached = CacheStore.get('sec', 'index');
        if (cached) {
          this.index = cached;
          setStatus('sec', 'ok', 'cached');
          return cached;
        }
        try {
          const res = await fetchWithRetry('https://www.sec.gov/files/company_tickers.json', {
            headers: {
              'Accept': 'application/json',
              'User-Agent': 'GemFinder/1.0 (github)'
            }
          });
          const json = await res.json();
          const map = {};
          Object.values(json).forEach(entry => {
            map[entry.ticker] = entry.cik_str.toString().padStart(10, '0');
          });
          this.index = map;
          CacheStore.set('sec', 'index', map);
          setStatus('sec', 'ok', statusLabelFromResponse(res));
          return map;
        } catch (err) {
          console.error('SEC index error', err);
          setStatus('sec', 'err', 'error');
          return {};
        }
      }
    };

    const fetchSecFilings = async (ticker) => {
      const index = await SECIndex.ensureIndex();
      const cik = index[ticker];
      if (!cik) return { data: null, error: new Error('CIK not found') };
      const cacheKey = `filings-${ticker}`;
      const cached = CacheStore.get('sec', cacheKey);
      if (cached) return { data: cached, cached: true };
      try {
        const res = await fetchWithRetry(`https://data.sec.gov/submissions/CIK${cik}.json`, {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'GemFinder/1.0 (+https://github.com)'
          }
        });
        const json = await res.json();
        CacheStore.set('sec', cacheKey, json);
        setStatus('sec', 'ok', statusLabelFromResponse(res));
        return { data: json, cached: false };
      } catch (err) {
        console.error('SEC filings error', ticker, err);
        setStatus('sec', 'warn', 'partial');
        return { data: null, error: err };
      }
    };

    const fetchReddit = async (query) => {
      const cached = CacheStore.get('reddit', query);
      if (cached) return { data: cached, cached: true };
      const url = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&sort=new&restrict_sr=0`;
      try {
        const res = await fetchWithRetry(url, { headers: { 'Accept': 'application/json' } });
        const json = await res.json();
        CacheStore.set('reddit', query, json);
        setStatus('reddit', 'ok', statusLabelFromResponse(res));
        return { data: json, cached: false };
      } catch (err) {
        console.error('Reddit fetch error', query, err);
        setStatus('reddit', 'warn', 'error');
        return { data: null, error: err };
      }
    };

    /* ======================================================
       Narrative & filings analytics
    ====================================================== */
    const computeSentiment = (articles = []) => {
      if (!articles.length) return { medianTone: 0, tailRisk: 0, novelty: 0, stories: [], domainConcentration: 0 };
      const tones = articles.map(a => Number(a.tone ?? 0)).filter(v => !Number.isNaN(v));
      const medianTone = tones.length ? median(tones) : 0;
      const sorted = [...tones].sort((a, b) => a - b);
      const tailIndex = Math.max(0, Math.floor(sorted.length * 0.05) - 1);
      const tailRisk = sorted[tailIndex] || 0;
      const uniqueStories = [];
      const seen = [];
      const uniqueDomains = new Map();
      const toTokens = text => text.toLowerCase().split(/\W+/).filter(Boolean).slice(0, 20);
      articles.forEach(story => {
        const tokens = toTokens(story.title || '');
        const dup = seen.some(existing => {
          const intersection = existing.filter(t => tokens.includes(t)).length;
          const union = new Set([...existing, ...tokens]).size || 1;
          return intersection / union > 0.6;
        });
        if (!dup) {
          seen.push(tokens);
          uniqueStories.push(story);
        }
        try {
          const domain = story.url ? new URL(story.url).hostname : 'unknown';
          uniqueDomains.set(domain, (uniqueDomains.get(domain) || 0) + 1);
        } catch (err) {
          uniqueDomains.set('unknown', (uniqueDomains.get('unknown') || 0) + 1);
        }
      });
      const novelty = clamp(uniqueStories.length / (articles.length || 1), 0, 1);
      const topDomainCount = Math.max(...Array.from(uniqueDomains.values()));
      const domainConcentration = topDomainCount / (articles.length || 1);
      return { medianTone, tailRisk, novelty, stories: uniqueStories, domainConcentration };
    };

    const analyzeReddit = (posts = []) => {
      if (!posts.length) return { velocity: 0, polarity: 0, spamPenalty: 0 };
      const timestamps = posts.map(p => p.created_utc * 1000).sort((a, b) => a - b);
      const now = Date.now();
      const recent = timestamps.filter(ts => now - ts < 3600 * 1000);
      const velocity = recent.length;
      const z = clamp((velocity - 2) / 2, -2, 3);
      const authors = posts.map(p => p.author);
      const authorCounts = authors.reduce((acc, author) => {
        acc[author] = (acc[author] || 0) + 1;
        return acc;
      }, {});
      const spamPenalty = Math.max(...Object.values(authorCounts)) > 5 ? -10 : 0;
      const lexicon = { bullish: 1, moon: 1, calls: 0.6, puts: -0.6, bearish: -1, drop: -0.7, pump: -0.4 };
      let polarityScore = 0;
      posts.slice(0, 30).forEach(post => {
        const text = `${post.title} ${post.selftext || ''}`.toLowerCase();
        Object.entries(lexicon).forEach(([word, weight]) => {
          if (text.includes(word)) polarityScore += weight;
        });
      });
      const polarity = clamp((polarityScore / posts.length) * 10 + 5, 0, 10);
      return { velocity: z * 20, polarity, spamPenalty };
    };

    const classifySecEvents = (filings) => {
      if (!filings) return { events: [], cadenceScore: 0 };
      const forms = filings.filings?.recent;
      if (!forms) return { events: [], cadenceScore: 0 };
      const { accessionNumber, filingDate, form, primaryDocDescription } = forms;
      const events = [];
      const now = Date.now();
      for (let i = 0; i < form.length; i++) {
        const type = form[i];
        const date = filingDate[i];
        const ageDays = (now - new Date(date).getTime()) / 86400000;
        if (ageDays > 180) continue;
        let weight = 0;
        let label = '';
        if (type === '8-K') {
          if (/material definitive agreement|guidance|contract/i.test(primaryDocDescription[i] || '')) {
            weight = 25;
            label = 'material';
          }
          if (/purchase|repurchase/i.test(primaryDocDescription[i] || '')) {
            weight += 10;
            label = 'insider';
          }
        } else if (['13D', '13G'].includes(type)) {
          weight = 20;
          label = 'ownership';
        } else if (/10-Q/.test(type)) {
          weight = 5;
          label = '10-Q';
        } else if (/S-1|S-3/.test(type)) {
          weight = 10;
          label = 'shelf';
        }
        if (weight) {
          const decay = Math.exp(-ageDays / 21);
          events.push({ form: type, type: label, date, weight: weight * decay, accession: accessionNumber[i] });
        }
      }
      const cadenceScore = events.some(e => /10-Q/.test(e.form)) ? 5 : 0;
      return { events, cadenceScore };
    };

    /* ======================================================
       Alpha computation
    ====================================================== */
    const horizonConfigs = {
      Week: { wT: 0.45, wS: 0.35, wP: 0.15, wF: 0.05 },
      NextWeek: { wT: 0.40, wS: 0.30, wP: 0.15, wF: 0.15 },
      Month: { wT: 0.35, wS: 0.30, wP: 0.15, wF: 0.20 },
      LongTerm: { wT: 0.25, wS: 0.20, wP: 0.15, wF: 0.40 }
    };

    const computeHorizonScores = ({ T, F, S, P }) => {
      return Object.entries(horizonConfigs).reduce((acc, [h, weights]) => {
        acc[h] = clamp(100 * (weights.wT * (T / 100) + weights.wF * (F / 100) + weights.wS * (S / 100) + weights.wP * (P / 100)), 0, 100);
        return acc;
      }, {});
    };

    const computeScores = ({ ticker, data, spy, gdelt, reddit, filings }) => {
      const closes = data.map(d => d.close);
      const volumes = data.map(d => d.volume);
      const last = data.at(-1);
      if (!last) return null;
      const sma50 = computeSMA(closes, 50).at(-1);
      const sma150 = computeSMA(closes, 150).at(-1);
      const sma200 = computeSMA(closes, 200).at(-1);
      const bbw = computeBBW(closes, 20);
      const squeezeMeta = detectSqueeze(bbw, closes, volumes);
      const avwap = avwapProxy(data);
      const parabolic = parabolicPenalty(data);
      const trendScore = (last.close > (sma50 || Infinity) ? 25 : 0) + (last.close > (sma150 || Infinity) ? 25 : 0) + (last.close > (sma200 || Infinity) ? 25 : 0);
      const rs20 = computeRS(closes, spy, 20) * 100;
      const rs60 = computeRS(closes, spy, 60) * 100;
      const rs120 = computeRS(closes, spy, 120) * 100;
      const rsSample = [rs20, rs60, rs120].filter(v => Number.isFinite(v));
      const rsPercentile = percentileRank(rsSample, rs20);
      const T = clamp(trendScore + 0.25 * rsPercentile + squeezeMeta.points + avwap.points + parabolic, 0, 100);

      const { events, cadenceScore } = classifySecEvents(filings);
      const F = clamp(events.reduce((acc, e) => acc + e.weight, 0) + cadenceScore, 0, 100);

      const articles = gdelt?.data?.articles || gdelt?.data?.documents || gdelt?.articles || gdelt?.data?.results || [];
      const { medianTone, tailRisk, novelty, stories, domainConcentration } = computeSentiment(articles);
      const tonePercentile = clamp((medianTone + 10) * 5, 0, 100);
      const tailPercentile = clamp((20 + tailRisk) * 3, 0, 100);
      const noveltyScore = clamp(novelty * 10, 0, 10);
      const S_news = 40 * (tonePercentile / 100) + 20 * (1 - tailPercentile / 100) + 10 * noveltyScore;
      const redditPosts = reddit?.data?.data?.children?.map(c => c.data) || [];
      const redditMetrics = analyzeReddit(redditPosts);
      let crowdPenalty = redditMetrics.spamPenalty;
      if (domainConcentration > 0.6) crowdPenalty -= 10;
      const S = clamp(S_news + redditMetrics.velocity + redditMetrics.polarity, 0, 100);

      const turnoverPercentile = clamp(percentileRank(volumes.slice(-60), last.volume), 0, 100);
      const atr = computeATR(data).at(-1) || 0;
      const atrPercentile = clamp(percentileRank(computeATR(data).filter(Boolean), atr), 0, 100);
      const P = clamp(turnoverPercentile * 0.35 + atrPercentile * 0.25 + Math.max(0, redditMetrics.velocity / 2) - crowdPenalty, 0, 100);

      const alphaRaw = 0.35 * T + 0.20 * F + 0.30 * S + 0.15 * P;
      const m = regimeMultipliers.current;
      const alpha = alphaRaw * ((0.25 * m.T + 0.20 * m.F + 0.30 * m.S + 0.15 * m.P) / (0.25 + 0.20 + 0.30 + 0.15));

      const liquidity = (median(volumes.slice(-20)) || 0) * last.close / 1e6;
      const dataSufficient = data.length >= 60;
      const catalystSufficient = (articles.length >= 5) || events.length >= 1;
      const passesGates = liquidity >= filters.minLiquidity && dataSufficient && catalystSufficient && (!filters.excludeEtfs || !ticker.endsWith('-US')) && (last.close >= 2 || alpha > 85);

      const horizonScores = computeHorizonScores({ T, F, S, P });
      const penalties = [];
      if (crowdPenalty) penalties.push(`crowding ${crowdPenalty}`);
      if (parabolic < 0) penalties.push(`parabolic ${parabolic}`);

      const corroborations = [T > 55, S > filters.sentimentThreshold, events.length > 0].filter(Boolean).length;
      const confidence = clamp(Math.min(1, corroborations / 3), 0, 1);

      const probabilities = {
        p_1w_ge_10: logistic(-1.2 + 0.02 * rs20 + (squeezeMeta.squeeze ? 0.8 : 0) + 0.01 * redditMetrics.velocity + 0.005 * turnoverPercentile),
        p_1m_ge_20: logistic(-1 + 0.015 * rs60 + 0.02 * medianTone + 0.01 * events.length + 0.005 * atrPercentile),
        p_6_12m_ge_50: logistic(-1.5 + 0.012 * rs120 + 0.015 * events.length + 0.5 * novelty + 0.01 * trendScore)
      };

      const catalystMap = events.map(event => ({
        date: event.date,
        type: event.type.includes('ownership') ? 'M&A' : /10-Q/.test(event.form) ? 'earnings' : 'regulatory',
        source: 'SEC'
      }));
      (stories || []).slice(0, 3).forEach(story => {
        if (!story.url) return;
        catalystMap.push({ date: story.seendate || story.published || '', type: 'press', source: 'GDELT' });
      });

      return {
        as_of: nowIso(),
        regime: regimeMultipliers.regime,
        ticker,
        name: metadata[ticker]?.name || ticker,
        sector: metadata[ticker]?.sector || 'Unknown',
        scores: { T, F, S, P, alpha, alpha_h: horizonScores[currentHorizon], confidence },
        signals: {
          rs20,
          rs60,
          bbw_rank: percentileRank(bbw.filter(Boolean), bbw.at(-1) || 0),
          squeeze: squeezeMeta.squeeze,
          turnover_prc: turnoverPercentile,
          atr_prc: atrPercentile,
          gdelt_median_tone_7d: medianTone,
          gdelt_tail_risk: tailRisk,
          reddit_velocity_z: redditMetrics.velocity,
          reddit_polarity: redditMetrics.polarity,
          sec_events: events.map(e => ({ form: e.form, type: e.type, date: e.date })),
          novelty
        },
        probabilities,
        catalysts: catalystMap,
        penalties,
        evidence: {
          headlines: (stories || []).slice(0, 3).map(story => ({
            domain: (() => { try { return new URL(story.url).hostname; } catch (err) { return 'unknown'; } })(),
            title: story.title || '',
            time: story.seendate || story.published || ''
          })),
          sec_refs: events.map(e => e.accession),
          reddit_refs: redditPosts.slice(0, 3).map(p => `https://www.reddit.com${p.permalink}`)
        },
        horizonScores,
        passesGates,
        liquidity,
        last,
        novelty,
        squeezeMeta,
        redditMetrics,
        events,
        stories,
        data,
        gdelt,
        reddit,
        filings
      };
    };

    /* ======================================================
       Macro regime detection
    ====================================================== */
    const regimeMultipliers = {
      current: { T: 1, F: 1, S: 1, P: 1 },
      regime: 'Neutral'
    };

    const detectRegime = async () => {
      try {
        const spyData = (await fetchStooq('spy.us')).data;
        const vixData = (await fetchStooq('^vix')).data;
        const closes = spyData.map(d => d.close);
        const sma200 = computeSMA(closes, 200).at(-1);
        const priceAbove200 = closes.at(-1) > (sma200 || Infinity);
        const vixLevel = vixData.at(-1)?.close || 20;
        let regime = 'Neutral';
        if (priceAbove200 && vixLevel < 15) regime = 'RiskOn';
        if (!priceAbove200 || vixLevel > 22) regime = 'RiskOff';
        regimeMultipliers.regime = regime;
        regimeMultipliers.current = {
          T: regime === 'RiskOff' ? 0.9 : regime === 'RiskOn' ? 1.1 : 1,
          F: regime === 'RiskOff' ? 1.1 : 0.95,
          S: regime === 'RiskOff' ? 0.9 : 1.05,
          P: regime === 'RiskOff' ? 0.95 : 1.05
        };
        document.getElementById('asOf').textContent = `As of ${new Date().toLocaleString()} • Regime: ${regime}`;
        return spyData;
      } catch (err) {
        console.error('Regime detection failed', err);
        regimeMultipliers.current = { T: 1, F: 1, S: 1, P: 1 };
        regimeMultipliers.regime = 'Neutral';
        return [];
      }
    };

    /* ======================================================
       Rendering logic
    ====================================================== */
    const renderResults = (results, horizon) => {
      const list = document.getElementById('resultsList');
      list.innerHTML = '';
      if (!results.length) {
        list.innerHTML = '<p style="padding:16px;color:var(--text-muted);">No candidates passed quality gates.</p>';
        return;
      }
      const rowHeight = 96;
      const container = list;
      const totalHeight = rowHeight * results.length;
      const spacer = document.createElement('div');
      spacer.style.height = `${totalHeight}px`;
      spacer.style.position = 'relative';
      container.appendChild(spacer);

      const renderSlice = () => {
        const scrollTop = container.scrollTop;
        const height = container.clientHeight;
        const start = Math.floor(scrollTop / rowHeight);
        const end = Math.min(results.length, Math.ceil((scrollTop + height) / rowHeight) + 3);
        spacer.innerHTML = '';
        for (let i = start; i < end; i++) {
          const item = results[i];
          const row = document.createElement('div');
          row.className = 'row';
          row.setAttribute('role', 'listitem');
          row.style.position = 'absolute';
          row.style.top = `${i * rowHeight}px`;
          row.innerHTML = `
            <span class="ticker">${item.ticker}</span>
            <span>${item.name}</span>
            <span class="alpha" style="color:${colorForScore(item.horizonScores[horizon])}">${item.horizonScores[horizon].toFixed(1)}</span>
            <span>T ${item.scores.T.toFixed(0)}</span>
            <span>F ${item.scores.F.toFixed(0)}</span>
            <span>S ${item.scores.S.toFixed(0)}</span>
            <span>P ${item.scores.P.toFixed(0)}</span>
            <span>${formatNumber(item.last.close, { style: 'currency', currency: 'USD' })}</span>
          `;
          row.addEventListener('click', () => toggleDossier(row, item));
          spacer.appendChild(row);
        }
      };

      container.addEventListener('scroll', renderSlice);
      renderSlice();
    };

    const drawSparkline = (canvas, data) => {
      const ctx = canvas.getContext('2d');
      const width = canvas.width = canvas.clientWidth;
      const height = canvas.height = canvas.clientHeight;
      if (!data.length) return;
      const max = Math.max(...data);
      const min = Math.min(...data);
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((value, idx) => {
        const x = (idx / (data.length - 1 || 1)) * width;
        const y = height - ((value - min) / ((max - min) || 1)) * height;
        if (idx === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
    };

    const drawVolume = (canvas, data) => {
      const ctx = canvas.getContext('2d');
      const width = canvas.width = canvas.clientWidth;
      const height = canvas.height = canvas.clientHeight;
      if (!data.length) return;
      const max = Math.max(...data);
      const barWidth = width / data.length;
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-muted');
      data.forEach((value, idx) => {
        const x = idx * barWidth;
        const barHeight = (value / (max || 1)) * height;
        ctx.fillRect(x, height - barHeight, Math.max(barWidth - 1, 1), barHeight);
      });
    };

    const toggleDossier = (row, item) => {
      const expanded = row.classList.toggle('expanded');
      row.querySelector('.dossier')?.remove();
      if (!expanded) return;
      const dossier = document.createElement('div');
      dossier.className = 'dossier';
      const priceCanvas = document.createElement('canvas');
      priceCanvas.className = 'sparkline';
      drawSparkline(priceCanvas, item.data.map(d => d.close));
      const volumeCanvas = document.createElement('canvas');
      volumeCanvas.className = 'volume-bars';
      drawVolume(volumeCanvas, item.data.map(d => d.volume));
      const subscores = document.createElement('div');
      subscores.className = 'subscores';
      ['T', 'F', 'S', 'P'].forEach(key => {
        const box = document.createElement('div');
        box.className = 'score-box';
        box.style.borderColor = colorForScore(item.scores[key]);
        box.innerHTML = `<strong>${key}</strong><div>${item.scores[key].toFixed(1)}</div>`;
        subscores.appendChild(box);
      });
      const catalysts = document.createElement('div');
      catalysts.className = 'catalysts';
      catalysts.innerHTML = `<strong>Catalysts</strong>` + (item.catalysts.slice(0, 6).map(c => `<div>${c.date || '—'} • ${c.type} (${c.source})</div>`).join('') || '<div>—</div>');
      const risks = document.createElement('div');
      risks.className = 'risks';
      risks.innerHTML = `<strong>Risks</strong>` + (item.penalties.length ? item.penalties.map(p => `<div>${p}</div>`).join('') : '<div>—</div>');
      const evidence = document.createElement('div');
      evidence.className = 'evidence';
      evidence.innerHTML = `<strong>Evidence</strong>` + (item.evidence.headlines.length ? item.evidence.headlines.map(story => `<div>${story.title} (${story.domain})</div>`).join('') : '<div>No headlines</div>');
      const actions = document.createElement('div');
      actions.className = 'flex-row';
      const watchBtn = document.createElement('button');
      watchBtn.className = 'flush-btn';
      watchBtn.textContent = 'Add to Watchlist';
      watchBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        addToWatchlist(item);
      });
      actions.appendChild(watchBtn);
      dossier.append(priceCanvas, volumeCanvas, subscores, catalysts, risks, evidence, actions);
      row.appendChild(dossier);
    };

    /* ======================================================
       Watchlist management
    ====================================================== */
    const Watchlist = (() => {
      let items = [];
      try {
        const raw = localStorage.getItem(STORAGE_KEYS.WATCHLIST);
        items = raw ? JSON.parse(raw) : [];
      } catch (err) {
        items = [];
      }
      const persist = () => localStorage.setItem(STORAGE_KEYS.WATCHLIST, JSON.stringify(items));
      return {
        all: () => items,
        add(entry) {
          if (!items.some(i => i.ticker === entry.ticker)) {
            items.push({ ticker: entry.ticker, name: entry.name, added: nowIso() });
            persist();
            renderWatchlist();
          }
        },
        remove(ticker) {
          items = items.filter(i => i.ticker !== ticker);
          persist();
          renderWatchlist();
        },
        clear() {
          items = [];
          persist();
          renderWatchlist();
        }
      };
    })();

    const renderWatchlist = () => {
      const list = document.getElementById('watchlistItems');
      list.innerHTML = '';
      Watchlist.all().forEach(item => {
        const row = document.createElement('div');
        row.textContent = `${item.ticker} • added ${new Date(item.added).toLocaleString()}`;
        const remove = document.createElement('button');
        remove.textContent = 'Remove';
        remove.addEventListener('click', () => Watchlist.remove(item.ticker));
        row.appendChild(remove);
        list.appendChild(row);
      });
      const select = document.getElementById('watchlistSelect');
      const current = select.value;
      select.innerHTML = '<option value="">None</option>' + Watchlist.all().map(item => `<option value="${item.ticker}">${item.ticker}</option>`).join('');
      select.value = current;
    };

    const addToWatchlist = (item) => Watchlist.add({ ticker: item.ticker, name: item.name });

    /* ======================================================
       Diagnostics & logging
    ====================================================== */
    const diagnostics = [];
    const logDiagnostic = (entry) => {
      diagnostics.push({ ...entry, timestamp: nowIso() });
      localStorage.setItem(STORAGE_KEYS.DIAGNOSTICS, JSON.stringify(diagnostics.slice(-200)));
      renderDiagnostics();
    };

    const renderDiagnostics = () => {
      const table = document.getElementById('diagnosticsTable');
      table.innerHTML = '<tr><th>Time</th><th>Origin</th><th>Status</th><th>Duration</th></tr>' + diagnostics.slice(-50).reverse().map(entry => `
        <tr>
          <td>${new Date(entry.timestamp).toLocaleTimeString()}</td>
          <td>${entry.origin}</td>
          <td>${entry.status}</td>
          <td>${entry.duration?.toFixed?.(1) || '—'} ms</td>
        </tr>
      `).join('');
    };

    /* ======================================================
       Universe filters and runner
    ====================================================== */
    const filters = {
      sector: 'all',
      cap: 'all',
      minLiquidity: 1,
      sentimentThreshold: 30,
      rsThreshold: -20,
      excludeEtfs: true
    };

    let currentHorizon = 'Week';
    let metadata = {};
    let spyCache = [];
    const pool = new FetchPool(6);

    const buildUniverse = async () => {
      const source = document.getElementById('universeSource').value;
      if (source === 'custom') {
        const raw = document.getElementById('customTickers').value;
        const tickers = raw.split(/[^A-Z0-9\-]+/i).map(t => t.trim().toUpperCase()).filter(Boolean);
        metadata = tickers.reduce((acc, ticker) => {
          acc[ticker] = { name: ticker, sector: 'Custom' };
          return acc;
        }, {});
        document.getElementById('universeSummary').textContent = `Universe: ${tickers.length} tickers`;
        return tickers;
      }
      const watchlistTicker = document.getElementById('watchlistSelect').value;
      const universe = await loadUniverse(source);
      metadata = universe.reduce((acc, entry) => {
        acc[entry.ticker.toUpperCase()] = { name: entry.name, sector: entry.sector };
        return acc;
      }, {});
      if (watchlistTicker) {
        document.getElementById('universeSummary').textContent = `Universe: watchlist ${watchlistTicker}`;
        return [watchlistTicker];
      }
      document.getElementById('universeSummary').textContent = `Universe: ${universe.length} tickers`;
      const sectors = Array.from(new Set(universe.map(u => u.sector))).sort();
      const sectorFilter = document.getElementById('sectorFilter');
      sectorFilter.innerHTML = '<option value="all">All</option>' + sectors.map(sector => `<option value="${sector}">${sector}</option>`).join('');
      return universe.map(u => u.ticker.toUpperCase());
    };

    const inferCapBucket = (item) => {
      const base = item.last.close * (item.filings?.company?.sharesOutstanding || 0);
      const cap = base || (item.liquidity * 1e6 * 20);
      if (cap > 200e9) return 'mega';
      if (cap > 10e9) return 'large';
      if (cap > 2e9) return 'mid';
      return 'small';
    };

    const applyFilters = (items) => {
      return items.filter(item => {
        if (!item.passesGates) return false;
        if (filters.sector !== 'all' && item.sector !== filters.sector) return false;
        if (filters.cap !== 'all' && inferCapBucket(item) !== filters.cap) return false;
        if (item.rs20 < filters.rsThreshold) return false;
        if (item.scores.S < filters.sentimentThreshold) return false;
        if (filters.excludeEtfs && item.ticker.includes('-US')) return false;
        return true;
      });
    };

    const runScreener = async () => {
      document.getElementById('resultsMeta').textContent = 'Running…';
      const tickers = await buildUniverse();
      const limitedTickers = tickers.slice(0, 60);
      if (!spyCache.length) spyCache = (await detectRegime()) || [];
      const spyCloses = spyCache.map(d => d.close);
      const results = [];
      for (const ticker of limitedTickers) {
        try {
          const startTime = performance.now();
          const [stooq, gdelt, reddit, filings] = await Promise.all([
            pool.enqueue(() => fetchStooq(`${ticker.toLowerCase()}.us`)),
            pool.enqueue(() => fetchGdelt(`${ticker} OR "${metadata[ticker]?.name || ticker}"`)),
            pool.enqueue(() => fetchReddit(`${ticker} OR ${metadata[ticker]?.name || ticker}`)),
            pool.enqueue(() => fetchSecFilings(ticker))
          ]);
          const duration = performance.now() - startTime;
          logDiagnostic({ origin: ticker, status: 'ok', duration });
          const scored = computeScores({ ticker, data: stooq.data, spy: spyCloses, gdelt, reddit, filings: filings.data });
          if (scored) results.push(scored);
        } catch (err) {
          console.error('Processing error', ticker, err);
          logDiagnostic({ origin: ticker, status: 'error' });
        }
      }
      const filtered = applyFilters(results);
      const horizon = currentHorizon;
      const ranked = filtered
        .filter(item => {
          const sWeight = item.scores.S / (item.scores.T + item.scores.F + item.scores.S + item.scores.P || 1);
          if (sWeight > 0.7 && !item.squeezeMeta.squeeze) return false;
          return true;
        })
        .sort((a, b) => b.horizonScores[horizon] - a.horizonScores[horizon] || b.scores.confidence - a.scores.confidence || b.novelty - a.novelty);
      renderResults(ranked, horizon);
      document.getElementById('resultsMeta').textContent = `${ranked.length} opportunities • Horizon ${horizon}`;
    };

    /* ======================================================
       Settings persistence
    ====================================================== */
    const saveSettings = () => {
      const settings = {
        filters,
        currentHorizon,
        universeSource: document.getElementById('universeSource').value
      };
      localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
    };

    const loadSettings = () => {
      try {
        const raw = localStorage.getItem(STORAGE_KEYS.SETTINGS);
        if (!raw) return;
        const settings = JSON.parse(raw);
        Object.assign(filters, settings.filters || {});
        currentHorizon = settings.currentHorizon || 'Week';
        document.getElementById('universeSource').value = settings.universeSource || 'sp500';
        document.querySelectorAll('.segmented button').forEach(btn => btn.classList.toggle('active', btn.dataset.horizon === currentHorizon));
        document.getElementById('sectorFilter').value = filters.sector;
        document.getElementById('capFilter').value = filters.cap;
        document.getElementById('liquidityFilter').value = filters.minLiquidity;
        document.getElementById('sentimentFilter').value = filters.sentimentThreshold;
        document.getElementById('rsFilter').value = filters.rsThreshold;
        document.getElementById('excludeEtfs').checked = filters.excludeEtfs;
      } catch (err) {
        console.warn('Failed to load settings', err);
      }
    };

    /* ======================================================
       Event bindings
    ====================================================== */
    document.getElementById('runScreen').addEventListener('click', runScreener);
    document.getElementById('flushCache').addEventListener('click', () => {
      CacheStore.flush();
      alert('Cache cleared.');
    });
    document.getElementById('sectorFilter').addEventListener('change', (ev) => { filters.sector = ev.target.value; saveSettings(); });
    document.getElementById('capFilter').addEventListener('change', (ev) => { filters.cap = ev.target.value; saveSettings(); });
    document.getElementById('liquidityFilter').addEventListener('input', (ev) => { filters.minLiquidity = Number(ev.target.value); saveSettings(); });
    document.getElementById('sentimentFilter').addEventListener('input', (ev) => { filters.sentimentThreshold = Number(ev.target.value); saveSettings(); });
    document.getElementById('rsFilter').addEventListener('input', (ev) => { filters.rsThreshold = Number(ev.target.value); saveSettings(); });
    document.getElementById('excludeEtfs').addEventListener('change', (ev) => { filters.excludeEtfs = ev.target.checked; saveSettings(); });
    document.querySelectorAll('.segmented button').forEach(btn => btn.addEventListener('click', () => {
      document.querySelectorAll('.segmented button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentHorizon = btn.dataset.horizon;
      saveSettings();
    }));
    document.getElementById('openDiagnostics').addEventListener('click', () => {
      document.getElementById('diagnostics').setAttribute('aria-hidden', 'false');
    });
    document.getElementById('closeDiagnostics').addEventListener('click', () => {
      document.getElementById('diagnostics').setAttribute('aria-hidden', 'true');
    });
    document.getElementById('exportWatchlist').addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(Watchlist.all(), null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `gemfinder-watchlist-${Date.now()}.json`;
      link.click();
      URL.revokeObjectURL(url);
    });
    document.getElementById('importWatchlist').addEventListener('change', async (ev) => {
      const file = ev.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        JSON.parse(text).forEach(entry => Watchlist.add(entry));
      } catch (err) {
        alert('Invalid watchlist file');
      }
    });

    /* ======================================================
       Service worker registration
    ====================================================== */
    const registerServiceWorker = async () => {
      if (!('serviceWorker' in navigator)) return;
      const script = `
        const CACHE_NAME = 'gemfinder-shell-v1';
        const RUNTIME_CACHE = 'gemfinder-runtime-v1';
        const OFFLINE_URLS = ['.'];
        self.addEventListener('install', event => {
          event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(OFFLINE_URLS)));
        });
        self.addEventListener('activate', event => {
          event.waitUntil(caches.keys().then(keys => Promise.all(keys.filter(key => ![CACHE_NAME, RUNTIME_CACHE].includes(key)).map(key => caches.delete(key)))));
        });
        const fetchWithTimeout = async (request) => {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), 10000);
          try {
            const response = await fetch(request, { signal: controller.signal });
            if (!response.ok) throw new Error('Network error');
            return response;
          } finally {
            clearTimeout(id);
          }
        };
        self.addEventListener('fetch', event => {
          const { request } = event;
          if (request.method !== 'GET') return;
          if (request.mode === 'navigate') {
            event.respondWith(fetchWithTimeout(request).catch(() => caches.match('.')));
            return;
          }
          event.respondWith(
            caches.open(RUNTIME_CACHE).then(async cache => {
              try {
                const response = await fetchWithTimeout(request.clone());
                cache.put(request, response.clone());
                return response;
              } catch (err) {
                const cached = await cache.match(request);
                if (cached) return cached;
                throw err;
              }
            })
          );
        });
      `;
      const blob = new Blob([script], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      try {
        await navigator.serviceWorker.register(url);
      } catch (err) {
        console.warn('SW registration failed', err);
      }
    };

    /* ======================================================
       Initialization
    ====================================================== */
    const init = async () => {
      renderWatchlist();
      loadSettings();
      renderDiagnostics();
      await registerServiceWorker();
      try {
        spyCache = (await detectRegime()) || [];
      } catch (err) {
        console.warn('Bootstrap regime detection failed', err);
      }
      try {
        await runScreener();
      } catch (err) {
        console.error('Initial screener run failed', err);
        document.getElementById('resultsMeta').textContent = 'Initial run failed';
      }
    };

    window.addEventListener('load', () => {
      init().catch(err => console.error('Init failure', err));
    });
  </script>
</body>
</html>
