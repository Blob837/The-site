<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="theme-color" content="#0b0f14">
    <meta name="description" content="College Football Winner Predictor with live data and ML models">
    <title>CFB Predictor</title>
    <style>
        :root {
            --bg-primary: #0b0f14;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #2a3441;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-danger: #ef4444;
            --accent-warning: #f59e0b;
            --border-primary: #374151;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        @media (prefers-color-scheme: light) {
            :root {
                --bg-primary: #ffffff;
                --bg-secondary: #f8fafc;
                --bg-tertiary: #e2e8f0;
                --text-primary: #1e293b;
                --text-secondary: #475569;
                --text-muted: #64748b;
                --border-primary: #e2e8f0;
                --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding-bottom: 80px;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-primary);
        }

        .week-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .week-nav {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .week-nav:hover {
            background: var(--accent-primary);
        }

        .week-display {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 0.375rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .settings-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        .loading-skeleton {
            background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--bg-tertiary) 50%, var(--bg-secondary) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 0.5rem;
            height: 120px;
            margin-bottom: 1rem;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .games-container {
            display: grid;
            gap: 1rem;
            grid-template-columns: 1fr;
        }

        @media (min-width: 768px) {
            .games-container {
                grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            }
        }

        .game-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: transform 0.2s ease;
        }

        .game-card:hover {
            transform: translateY(-2px);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .game-time {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-align: right;
        }

        .venue {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
        }

        .team {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        .team-name {
            font-weight: bold;
            font-size: 1.125rem;
            margin-bottom: 0.25rem;
        }

        .team-record {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .vs {
            margin: 0 1rem;
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .prediction {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
        }

        .prob-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .confidence-ring {
            width: 40px;
            height: 40px;
            position: relative;
        }

        .confidence-ring svg {
            transform: rotate(-90deg);
        }

        .confidence-bg {
            fill: none;
            stroke: var(--bg-tertiary);
            stroke-width: 3;
        }

        .confidence-fill {
            fill: none;
            stroke: var(--accent-secondary);
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dasharray 0.3s ease;
        }

        .prob-text {
            font-weight: bold;
            font-size: 1.125rem;
        }

        .edge-badge {
            background: var(--accent-warning);
            color: var(--bg-primary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .drivers {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .driver-chip {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
        }

        .driver-chip.positive {
            background: var(--accent-secondary);
            color: var(--bg-primary);
        }

        .driver-chip.negative {
            background: var(--accent-danger);
            color: var(--text-primary);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.375rem;
            min-width: 44px;
            min-height: 44px;
        }

        .close-btn:hover {
            background: var(--bg-tertiary);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 0.375rem;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .checkbox {
            width: 1.25rem;
            height: 1.25rem;
        }

        .button {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-height: 44px;
        }

        .button:hover {
            background: #2563eb;
        }

        .button.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .button.secondary:hover {
            background: var(--border-primary);
        }

        .button.danger {
            background: var(--accent-danger);
        }

        .button.danger:hover {
            background: #dc2626;
        }

        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-primary);
            padding: 1rem;
            z-index: 100;
        }

        .bottom-actions {
            display: flex;
            gap: 0.75rem;
            max-width: 1200px;
            margin: 0 auto;
            justify-content: center;
            flex-wrap: wrap;
        }

        .bottom-actions .button {
            flex: 1;
            min-width: 120px;
        }

        .toast {
            position: fixed;
            top: 80px;
            left: 1rem;
            right: 1rem;
            background: var(--accent-danger);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            z-index: 1100;
            transform: translateY(-100px);
            transition: transform 0.3s ease;
            box-shadow: var(--shadow);
        }

        .toast.show {
            transform: translateY(0);
        }

        .toast.success {
            background: var(--accent-secondary);
        }

        .toast.warning {
            background: var(--accent-warning);
            color: var(--bg-primary);
        }

        .filters {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 0.375rem;
            color: var(--text-primary);
            min-height: 44px;
        }

        .sort-select {
            margin-left: auto;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">CFB Predictor</div>
            <div class="week-selector">
                <button class="week-nav" id="prevWeek" aria-label="Previous week">‚Üê</button>
                <div class="week-display" id="weekDisplay">This Weekend</div>
                <button class="week-nav" id="nextWeek" aria-label="Next week">‚Üí</button>
            </div>
            <button class="settings-btn" id="settingsBtn" aria-label="Settings">‚öôÔ∏è</button>
        </div>
    </header>

    <main class="main-content">
        <div class="filters">
            <select class="filter-select" id="conferenceFilter">
                <option value="">All Conferences</option>
            </select>
            <select class="filter-select" id="teamFilter">
                <option value="">All Teams</option>
            </select>
            <select class="filter-select sort-select" id="sortBy">
                <option value="confidence">Sort by Confidence</option>
                <option value="edge">Sort by Edge</option>
                <option value="time">Sort by Kickoff</option>
            </select>
        </div>

        <div class="games-container" id="gamesContainer">
            <div class="loading-skeleton"></div>
            <div class="loading-skeleton"></div>
            <div class="loading-skeleton"></div>
        </div>

        <div class="empty-state" id="emptyState" style="display: none;">
            <div class="empty-icon">üèà</div>
            <h3>No games found</h3>
            <p>Try adjusting your filters or check back later</p>
        </div>
    </main>

    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="close-btn" id="closeSettings">√ó</button>
            </div>
            
            <div class="form-group">
                <label class="form-label" for="cfbdKey">CFBD API Key *</label>
                <input type="password" class="form-input" id="cfbdKey" placeholder="Enter your CFBD API key">
                <small style="color: var(--text-muted); display: block; margin-top: 0.5rem;">
                    Get your free key at <a href="https://collegefootballdata.com" target="_blank" style="color: var(--accent-primary);">collegefootballdata.com</a>
                </small>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="useMarkets" checked>
                <label for="useMarkets">Use betting markets</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="useWeather" checked>
                <label for="useWeather">Use weather forecasts</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="manualInjuries">
                <label for="manualInjuries">Manual injury tracking</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="demoMode">
                <label for="demoMode">Demo mode (offline data)</label>
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem; flex-wrap: wrap;">
                <button class="button" id="saveSettings">Save Settings</button>
                <!-- Added Test API button so users can validate their key against the v2 endpoint -->
                <button class="button secondary" id="testApi">Test API</button>
                <button class="button secondary" id="closeSettings2">Cancel</button>
                <button class="button danger" id="forgetKeys">Forget Keys</button>
            </div>
        </div>
    </div>

    <div class="bottom-bar">
        <div class="bottom-actions">
            <!-- Renamed to match the expected user flow described in the requirements -->
            <button class="button" id="loadGames">Load Games</button>
            <button class="button" id="predict">Predict</button>
            <button class="button secondary" id="exportData">Export JSON</button>
            <button class="button secondary" id="resetApp">Reset</button>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Demo data that matches actual CFBD API structure
        const DEMO_DATA = {
            games: [
                {
                    id: 401628492,
                    season: 2024,
                    week: 12,
                    season_type: "regular",
                    start_date: "2024-11-30T19:30:00.000Z",
                    neutral_site: false,
                    conference_game: true,
                    home_team: "Texas A&M",
                    home_conference: "SEC",
                    home_points: null,
                    away_team: "Texas",
                    away_conference: "SEC", 
                    away_points: null,
                    venue: "Kyle Field"
                },
                {
                    id: 401628493,
                    season: 2024,
                    week: 12,
                    season_type: "regular",
                    start_date: "2024-11-30T20:00:00.000Z",
                    neutral_site: false,
                    conference_game: true,
                    home_team: "Auburn",
                    home_conference: "SEC",
                    home_points: null,
                    away_team: "Alabama", 
                    away_conference: "SEC",
                    away_points: null,
                    venue: "Jordan-Hare Stadium"
                }
            ],
            calendar: [
                {
                    season: 2024,
                    season_type: "regular",
                    week: 12,
                    start_date: "2024-11-25T00:00:00.000Z",
                    end_date: "2024-12-01T23:59:59.000Z"
                },
                {
                    season: 2024,
                    season_type: "postseason",
                    week: 1,
                    start_date: "2024-12-02T00:00:00.000Z",
                    end_date: "2024-12-09T23:59:59.000Z"
                }
            ],
            elo: [
                { team: "Texas", elo: 1650 },
                { team: "Texas A&M", elo: 1580 },
                { team: "Alabama", elo: 1620 },
                { team: "Auburn", elo: 1520 }
            ],
            ppa: [
                { team: "Texas", overall: { ppa: 0.15 }, passing: { ppa: 0.12 }, rushing: { ppa: 0.08 } },
                { team: "Texas A&M", overall: { ppa: 0.08 }, passing: { ppa: 0.06 }, rushing: { ppa: 0.04 } },
                { team: "Alabama", overall: { ppa: 0.12 }, passing: { ppa: 0.10 }, rushing: { ppa: 0.06 } },
                { team: "Auburn", overall: { ppa: 0.02 }, passing: { ppa: 0.01 }, rushing: { ppa: 0.02 } }
            ],
            lines: [
                {
                    id: 401628492,
                    season: 2024,
                    week: 12,
                    season_type: "regular",
                    start_date: "2024-11-30T19:30:00.000Z",
                    home_team: "Texas A&M",
                    away_team: "Texas",
                    home_conference: "SEC",
                    away_conference: "SEC",
                    home_score: null,
                    away_score: null,
                    lines: [
                        {
                            provider: "consensus",
                            spread: -7.5,
                            formatted_spread: "Texas A&M -7.5",
                            spread_open: -6.5,
                            over_under: 48.5,
                            over_under_open: 47.5,
                            home_moneyline: -280,
                            away_moneyline: 240
                        }
                    ]
                }
            ]
        };

        function getDefaultSeason(date = new Date()) {
            return date.getMonth() >= 7 ? date.getFullYear() : date.getFullYear() - 1;
        }

        // Application state
        const AppState = {
            currentWeek: null,
            currentSeason: getDefaultSeason(),
            currentSeasonType: 'regular',
            currentCalendarIndex: null,
            activeCalendarIndex: null,
            settings: {
                cfbdKey: localStorage.getItem('cfbd_key') || '',
                useMarkets: true,
                useWeather: true,
                manualInjuries: false,
                demoMode: false
            },
            cache: {
                games: null,
                metrics: null,
                weather: null,
                lines: null,
                calendar: null,
                lastUpdate: null
            },
            predictions: null
        };

        // Rate limiter
        class RateLimiter {
            constructor(tokensPerSecond = 2, maxTokens = 5) {
                this.tokensPerSecond = tokensPerSecond;
                this.maxTokens = maxTokens;
                this.tokens = maxTokens;
                this.lastRefill = Date.now();
            }

            async waitForToken() {
                const now = Date.now();
                const timePassed = (now - this.lastRefill) / 1000;
                this.tokens = Math.min(this.maxTokens, this.tokens + timePassed * this.tokensPerSecond);
                this.lastRefill = now;

                if (this.tokens >= 1) {
                    this.tokens -= 1;
                    return;
                }

                const waitTime = (1 - this.tokens) / this.tokensPerSecond * 1000;
                await new Promise(resolve => setTimeout(resolve, waitTime + Math.random() * 100));
                this.tokens = 0;
            }
        }

        // CFBD API client
        class CFBDClient {
            constructor() {
                // v1 host stopped serving requests for this app - point to the v2 "apinext" host instead.
                this.baseURL = 'https://apinext.collegefootballdata.com';
                this.rateLimiter = new RateLimiter(2, 5);
            }

            normalizeSeasonType(seasonType = 'regular') {
                if (!seasonType) return 'regular';
                const normalized = String(seasonType).toLowerCase();
                if (['regular', 'regular_season'].includes(normalized)) {
                    return 'regular';
                }
                if (['postseason', 'post_season'].includes(normalized)) {
                    return 'postseason';
                }
                if (normalized === 'both') {
                    return 'both';
                }
                if (normalized.includes('champ')) {
                    return 'postseason';
                }
                if (normalized.includes('bowl') || normalized.includes('playoff')) {
                    return 'postseason';
                }
                return 'regular';
            }

            async fetch(endpoint, params = {}) {
                // Prevent silent failures when no key was saved.
                if (!AppState.settings.cfbdKey && !AppState.settings.demoMode) {
                    throw new Error('CFBD API key required');
                }

                if (AppState.settings.demoMode) {
                    console.log('[CFBD] Demo mode request', { endpoint, params });
                    return this.getDemoData(endpoint);
                }

                await this.rateLimiter.waitForToken();

                const url = new URL(endpoint, this.baseURL);
                Object.entries(params).forEach(([key, value]) => {
                    if (value !== null && value !== undefined) {
                        url.searchParams.append(key, value);
                    }
                });
                const requestUrl = url.toString();

                console.log('[CFBD] Request', { url: requestUrl, params });

                let response;
                try {
                    response = await fetch(requestUrl, {
                        headers: {
                            'Authorization': `Bearer ${AppState.settings.cfbdKey}`,
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });
                } catch (networkError) {
                    console.error('[CFBD] Network error', networkError);
                    throw new Error('Network error reaching CollegeFootballData API');
                }

                const rawText = await response.text();
                let data = null;

                if (rawText) {
                    try {
                        data = JSON.parse(rawText);
                    } catch (parseError) {
                        console.warn('[CFBD] Response parse fallback', parseError);
                        data = rawText;
                    }
                }

                console.log('[CFBD] Response', {
                    url: requestUrl,
                    status: response.status,
                    ok: response.ok,
                    sample: Array.isArray(data) ? data.slice(0, 5) : data
                });

                if (response.status === 401) {
                    throw new Error('Invalid CFBD API key');
                }
                if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please wait before retrying.');
                }
                if (!response.ok) {
                    let detail = '';
                    if (data && typeof data === 'object') {
                        detail = data.message || data.detail || JSON.stringify(data);
                    } else if (typeof data === 'string') {
                        detail = data;
                    }

                    if (detail.length > 200) {
                        detail = `${detail.slice(0, 200)}...`;
                    }

                    const suffix = detail ? ` - ${detail}` : '';
                    throw new Error(`CFBD API error: ${response.status}${suffix}`);
                }

                if (data === null || data === '') {
                    console.warn('[CFBD] Empty response body', { url: requestUrl });
                    return [];
                }

                return data;
            }

            // Added explicit connectivity check so we can validate credentials before loading games.
            async testConnection() {
                const teams = await this.fetch('/teams', { classification: 'fbs' });
                const normalized = Array.isArray(teams) ? teams : [];
                return {
                    count: normalized.length,
                    sample: normalized.slice(0, 5)
                };
            }

            getDemoData(endpoint) {
                console.log('Demo mode - endpoint:', endpoint);
                if (endpoint.includes('/games')) {
                    if (endpoint.includes('/weather')) return [];
                    return DEMO_DATA.games;
                }
                if (endpoint.includes('/calendar')) return DEMO_DATA.calendar;
                if (endpoint.includes('/ratings/elo')) return DEMO_DATA.elo;
                if (endpoint.includes('/metrics/ppa')) return DEMO_DATA.ppa;
                if (endpoint.includes('/lines')) return DEMO_DATA.lines;
                return [];
            }

            async getCalendar(season) {
                const data = await this.fetch('/calendar', { year: season });
                return Array.isArray(data) ? data : [];
            }

            async getGames(season, week, seasonType = 'regular') {
                const normalizedType = this.normalizeSeasonType(seasonType);
                const baseParams = { year: season, week };
                const seasonTypesToTry = normalizedType === 'both' ? ['both'] : [normalizedType, 'both'];

                for (const type of seasonTypesToTry) {
                    const paramsWithType = { ...baseParams, seasonType: type };
                    try {
                        let games = await this.fetch('/games', {
                            ...paramsWithType,
                            division: 'fbs'
                        });

                        if (!Array.isArray(games) || games.length === 0) {
                            games = await this.fetch('/games', paramsWithType);
                        }

                        if (Array.isArray(games) && games.length > 0) {
                            return games;
                        }
                    } catch (error) {
                        if (error.message.includes('CFBD API error: 400')) {
                            console.warn('Games request failed with division filter, retrying without it.', error);
                            const fallbackGames = await this.fetch('/games', paramsWithType);
                            if (Array.isArray(fallbackGames) && fallbackGames.length > 0) {
                                return fallbackGames;
                            }
                            continue;
                        }

                        if (error.message.includes('CFBD API error: 404')) {
                            console.warn(`No games found for ${JSON.stringify(paramsWithType)}, trying next season type.`, error);
                            continue;
                        }

                        throw error;
                    }
                }

                return [];
            }

            async getEloRatings(season, week) {
                const data = await this.fetch('/ratings/elo', { year: season, week });
                return Array.isArray(data) ? data : [];
            }

            async getPPAData(season, week) {
                const data = await this.fetch('/metrics/ppa/teams', { year: season, week });
                return Array.isArray(data) ? data : [];
            }

            async getLines(season, week, seasonType = 'regular') {
                const normalizedType = this.normalizeSeasonType(seasonType);
                const params = { year: season, week, seasonType: normalizedType };

                try {
                    let data = await this.fetch('/lines', params);

                    if ((!Array.isArray(data) || data.length === 0) && normalizedType !== 'both') {
                        data = await this.fetch('/lines', { ...params, seasonType: 'both' });
                    }

                    return Array.isArray(data) ? data : [];
                } catch (error) {
                    if (error.message.includes('CFBD API error: 404') && normalizedType !== 'both') {
                        const fallback = await this.fetch('/lines', { ...params, seasonType: 'both' });
                        return Array.isArray(fallback) ? fallback : [];
                    }

                    throw error;
                }
            }
        }

        // Math utilities
        const MathUtils = {
            sigmoid: (x) => 1 / (1 + Math.exp(-x)),
            
            calibrateProb: (rawProb) => {
                // Simple Platt scaling calibration
                const logit = Math.log(rawProb / (1 - rawProb));
                const calibratedLogit = 0.8 * logit;
                return 1 / (1 + Math.exp(-calibratedLogit));
            },
            
            spreadToProb: (spread) => {
                // Convert point spread to win probability
                return 1 / (1 + Math.exp(-spread / 14));
            },
            
            probToSpread: (prob) => {
                // Convert win probability to equivalent spread
                const logit = Math.log(prob / (1 - prob));
                return logit * 14;
            }
        };

        // Feature engineering
        class FeatureEngine {
            static engineerFeatures(game, eloData, ppaData, lines, weather) {
                const features = [];
                const featureNames = [];
                
                // Get team metrics
                const homeElo = eloData.find(t => t.team === game.home_team)?.elo || 1500;
                const awayElo = eloData.find(t => t.team === game.away_team)?.elo || 1500;
                
                const homePPA = ppaData.find(t => t.team === game.home_team)?.overall?.ppa || 0;
                const awayPPA = ppaData.find(t => t.team === game.away_team)?.overall?.ppa || 0;
                
                // Elo differential with home field advantage
                const homeAdvantage = game.neutral_site ? 0 : 65;
                const eloDiff = homeElo + homeAdvantage - awayElo;
                features.push(eloDiff);
                featureNames.push('elo_diff');
                
                // PPA differentials
                features.push(homePPA - awayPPA);
                featureNames.push('ppa_diff');
                
                // Home/Neutral flags
                features.push(game.neutral_site ? 0 : 1);
                featureNames.push('home_flag');
                
                features.push(game.neutral_site ? 1 : 0);
                featureNames.push('neutral_flag');
                
                // Weather adjustments (placeholder)
                features.push(0); // wind penalty
                features.push(0); // precip penalty
                featureNames.push('wind_penalty');
                featureNames.push('precip_penalty');
                
                // Market features if available
                const gameLines = lines.find(l => 
                    l.home_team === game.home_team && l.away_team === game.away_team
                );
                
                if (gameLines && gameLines.lines && gameLines.lines.length > 0 && AppState.settings.useMarkets) {
                    const line = gameLines.lines[0];
                    const spread = line.spread || 0;
                    features.push(spread);
                    featureNames.push('market_spread');
                } else {
                    features.push(0);
                    featureNames.push('market_spread');
                }
                
                return { features, featureNames };
            }
            
            static getGameDrivers(game, prediction, features, featureNames) {
                const drivers = [];
                
                // Elo difference driver
                const eloDiffIndex = featureNames.indexOf('elo_diff');
                const eloDiff = features[eloDiffIndex] || 0;
                if (Math.abs(eloDiff) > 50) {
                    drivers.push({
                        name: 'Elo Rating',
                        impact: eloDiff > 0 ? 'positive' : 'negative',
                        description: `${Math.abs(eloDiff).toFixed(0)} point ${eloDiff > 0 ? 'advantage' : 'disadvantage'}`
                    });
                }
                
                // PPA difference driver
                const ppaDiffIndex = featureNames.indexOf('ppa_diff');
                const ppaDiff = features[ppaDiffIndex] || 0;
                if (Math.abs(ppaDiff) > 0.05) {
                    drivers.push({
                        name: 'PPA Efficiency',
                        impact: ppaDiff > 0 ? 'positive' : 'negative',
                        description: `${(Math.abs(ppaDiff) * 100).toFixed(1)}% efficiency edge`
                    });
                }
                
                return drivers;
            }
        }

        // Main prediction engine
        class PredictionEngine {
            constructor() {
                this.cfbdClient = new CFBDClient();
                this.models = {
                    elo: { a: -0.001, b: 0.025 }
                };
            }
            
            async predict(games) {
                if (!games || games.length === 0) return [];

                showToast('Generating predictions...', 'success');

                try {
                    const seasonType = this.cfbdClient.normalizeSeasonType(AppState.currentSeasonType);
                    // Get all the data we need
                    const [eloData, ppaData, lines] = await Promise.all([
                        this.cfbdClient.getEloRatings(AppState.currentSeason, AppState.currentWeek).catch(() => []),
                        this.cfbdClient.getPPAData(AppState.currentSeason, AppState.currentWeek).catch(() => []),
                        AppState.settings.useMarkets ?
                            this.cfbdClient.getLines(AppState.currentSeason, AppState.currentWeek, seasonType).catch(() => []) :
                            []
                    ]);

                    console.log('Data loaded:', { 
                        games: games.length, 
                        elo: eloData.length, 
                        ppa: ppaData.length, 
                        lines: lines.length 
                    });
                    
                    const predictions = [];
                    
                    for (const game of games) {
                        // Skip completed games
                        if (game.home_points !== null || game.away_points !== null) continue;
                        
                        // Engineer features
                        const { features, featureNames } = FeatureEngine.engineerFeatures(
                            game, eloData, ppaData, lines, null
                        );
                        
                        // Elo-based prediction
                        const eloDiff = features[0];
                        const probElo = MathUtils.sigmoid(this.models.elo.a + this.models.elo.b * eloDiff);
                        
                        // Calibrated final prediction
                        const probFinal = MathUtils.calibrateProb(probElo);
                        
                        // Calculate edge vs market if available
                        let edge = null;
                        const gameLines = lines.find(l => 
                            l.home_team === game.home_team && l.away_team === game.away_team
                        );
                        
                        if (gameLines && gameLines.lines && gameLines.lines.length > 0) {
                            const line = gameLines.lines[0];
                            if (line.spread !== undefined) {
                                const impliedProb = MathUtils.spreadToProb(-line.spread);
                                edge = Math.abs(probFinal - impliedProb);
                            }
                        }
                        
                        // Generate explanation
                        const drivers = FeatureEngine.getGameDrivers(game, probFinal, features, featureNames);
                        
                        predictions.push({
                            gameId: game.id,
                            homeTeam: game.home_team,
                            awayTeam: game.away_team,
                            homeWinProb: probFinal,
                            awayWinProb: 1 - probFinal,
                            confidence: Math.abs(probFinal - 0.5) * 2,
                            edge: edge,
                            drivers: drivers,
                            spreadEquiv: MathUtils.probToSpread(probFinal),
                            kickoff: game.start_date,
                            venue: game.venue
                        });
                    }
                    
                    console.log('Generated predictions:', predictions.length);
                    return predictions;
                    
                } catch (error) {
                    console.error('Prediction error:', error);
                    showToast(`Prediction error: ${error.message}`, 'danger');
                    return [];
                }
            }
        }

        // Date utilities
        const DateUtils = {
            getCurrentSeason(date = new Date()) {
                return getDefaultSeason(date);
            },

            getCurrentWeek(date = new Date()) {
                const season = this.getCurrentSeason(date);
                const seasonStart = new Date(season, 7, 15);
                const millisecondsPerWeek = 7 * 24 * 60 * 60 * 1000;
                const weekNumber = Math.ceil((date - seasonStart) / millisecondsPerWeek);
                return Math.max(1, Math.min(15, weekNumber));
            },
            
            formatGameTime(dateString) {
                const date = new Date(dateString);
                return {
                    time: date.toLocaleTimeString('en-US', { 
                        hour: 'numeric', 
                        minute: '2-digit',
                        timeZoneName: 'short'
                    }),
                    date: date.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    })
                };
            }
        };

        // UI Management
        const UI = {
            showLoading() {
                const container = document.getElementById('gamesContainer');
                const emptyState = document.getElementById('emptyState');
                if (emptyState) {
                    emptyState.style.display = 'none';
                }

                container.innerHTML = Array(3).fill().map(() => '<div class="loading-skeleton"></div>').join('');
            },
            
            renderGames(predictions) {
                const container = document.getElementById('gamesContainer');
                const emptyState = document.getElementById('emptyState');
                
                if (!predictions || predictions.length === 0) {
                    container.innerHTML = '';
                    emptyState.style.display = 'block';
                    return;
                }
                
                emptyState.style.display = 'none';
                
                // Sort predictions
                const sortBy = document.getElementById('sortBy').value;
                const sorted = [...predictions].sort((a, b) => {
                    switch (sortBy) {
                        case 'confidence':
                            return b.confidence - a.confidence;
                        case 'edge':
                            return (b.edge || 0) - (a.edge || 0);
                        case 'time':
                            return new Date(a.kickoff) - new Date(b.kickoff);
                        default:
                            return b.confidence - a.confidence;
                    }
                });
                
                container.innerHTML = sorted.map(prediction => this.renderGameCard(prediction)).join('');
            },
            
            renderGameCard(prediction) {
                const gameTime = DateUtils.formatGameTime(prediction.kickoff);
                const confidence = (prediction.confidence * 100).toFixed(0);
                const homeProb = (prediction.homeWinProb * 100).toFixed(0);
                const awayProb = (prediction.awayWinProb * 100).toFixed(0);
                
                // Calculate confidence ring
                const circumference = 2 * Math.PI * 16;
                const strokeDasharray = circumference;
                const strokeDashoffset = circumference * (1 - prediction.confidence);
                
                const edgeBadge = prediction.edge && prediction.edge > 0.1 ? 
                    `<div class="edge-badge">${(prediction.edge * 100).toFixed(0)}% edge</div>` : '';
                
                const drivers = prediction.drivers.map(driver => 
                    `<div class="driver-chip ${driver.impact}">${driver.name}: ${driver.description}</div>`
                ).join('');
                
                const favoredTeam = prediction.homeWinProb > 0.5 ? prediction.homeTeam : prediction.awayTeam;
                
                return `
                    <div class="game-card">
                        <div class="game-header">
                            <div class="game-time">
                                <div>${gameTime.date}</div>
                                <div>${gameTime.time}</div>
                            </div>
                        </div>
                        
                        <div class="venue">${prediction.venue || 'TBD'}</div>
                        
                        <div class="matchup">
                            <div class="team">
                                <div class="team-name">${prediction.awayTeam}</div>
                                <div class="team-record">${awayProb}%</div>
                            </div>
                            <div class="vs">@</div>
                            <div class="team">
                                <div class="team-name">${prediction.homeTeam}</div>
                                <div class="team-record">${homeProb}%</div>
                            </div>
                        </div>
                        
                        <div class="prediction">
                            <div class="prob-container">
                                <div class="confidence-ring">
                                    <svg width="40" height="40">
                                        <circle class="confidence-bg" cx="20" cy="20" r="16"></circle>
                                        <circle class="confidence-fill" cx="20" cy="20" r="16"
                                                stroke-dasharray="${strokeDasharray}"
                                                stroke-dashoffset="${strokeDashoffset}"></circle>
                                    </svg>
                                </div>
                                <div>
                                    <div class="prob-text">${favoredTeam}</div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">${confidence}% confidence</div>
                                </div>
                            </div>
                            ${edgeBadge}
                        </div>
                        
                        ${drivers ? `<div class="drivers">${drivers}</div>` : ''}
                    </div>
                `;
            },

            getWeekLabel(entry) {
                const rawWeek = entry.week ?? AppState.currentWeek;
                const weekNumber = rawWeek !== undefined && rawWeek !== null ? rawWeek : '';
                const seasonType = String(entry.season_type || entry.seasonType || 'regular').toLowerCase();
                const normalizedType = seasonType.replace(/[\s_-]/g, '');

                if (normalizedType === 'regular' || normalizedType === 'regularseason') {
                    return weekNumber !== '' ? `Week ${weekNumber}` : 'Week';
                }

                if (seasonType.includes('champ')) {
                    return 'Conference Championships';
                }

                if (seasonType.includes('bowl')) {
                    return weekNumber !== '' ? `Bowl Week ${weekNumber}` : 'Bowl Week';
                }

                if (normalizedType === 'postseason') {
                    return weekNumber !== '' ? `Postseason Week ${weekNumber}` : 'Postseason Week';
                }

                return weekNumber !== '' ? `Week ${weekNumber}` : 'Week';
            },

            updateWeekDisplay() {
                const display = document.getElementById('weekDisplay');
                if (!display) return;

                const calendar = AppState.cache.calendar;
                const currentIndex = AppState.currentCalendarIndex;

                if (calendar && calendar.length > 0 && currentIndex !== null && calendar[currentIndex]) {
                    const entry = calendar[currentIndex];
                    const isActiveSelection = AppState.activeCalendarIndex !== null && currentIndex === AppState.activeCalendarIndex;

                    if (isActiveSelection) {
                        display.textContent = 'This Weekend';
                        return;
                    }

                    const label = this.getWeekLabel(entry);
                    const seasonLabel = entry.season ?? AppState.currentSeason;
                    const parts = [label];
                    if (seasonLabel !== undefined && seasonLabel !== null && seasonLabel !== '') {
                        parts.push(seasonLabel);
                    }
                    display.textContent = parts.join(' ‚Ä¢ ');
                    return;
                }

                const isCurrentSeason = AppState.currentSeason === DateUtils.getCurrentSeason();
                const isCurrentWeek = AppState.currentWeek === DateUtils.getCurrentWeek();

                if (isCurrentSeason && isCurrentWeek) {
                    display.textContent = 'This Weekend';
                } else {
                    display.textContent = `Week ${AppState.currentWeek} ‚Ä¢ ${AppState.currentSeason}`;
                }
            },
            
            populateFilters(games) {
                const conferenceFilter = document.getElementById('conferenceFilter');
                const teamFilter = document.getElementById('teamFilter');
                
                const conferences = [...new Set(games.flatMap(g => [g.away_conference, g.home_conference]).filter(Boolean))];
                const teams = [...new Set(games.flatMap(g => [g.away_team, g.home_team]))];
                
                conferenceFilter.innerHTML = '<option value="">All Conferences</option>' +
                    conferences.map(conf => `<option value="${conf}">${conf}</option>`).join('');
                
                teamFilter.innerHTML = '<option value="">All Teams</option>' +
                    teams.map(team => `<option value="${team}">${team}</option>`).join('');
            }
        };

        // Toast notifications
        function showToast(message, type = 'danger') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, type === 'success' ? 2000 : 4000);
        }

        // Settings management
        function loadSettings() {
            const settings = AppState.settings;
            document.getElementById('cfbdKey').value = settings.cfbdKey;
            document.getElementById('useMarkets').checked = settings.useMarkets;
            document.getElementById('useWeather').checked = settings.useWeather;
            document.getElementById('manualInjuries').checked = settings.manualInjuries;
            document.getElementById('demoMode').checked = settings.demoMode;
        }

        function saveSettings() {
            const settings = AppState.settings;
            settings.cfbdKey = document.getElementById('cfbdKey').value.trim();
            settings.useMarkets = document.getElementById('useMarkets').checked;
            settings.useWeather = document.getElementById('useWeather').checked;
            settings.manualInjuries = document.getElementById('manualInjuries').checked;
            settings.demoMode = document.getElementById('demoMode').checked;

            if (settings.cfbdKey) {
                localStorage.setItem('cfbd_key', settings.cfbdKey);
            }

            console.log('Settings saved (key length):', settings.cfbdKey ? settings.cfbdKey.length : 0);
            document.getElementById('settingsModal').classList.remove('show');
            showToast('Settings saved', 'success');
        }

        function forgetKeys() {
            localStorage.removeItem('cfbd_key');
            AppState.settings.cfbdKey = '';
            document.getElementById('cfbdKey').value = '';
            showToast('API keys forgotten', 'success');
        }

        // Main application controller
        class App {
            constructor() {
                this.predictionEngine = new PredictionEngine();
                this.init();
            }

            init() {
                AppState.currentSeason = DateUtils.getCurrentSeason();
                AppState.currentWeek = DateUtils.getCurrentWeek();
                UI.updateWeekDisplay();
                this.bindEvents();
                loadSettings();
                
                if (AppState.settings.cfbdKey || AppState.settings.demoMode) {
                    this.refreshData();
                }
            }
            
            bindEvents() {
                document.getElementById('prevWeek').addEventListener('click', () => {
                    if (!AppState.cache.calendar || !AppState.cache.calendar.length) {
                        this.refreshData();
                        return;
                    }

                    const newIndex = AppState.currentCalendarIndex === null ? 0 : Math.max(0, AppState.currentCalendarIndex - 1);
                    this.setCalendarIndex(newIndex);
                    this.refreshData({ maintainSelection: true });
                });

                document.getElementById('nextWeek').addEventListener('click', () => {
                    if (!AppState.cache.calendar || !AppState.cache.calendar.length) {
                        this.refreshData();
                        return;
                    }

                    const calendarLength = AppState.cache.calendar.length;
                    const newIndex = AppState.currentCalendarIndex === null ? 0 : Math.min(calendarLength - 1, AppState.currentCalendarIndex + 1);
                    this.setCalendarIndex(newIndex);
                    this.refreshData({ maintainSelection: true });
                });
                
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.add('show');
                });
                
                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('show');
                });

                document.getElementById('testApi').addEventListener('click', () => this.testApiConnection());

                document.getElementById('closeSettings2').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('show');
                });

                document.getElementById('saveSettings').addEventListener('click', saveSettings);
                document.getElementById('forgetKeys').addEventListener('click', forgetKeys);

                document.getElementById('loadGames').addEventListener('click', () => this.refreshData({ maintainSelection: true }));
                document.getElementById('predict').addEventListener('click', () => this.predict());
                document.getElementById('exportData').addEventListener('click', () => this.exportData());
                document.getElementById('resetApp').addEventListener('click', () => this.reset());
                
                document.getElementById('sortBy').addEventListener('change', () => {
                    if (AppState.predictions) {
                        UI.renderGames(AppState.predictions);
                    }
                });
                
                document.getElementById('settingsModal').addEventListener('click', (e) => {
                    if (e.target.id === 'settingsModal') {
                        e.target.classList.remove('show');
                    }
                });
            }

            // Allow users to validate their API key before loading games.
            async testApiConnection() {
                const keyInput = document.getElementById('cfbdKey');
                const button = document.getElementById('testApi');
                if (!keyInput) {
                    return;
                }

                const apiKey = keyInput.value.trim();
                if (!apiKey) {
                    showToast('Enter your CFBD API key before testing', 'danger');
                    return;
                }

                const previousKey = AppState.settings.cfbdKey;
                const previousDemo = AppState.settings.demoMode;

                showToast('Testing API connection...', 'warning');
                console.log('Testing CFBD API key (length only):', apiKey.length);

                if (button) {
                    button.disabled = true;
                    button.textContent = 'Testing...';
                }

                AppState.settings.cfbdKey = apiKey;
                AppState.settings.demoMode = false;

                try {
                    const result = await this.predictionEngine.cfbdClient.testConnection();
                    const teamCount = result.count ?? 0;
                    showToast(`API connection good - Found ${teamCount} teams`, 'success');
                    console.log('CFBD API test result:', result);
                } catch (error) {
                    console.error('CFBD API test failed:', error);
                    const toastType = error.message.includes('Rate limit') ? 'warning' : 'danger';
                    showToast(`API test failed: ${error.message}`, toastType);
                } finally {
                    AppState.settings.cfbdKey = previousKey;
                    AppState.settings.demoMode = previousDemo;

                    if (button) {
                        button.disabled = false;
                        button.textContent = 'Test API';
                    }
                }
            }

            async ensureCalendarLoaded() {
                if (AppState.cache.calendar && AppState.cache.calendar.length > 0) {
                    return AppState.cache.calendar;
                }

                const calendar = await this.predictionEngine.cfbdClient.getCalendar(AppState.currentSeason);

                if (!Array.isArray(calendar) || calendar.length === 0) {
                    throw new Error('Unable to load season calendar');
                }

                const sorted = [...calendar].sort((a, b) => {
                    const startA = this.getCalendarDate(a, ['first_game_start', 'firstGameStart', 'start_date', 'startDate']);
                    const startB = this.getCalendarDate(b, ['first_game_start', 'firstGameStart', 'start_date', 'startDate']);
                    const timeA = startA ? startA.getTime() : 0;
                    const timeB = startB ? startB.getTime() : 0;
                    return timeA - timeB;
                });

                AppState.cache.calendar = sorted;
                return sorted;
            }

            getCalendarDate(entry, keys) {
                for (const key of keys) {
                    const value = entry[key];
                    if (!value) continue;
                    const parsed = new Date(value);
                    if (!Number.isNaN(parsed.getTime())) {
                        return parsed;
                    }
                }
                return null;
            }

            determineActiveCalendarIndex() {
                const calendar = AppState.cache.calendar;
                if (!calendar || calendar.length === 0) return null;

                const now = new Date();

                const activeIndex = calendar.findIndex((entry) => {
                    const start = this.getCalendarDate(entry, ['first_game_start', 'firstGameStart', 'start_date', 'startDate']);
                    const end = this.getCalendarDate(entry, ['last_game_start', 'lastGameStart', 'end_date', 'endDate']);
                    const effectiveEnd = end || (start ? new Date(start.getTime() + 6 * 24 * 60 * 60 * 1000) : null);

                    if (start && effectiveEnd) {
                        return start <= now && now <= effectiveEnd;
                    }

                    return false;
                });

                if (activeIndex !== -1) {
                    return activeIndex;
                }

                const upcomingIndex = calendar.findIndex((entry) => {
                    const start = this.getCalendarDate(entry, ['first_game_start', 'firstGameStart', 'start_date', 'startDate']);
                    return start && start > now;
                });

                if (upcomingIndex !== -1) {
                    return upcomingIndex;
                }

                return calendar.length - 1;
            }

            setCalendarIndex(index) {
                const calendar = AppState.cache.calendar;
                if (!calendar || calendar.length === 0) {
                    return null;
                }

                const normalizedIndex = Math.max(0, Math.min(index, calendar.length - 1));
                AppState.currentCalendarIndex = normalizedIndex;

                const entry = calendar[normalizedIndex];
                if (entry) {
                    const seasonValue = entry.season ?? AppState.currentSeason;
                    const parsedSeason = Number(seasonValue);
                    AppState.currentSeason = Number.isFinite(parsedSeason) ? parsedSeason : seasonValue;

                    const weekValue = entry.week ?? AppState.currentWeek;
                    const parsedWeek = Number(weekValue);
                    AppState.currentWeek = Number.isFinite(parsedWeek) ? parsedWeek : AppState.currentWeek;

                    AppState.currentSeasonType = String(entry.season_type || entry.seasonType || 'regular').toLowerCase();
                }

                UI.updateWeekDisplay();
                return entry;
            }

            syncCalendarSelection({ maintainSelection = false } = {}) {
                const calendar = AppState.cache.calendar;
                if (!calendar || calendar.length === 0) {
                    AppState.activeCalendarIndex = null;
                    AppState.currentCalendarIndex = null;
                    AppState.currentSeasonType = 'regular';
                    return;
                }

                const activeIndex = this.determineActiveCalendarIndex();
                AppState.activeCalendarIndex = activeIndex;

                if (maintainSelection && AppState.currentCalendarIndex !== null) {
                    const preservedIndex = Math.max(0, Math.min(AppState.currentCalendarIndex, calendar.length - 1));
                    this.setCalendarIndex(preservedIndex);
                    return;
                }

                if (activeIndex !== null) {
                    this.setCalendarIndex(activeIndex);
                    return;
                }

                this.setCalendarIndex(0);
            }

            async findNextWeekWithGames(startIndex) {
                const calendar = AppState.cache.calendar;
                if (!calendar || calendar.length === 0) {
                    return null;
                }

                const baselineSeason = AppState.currentSeason;
                const baselineWeek = AppState.currentWeek;
                const baselineSeasonType = AppState.currentSeasonType || 'regular';

                const maxLookahead = 6;
                let attempts = 0;

                for (let index = Math.max(startIndex + 1, 0); index < calendar.length; index++) {
                    if (attempts >= maxLookahead) break;
                    attempts += 1;

                    const entry = calendar[index];
                    if (!entry) continue;

                    const seasonValue = entry.season ?? baselineSeason;
                    const parsedSeason = Number(seasonValue);
                    const season = Number.isFinite(parsedSeason) ? parsedSeason : seasonValue;

                    const weekValue = entry.week ?? baselineWeek;
                    const parsedWeek = Number(weekValue);
                    const week = Number.isFinite(parsedWeek) ? parsedWeek : baselineWeek;

                    const rawSeasonType = entry.season_type || entry.seasonType || baselineSeasonType;
                    const normalizedSeasonType = this.predictionEngine.cfbdClient.normalizeSeasonType(rawSeasonType);

                    try {
                        const games = await this.predictionEngine.cfbdClient.getGames(season, week, normalizedSeasonType);
                        if (Array.isArray(games) && games.length > 0) {
                            return {
                                index,
                                games,
                                season,
                                week,
                                seasonType: rawSeasonType
                            };
                        }
                    } catch (error) {
                        console.warn('Error while probing calendar entry for games', entry, error);
                    }
                }

                return null;
            }

            async refreshData(options = {}) {
                const { maintainSelection = false } = options;

                if (!AppState.settings.cfbdKey && !AppState.settings.demoMode) {
                    showToast('CFBD API key required. Check settings.', 'warning');
                    document.getElementById('settingsModal').classList.add('show');
                    return;
                }

                // Surface progress to the user so they know the request is underway.
                showToast('Loading games from CollegeFootballData...', 'warning');
                UI.showLoading();

                try {
                    await this.ensureCalendarLoaded();
                    this.syncCalendarSelection({ maintainSelection });

                    const seasonType = this.predictionEngine.cfbdClient.normalizeSeasonType(AppState.currentSeasonType);
                    console.log('Requesting games with params:', {
                        season: AppState.currentSeason,
                        week: AppState.currentWeek,
                        seasonType
                    });

                    const games = await this.predictionEngine.cfbdClient.getGames(
                        AppState.currentSeason,
                        AppState.currentWeek,
                        seasonType
                    );

                    console.log('Games loaded:', games);

                    let resolvedGames = games;

                    if (!resolvedGames || resolvedGames.length === 0) {
                        console.warn('Empty games response received', {
                            season: AppState.currentSeason,
                            week: AppState.currentWeek,
                            seasonType
                        });
                        if (!maintainSelection) {
                            const fallback = await this.findNextWeekWithGames(AppState.currentCalendarIndex ?? -1);

                            if (fallback && fallback.games && fallback.games.length > 0) {
                                console.info('Auto-selected next available week with games', fallback);
                                this.setCalendarIndex(fallback.index);
                                AppState.activeCalendarIndex = fallback.index;
                                UI.updateWeekDisplay();
                                resolvedGames = fallback.games;
                                showToast('No games for selected week. Showing next available slate.', 'warning');
                            } else {
                                AppState.cache.games = [];
                                AppState.predictions = null;
                                showToast('No games found for this week', 'warning');
                                UI.renderGames([]);
                                return;
                            }
                        } else {
                            AppState.cache.games = [];
                            AppState.predictions = null;
                            showToast('No games found for this week', 'warning');
                            UI.renderGames([]);
                            return;
                        }
                    }

                    AppState.cache.games = resolvedGames;
                    AppState.cache.lastUpdate = new Date();

                    UI.populateFilters(resolvedGames);
                    showToast(`Loaded ${resolvedGames.length} games`, 'success');

                    this.predict();

                } catch (error) {
                    console.error('Error loading data:', error);
                    showToast(`Error loading data: ${error.message}`, 'danger');
                    AppState.cache.games = [];
                    AppState.predictions = null;
                    UI.renderGames([]);
                }
            }
            
            async predict() {
                if (!AppState.cache.games) {
                    showToast('Load data first', 'warning');
                    return;
                }
                
                try {
                    const predictions = await this.predictionEngine.predict(AppState.cache.games);
                    AppState.predictions = predictions;
                    UI.renderGames(predictions);
                    
                    if (predictions.length > 0) {
                        showToast(`Generated ${predictions.length} predictions`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Prediction error:', error);
                    showToast(`Prediction error: ${error.message}`, 'danger');
                }
            }
            
            exportData() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    week: AppState.currentWeek,
                    season: AppState.currentSeason,
                    seasonType: AppState.currentSeasonType,
                    games: AppState.cache.games,
                    predictions: AppState.predictions
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cfb-predictions-week${AppState.currentWeek}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('Data exported', 'success');
            }
            
            reset() {
                if (confirm('Reset all data? This will clear cache but keep settings.')) {
                    const preservedCalendar = AppState.cache.calendar;
                    AppState.cache = {
                        games: null,
                        metrics: null,
                        weather: null,
                        lines: null,
                        calendar: preservedCalendar,
                        lastUpdate: null
                    };
                    AppState.predictions = null;
                    AppState.currentCalendarIndex = AppState.activeCalendarIndex;

                    if (AppState.currentCalendarIndex !== null && preservedCalendar && preservedCalendar.length > 0) {
                        this.setCalendarIndex(AppState.currentCalendarIndex);
                    } else {
                        AppState.currentSeasonType = 'regular';
                        UI.updateWeekDisplay();
                    }

                    UI.renderGames([]);
                    showToast('App reset', 'success');
                }
            }
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new App();
        });
    </script>
</body>
</html>

<!--
CFBD API Endpoints Used:
- /games?year={year}&week={week}&seasonType=regular&division=fbs
- /ratings/elo?year={year}&week={week}
- /metrics/ppa/teams?year={year}&week={week}
- /lines?year={year}&week={week}&seasonType=regular

Response Structures Expected:
- Games: { id, season, week, home_team, away_team, start_date, venue, neutral_site, etc. }
- ELO: [{ team, elo }]
- PPA: [{ team, overall: { ppa }, passing: { ppa }, rushing: { ppa } }]
- Lines: [{ home_team, away_team, lines: [{ provider, spread, over_under }] }]
-->
