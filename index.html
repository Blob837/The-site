<!DOCTYPE html>
<!--
CHANGELOG:
- Replaced heavy neon theme with clean terminal dark theme using CSS variables
- Reduced CSS from 700+ to ~400 lines, removed redundant animations
- Added skeleton loading states and optimistic UI updates
- Improved keyboard navigation and focus management
- Performance: removed heavy backdrop-filters, simplified animations to transform/opacity
- Added prefers-reduced-motion support
- Maintained exact DOM structure and all existing functionality
- Optimized fetch operations and reduced layout thrash
-->
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>UR NEWS - Terminal Intelligence</title>
<meta name="theme-color" content="#0b0f14" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="Real-time intelligence terminal for breaking news and political analysis">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #061214;
    --panel: rgba(10, 26, 28, 0.88);
    --muted: #7fa8ab;
    --text: #e6fffb;
    --accent: #2dd4bf;
    --accent-soft: #0f766e;
    --ok: #34d399;
    --warn: #fbbf24;
    --err: #f87171;
    --border: rgba(30, 80, 84, 0.6);
    --hover: rgba(20, 52, 54, 0.5);
    --focus: rgba(45, 212, 191, 0.35);
    --skeleton: #0f2628;
    --tone-high: #5eead4;
    --tone-mid: #2dd4bf;
    --tone-neutral: #6c8a8d;
    --tone-low: #f97316;
    --tone-critical: #ef4444;
    --aurora-1: #0f766e;
    --aurora-2: #14b8a6;
    --aurora-3: #2dd4bf;
    --app-height: 100vh;
  }

  @supports (height: 100dvh) {
    :root {
      --app-height: 100dvh;
    }
  }
  
  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }
  
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    background: var(--bg);
    color: var(--text);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 15px;
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    padding: env(safe-area-inset-top) env(safe-area-inset-right) 0 env(safe-area-inset-left);
    overflow-x: hidden;
  }

  body,
  button,
  input,
  select,
  textarea {
    font-family: 'IBM Plex Mono', monospace;
  }

  /* Animations - respect motion preferences */
  @media (prefers-reduced-motion: no-preference) {
    .smooth { transition: all 0.15s cubic-bezier(0.2, 0.8, 0.2, 1); }
    .slide { transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1); }
    .fade { transition: opacity 0.15s ease; }
  }

  /* Skeleton loading */
  .skeleton {
    background: linear-gradient(90deg, var(--skeleton) 25%, var(--hover) 50%, var(--skeleton) 75%);
    background-size: 200% 100%;
    border-radius: 4px;
  }

  @media (prefers-reduced-motion: no-preference) {
    .skeleton {
      animation: shimmer 1.5s infinite;
    }
  }

  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Header */
  header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: linear-gradient(180deg, rgba(15, 118, 110, 0.55), rgba(6, 18, 20, 0.9));
    border-bottom: 1px solid rgba(45, 212, 191, 0.18);
    box-shadow: 0 16px 42px rgba(6, 18, 20, 0.6);
    margin-top: calc(env(safe-area-inset-top, 0px) * -1);
    padding-top: calc(env(safe-area-inset-top, 0px) + 0.5rem);
  }

  .bar {
    display: flex;
    gap: 1rem;
    align-items: center;
    padding: 1rem;
    border-bottom: none;
    background: rgba(7, 20, 22, 0.92);
  }
  
  .title {
    font-weight: 700;
    letter-spacing: 0.5px;
    font-size: 1.1rem;
    flex: 1;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
    row-gap: 0.35rem;
  }
  
  .blip {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--accent);
    flex-shrink: 0;
    box-shadow: 0 0 0 2px rgba(45, 212, 191, 0.28), 0 0 10px rgba(34, 211, 238, 0.55);
  }

  @media (prefers-reduced-motion: no-preference) {
    .blip {
      animation: pulse 2s infinite;
    }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  @keyframes aurora {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  
  .meta {
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--muted);
  }

  .meta.mood {
    margin-left: 0.75rem;
    color: var(--tone-neutral);
    transition: color 0.2s ease;
  }

  .meta.mood.very-positive {
    color: var(--tone-high);
  }

  .meta.mood.positive {
    color: var(--tone-mid);
  }

  .meta.mood.neutral {
    color: var(--tone-neutral);
  }

  .meta.mood.negative {
    color: var(--tone-low);
  }

  .meta.mood.very-negative {
    color: var(--tone-critical);
  }
  
  /* Filter chips */
  .filters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 0;
    margin: 0;
    background: transparent;
    border: 0;
    box-shadow: none;
  }
  
  .chip {
    white-space: nowrap;
    padding: 0.5rem 0.9rem;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(255, 255, 255, 0.02);
    color: var(--muted);
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    flex-shrink: 0;
    transition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  }

  .chip:hover {
    border-color: rgba(45, 212, 191, 0.7);
    color: var(--text);
    background: rgba(45, 212, 191, 0.12);
    box-shadow: 0 12px 24px rgba(15, 118, 110, 0.3);
  }

  .chip:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  .chip.active {
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-soft) 100%);
    color: #021110;
    border-color: transparent;
    box-shadow: 0 16px 30px rgba(15, 118, 110, 0.35);
  }

  .chip[data-view="popular"].active {
    background: linear-gradient(135deg, var(--warn) 0%, var(--accent-soft) 100%);
    color: #0a0604;
  }
  
  /* Main content */
  main {
    padding: 1rem;
    max-width: 1000px;
    margin: 0 auto;
    padding-bottom: 4rem;
  }
  
  /* Cards */
  .card {
    background: linear-gradient(175deg, rgba(8, 26, 28, 0.92), rgba(4, 12, 14, 0.96));
    border: 1px solid rgba(45, 212, 191, 0.16);
    border-radius: 18px;
    overflow: hidden;
    margin-bottom: 1.2rem;
    position: relative;
    transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
    box-shadow: 0 20px 48px rgba(2, 10, 12, 0.7);
  }

  .card-head,
  .card-body {
    position: relative;
    z-index: 1;
  }

  .card-glow {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, rgba(45, 212, 191, 0.18), rgba(15, 118, 110, 0.22), rgba(6, 95, 70, 0.18));
    background-size: 180% 180%;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.45s ease;
    z-index: 0;
  }

  @keyframes card-glow-shift {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }

  .card::before {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 3px;
    background: linear-gradient(90deg, var(--aurora-1), var(--aurora-2), var(--aurora-3));
    background-size: 200% 200%;
    opacity: 0;
    transform: translateY(-100%);
    transition: opacity 0.3s ease, transform 0.3s ease;
    pointer-events: none;
    z-index: 1;
  }

  .card:hover {
    border-color: var(--accent);
    box-shadow: 0 18px 38px rgba(3, 16, 17, 0.55);
  }

  .card.open {
    border-color: rgba(45, 212, 191, 0.45);
    box-shadow: 0 24px 60px rgba(3, 16, 17, 0.65);
  }

  .card.open .card-glow {
    opacity: 1;
    animation: card-glow-shift 12s ease infinite;
  }

  .card.open::before {
    opacity: 1;
    transform: translateY(0);
  }

  @media (prefers-reduced-motion: no-preference) {
    .card.open::before {
      animation: aurora 6s linear infinite;
    }
  }

  .card.popular {
    border-color: rgba(45, 212, 191, 0.35);
    box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.25), 0 20px 45px rgba(15, 118, 110, 0.18);
  }

  .card.open.popular {
    box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.35), 0 24px 52px rgba(15, 118, 110, 0.24);
  }

  .card-head {
    display: grid;
    grid-template-columns: auto 1fr auto auto;
    gap: 1rem;
    align-items: center;
    padding: 1.1rem 1.4rem;
    cursor: pointer;
  }
  
  .card:not(.open) .card-head:hover {
    background: var(--hover);
  }

  .card-head:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: -2px;
  }
  
  .favicon {
    width: 16px;
    height: 16px;
    border-radius: 3px;
    background: var(--skeleton);
    background-size: cover;
    background-position: center;
    border: 1px solid var(--border);
    flex-shrink: 0;
    margin-top: 2px;
  }
  
  .titleline {
    font-size: 0.9rem;
    font-weight: 600;
    line-height: 1.3;
    color: var(--text);
    margin-bottom: 0.4rem;
    word-wrap: break-word;
  }
  
  .card:hover .titleline {
    color: var(--accent-soft);
  }
  
  .tag {
    font-size: 0.75rem;
    color: var(--muted);
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 0.4rem;
    flex-wrap: wrap;
  }
  
  .badge {
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.25rem 0.5rem;
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 999px;
    color: var(--text);
    background: rgba(255, 255, 255, 0.03);
    text-transform: uppercase;
    letter-spacing: 0.3px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .badge.trending {
    border-color: rgba(45, 212, 191, 0.6);
    color: var(--accent);
    background: rgba(45, 212, 191, 0.12);
  }

  .badge.sentiment {
    background: transparent;
    border-color: rgba(255, 255, 255, 0.06);
    color: var(--tone-neutral);
  }

  .badge.sentiment.very-positive {
    border-color: var(--tone-high);
    color: var(--tone-high);
  }

  .badge.sentiment.positive {
    border-color: var(--tone-mid);
    color: var(--tone-mid);
  }

  .badge.sentiment.neutral {
    border-color: var(--tone-neutral);
    color: var(--tone-neutral);
  }

  .badge.sentiment.negative {
    border-color: var(--tone-low);
    color: var(--tone-low);
  }

  .badge.sentiment.very-negative {
    border-color: var(--tone-critical);
    color: var(--tone-critical);
  }

  .breaking-indicator {
    display: inline-block;
    background: var(--err);
    color: var(--bg);
    font-size: 0.6rem;
    font-weight: 700;
    padding: 0.15rem 0.3rem;
    border-radius: 3px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    margin-left: 0.3rem;
    flex-shrink: 0;
  }

  @media (prefers-reduced-motion: no-preference) {
    .breaking-indicator {
      animation: pulse 1.5s infinite;
    }
  }
  
  .time {
    font-size: 0.75rem;
    color: var(--muted);
    font-weight: 500;
    white-space: nowrap;
  }
  
  .expand-btn {
    color: var(--muted);
    font-size: 0.9rem;
    user-select: none;
    flex-shrink: 0;
    width: 20px;
    text-align: center;
  }

  .card:hover .expand-btn {
    color: var(--accent);
  }

  .card.open .expand-btn {
    color: var(--accent);
    transform: rotate(180deg);
  }
  
  .card-body {
    padding: 0 1.5rem 1.4rem;
    font-size: 0.9rem;
    color: var(--muted);
    line-height: 1.55;
    display: none;
    background: rgba(4, 16, 18, 0.78);
    border-top: 1px solid rgba(45, 212, 191, 0.12);
    word-wrap: break-word;
  }

  .card.open .card-body {
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
  }

  .card-body > * + * {
    margin-top: 1rem;
  }

  .card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  .source-header {
    margin: 2rem 0 1rem;
    font-size: 1rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--accent);
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
  }
  
  .article-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.3rem;
    background: linear-gradient(135deg, var(--accent) 0%, var(--accent-soft) 100%);
    color: #020305;
    padding: 0.6rem 1.2rem;
    border-radius: 999px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    font-size: 0.75rem;
    text-decoration: none;
    flex: 0;
    border: none;
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 14px 28px rgba(15, 118, 110, 0.35);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .article-link:hover {
    box-shadow: 0 18px 34px rgba(34, 211, 238, 0.32);
    transform: translateY(-1px);
  }

  .article-link:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 4px;
  }
  
  /* Toast notifications */
  .toast {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(4, 16, 18, 0.95);
    color: var(--text);
    padding: 0.9rem 1.1rem;
    border-radius: 12px;
    z-index: 3000;
    font-weight: 500;
    border: 1px solid rgba(255, 255, 255, 0.08);
    max-width: 85%;
    text-align: center;
    font-size: 0.8rem;
    box-shadow: 0 14px 32px rgba(15, 118, 110, 0.28);
  }

  .toast.success {
    border-color: rgba(78, 244, 194, 0.6);
    color: var(--ok);
  }

  .toast.error {
    border-color: rgba(255, 94, 138, 0.6);
    color: var(--err);
  }

  /* Empty state */
  .empty {
    color: var(--muted);
    text-align: center;
    padding: 3rem 1.5rem;
    background: var(--panel);
    border-radius: 8px;
    border: 1px solid var(--border);
  }
  
  .empty h3 {
    color: var(--accent);
    margin-bottom: 1rem;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Loading states */
  .loading-card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
  }

  .loading-title {
    height: 1.2rem;
    margin-bottom: 0.5rem;
  }

  .loading-meta {
    height: 0.8rem;
    width: 60%;
  }

  /* Mobile optimizations */
  @media (max-width: 768px) {
    .card-actions {
      flex-direction: column;
    }
    
    .article-link {
      width: 100%;
    }

    .bar {
      padding: 0.9rem 1.1rem;
    }

    main {
      padding: 1.6rem 0.5rem calc(3.2rem + var(--tab-bar-height) + var(--tab-bar-dynamic-offset));
    }
  }

  @media (max-width: 480px) {
    .title {
      font-size: 1rem;
    }

    .filters {
      padding: 0 0.4rem 0.6rem;
      gap: 0.35rem;
    }

    .chip {
      padding: 0.4rem 0.65rem;
      font-size: 0.7rem;
    }

  }

  /* Focus management */
  [tabindex="-1"]:focus {
    outline: none;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  :root {
    --glass: rgba(9, 24, 26, 0.78);
    --glass-strong: rgba(6, 18, 20, 0.88);
    --glow-fresh: rgba(45, 212, 191, 0.42);
    --gold: #fbbf24;
    --breaking: #f97316;
    --tab-bg: rgba(7, 20, 22, 0.88);
    --tab-stroke: rgba(45, 212, 191, 0.2);
    --tab-shadow: 0 24px 60px rgba(3, 12, 14, 0.55);
    --tab-bar-height: 84px;
    --sheet-bg: rgba(6, 18, 20, 0.92);
    --sheet-backdrop: rgba(3, 10, 12, 0.65);
    --sheet-border: rgba(45, 212, 191, 0.18);
    --ios-ease: cubic-bezier(0.22, 0.61, 0.36, 1);
    --tab-bar-base-gap: 0;
    --tab-bar-dynamic-offset: 0px;
    --tab-bar-translate: 0px;
  }

  body {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 15px;
    line-height: 1.6;
    letter-spacing: 0.01em;
    display: flex;
    flex-direction: column;
    min-height: var(--app-height, 100%);
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    background: var(--bg);
    position: relative;
    isolation: isolate;
  }

  body::before,
  body::after {
    content: '';
    position: fixed;
    inset: -30%;
    z-index: -1;
    pointer-events: none;
    background-size: 160% 160%;
    filter: blur(0px);
    opacity: 0.55;
  }

  body::before {
    background:
      radial-gradient(60% 60% at 15% 20%, rgba(45, 212, 191, 0.28), transparent 65%),
      radial-gradient(60% 60% at 85% 25%, rgba(15, 118, 110, 0.35), transparent 68%),
      linear-gradient(140deg, rgba(8, 26, 28, 0.9), rgba(6, 18, 20, 0.95));
    mix-blend-mode: screen;
  }

  body::after {
    background:
      radial-gradient(55% 55% at 28% 78%, rgba(34, 211, 238, 0.24), transparent 70%),
      radial-gradient(65% 65% at 74% 82%, rgba(14, 165, 233, 0.18), transparent 72%);
    mix-blend-mode: screen;
    opacity: 0.32;
  }

  @media (prefers-reduced-motion: no-preference) {
    body::before,
    body::after {
      animation: gradient-drift 26s ease-in-out infinite alternate;
    }
  }

  @keyframes gradient-drift {
    0% {
      transform: translate3d(-2%, -1%, 0) scale(1);
    }
    50% {
      transform: translate3d(2%, 1.5%, 0) scale(1.05);
    }
    100% {
      transform: translate3d(-1%, 3%, 0) scale(1.02);
    }
  }

  header {
    backdrop-filter: blur(22px);
    -webkit-backdrop-filter: blur(22px);
    border-bottom: 1px solid rgba(45, 212, 191, 0.18);
    background: linear-gradient(180deg, rgba(20, 83, 92, 0.55), rgba(6, 20, 22, 0.92));
    box-shadow: 0 24px 60px rgba(2, 12, 14, 0.55);
    isolation: isolate;
  }

  header::before {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    top: calc(env(safe-area-inset-top, 0px) * -1);
    bottom: 0;
    background: inherit;
    z-index: -1;
  }

  main {
    width: min(1200px, 100% - 1rem);
    margin: 0 auto;
    padding: 2.2rem 0.5rem calc(3.8rem + var(--tab-bar-height) + var(--tab-bar-dynamic-offset));
    display: flex;
    flex-direction: column;
    gap: 1.75rem;
    flex: 1;
    min-height: 0;
    transform: translateY(calc(var(--pull-distance, 0px) * 0.48));
    transition: transform 0.45s var(--ios-ease), padding-bottom 0.45s var(--ios-ease);
  }

  .bar {
    padding: 1.1rem 1.6rem;
    gap: 1.15rem;
    background: rgba(6, 22, 24, 0.72);
    border-radius: 18px;
    border: 1px solid rgba(45, 212, 191, 0.16);
    box-shadow: 0 22px 48px rgba(2, 12, 14, 0.45);
    backdrop-filter: blur(12px);
  }

  .title {
    font-weight: 600;
    letter-spacing: 0.14em;
    font-size: 1.08rem;
    text-transform: uppercase;
    color: var(--text);
  }

  .meta {
    letter-spacing: 0.16em;
    font-size: 0.72rem;
    color: rgba(230, 255, 251, 0.6);
  }

  .filters {
    position: static;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    gap: 0.55rem;
    padding: 0 0.25rem 0.75rem;
    margin: 0;
    overflow: visible;
  }

  .chip {
    position: relative;
    flex: 0 0 auto;
    padding: 0.5rem 0.95rem;
    border-radius: 999px;
    border: none;
    background: rgba(6, 24, 26, 0.58);
    color: rgba(230, 255, 251, 0.64);
    font-size: 0.74rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    transition: color 0.3s var(--ios-ease), transform 0.35s var(--ios-ease), background 0.3s var(--ios-ease);
    backdrop-filter: blur(4px);
  }

  .chip::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: linear-gradient(135deg, rgba(45, 212, 191, 0.28), rgba(15, 118, 110, 0.26));
    opacity: 0;
    transform: scale(0.94);
    transition: opacity 0.35s var(--ios-ease), transform 0.35s var(--ios-ease);
  }

  .chip:hover {
    color: var(--text);
  }

  .chip.active {
    color: var(--text);
    transform: translateY(-2px);
  }

  .chip.active::after {
    opacity: 1;
    transform: scale(1);
    background: linear-gradient(135deg, rgba(45, 212, 191, 0.6), rgba(14, 165, 233, 0.38));
    box-shadow: 0 16px 32px rgba(10, 54, 59, 0.45);
  }

  .chip[data-view='breaking'].active {
    color: var(--breaking);
  }

  .chip[data-view='popular'].active {
    color: var(--gold);
  }

  .list {
    display: flex;
    flex-direction: column;
    gap: 1.6rem;
    padding: 0;
    position: relative;
  }

  .card {
    position: relative;
    border-radius: 18px;
    border: 1px solid rgba(45, 212, 191, 0.18);
    background: linear-gradient(155deg, rgba(8, 26, 28, 0.9), rgba(4, 12, 14, 0.94));
    box-shadow: 0 28px 60px rgba(2, 12, 14, 0.55);
    overflow: hidden;
    margin: 0;
    transform-origin: center top;
    transform: translateY(var(--stack-offset, 0px)) scale(var(--stack-scale, 1));
    transition: transform 0.6s var(--ios-ease), box-shadow 0.45s var(--ios-ease), border-color 0.4s ease, background 0.4s ease;
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    animation: cardStackIn 0.7s var(--ios-ease) both;
    animation-delay: var(--card-delay, 0s);
  }

  .card::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.45s ease;
    box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.12), 0 0 0 6px rgba(45, 212, 191, 0.05);
  }

  .card.fresh::after {
    opacity: 1;
  }

  .card.open {
    background: linear-gradient(160deg, rgba(8, 30, 32, 0.96), rgba(4, 12, 14, 0.98));
    border-color: rgba(45, 212, 191, 0.5);
    box-shadow: 0 36px 80px rgba(2, 12, 14, 0.65);
    transform: translateY(0) scale(1.02);
    z-index: 200;
  }

  .card.open::before {
    opacity: 1;
    transform: translateY(0);
  }

  .card:hover {
    transform: translateY(calc(var(--stack-offset, 0px) - 6px)) scale(calc(var(--stack-scale, 1) + 0.012));
    box-shadow: 0 32px 70px rgba(2, 12, 14, 0.6);
    border-color: rgba(45, 212, 191, 0.35);
  }

  .card--lead {
    --stack-offset: 0px;
    --stack-scale: 1;
  }

  .card--lead .titleline {
    font-size: 1.15rem;
  }

  .card--feature .titleline {
    font-size: 1rem;
  }

  .card--breaking .titleline {
    color: var(--breaking);
  }

  .card--trending .titleline {
    color: var(--gold);
  }

  .card-head {
    display: grid;
    grid-template-columns: auto 1fr auto auto;
    gap: 1rem;
    align-items: center;
    padding: 1.1rem 1.6rem 1rem;
  }

  .favicon {
    width: 22px;
    height: 22px;
    border-radius: 6px;
    box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.22);
  }

  .titleline {
    font-weight: 600;
    letter-spacing: 0.01em;
    line-height: 1.35;
    margin-bottom: 0.45rem;
    text-transform: none;
    color: rgba(242, 244, 255, 0.94);
    transition: color 0.3s ease;
  }

  .time {
    font-size: 0.7rem;
    letter-spacing: 0.16em;
  }

  .time--fresh {
    color: var(--accent);
  }

  .tag {
    gap: 0.55rem;
    color: rgba(230, 255, 251, 0.6);
  }

  .badge {
    border-color: rgba(45, 212, 191, 0.2);
    background: rgba(6, 20, 22, 0.68);
    letter-spacing: 0.16em;
    color: rgba(230, 255, 251, 0.78);
  }

  .badge.trending {
    background: rgba(255, 224, 154, 0.16);
    border-color: rgba(255, 224, 154, 0.45);
    color: var(--gold);
  }

  .badge.sentiment {
    font-weight: 600;
    letter-spacing: 0.14em;
  }

  .badge.credibility {
    border-color: rgba(45, 212, 191, 0.35);
    background: rgba(45, 212, 191, 0.18);
    color: var(--accent);
  }

  .badge.credibility.watch {
    border-color: rgba(255, 193, 164, 0.4);
    background: rgba(255, 193, 164, 0.14);
    color: var(--warn);
  }

  .badge.credibility.trust {
    border-color: rgba(143, 247, 212, 0.42);
    background: rgba(143, 247, 212, 0.18);
    color: var(--ok);
  }

  .badge.badge-fresh {
    border-color: rgba(45, 212, 191, 0.55);
    background: rgba(45, 212, 191, 0.2);
    color: var(--accent);
  }

  .card-body {
    padding: 0 1.5rem 1.4rem;
  }

  .card-summary {
    font-size: 0.9rem;
    letter-spacing: 0.01em;
    color: rgba(230, 255, 251, 0.82);
    line-height: 1.55;
  }

  .card-actions {
    justify-content: space-between;
    align-items: center;
    gap: 0.75rem;
  }

  .article-link {
    padding: 0.65rem 1.45rem;
    letter-spacing: 0.14em;
  }

  .reading-progress {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    border: 1px solid rgba(45, 212, 191, 0.24);
    display: grid;
    place-items: center;
    position: relative;
    background: rgba(6, 20, 22, 0.65);
    transition: transform 0.35s var(--ios-ease), border-color 0.35s var(--ios-ease);
  }

  .reading-progress__meter {
    --progress: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: conic-gradient(var(--accent) calc(var(--progress) * 360deg), rgba(255, 255, 255, 0.1) 0deg);
    -webkit-mask: radial-gradient(circle at center, transparent 58%, black 62%);
    mask: radial-gradient(circle at center, transparent 58%, black 62%);
    transition: background 0.35s ease;
  }

  .reading-progress::after {
    content: '';
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--accent);
    opacity: 0.8;
  }

  .card.open .reading-progress {
    border-color: rgba(45, 212, 191, 0.45);
    transform: scale(1.05);
  }

  .pull-indicator {
    position: fixed;
    top: calc(env(safe-area-inset-top) + 1rem);
    left: 50%;
    transform: translate(-50%, -120%);
    padding: 0.45rem 1.1rem;
    border-radius: 999px;
    background: rgba(6, 20, 22, 0.85);
    color: var(--text);
    font-size: 0.7rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    border: 1px solid rgba(45, 212, 191, 0.22);
    box-shadow: 0 18px 38px rgba(2, 12, 14, 0.4);
    opacity: 0;
    transition: opacity 0.35s var(--ios-ease);
    pointer-events: none;
    z-index: 90;
  }

  .pull-indicator[data-state='ready'],
  .pull-indicator[data-state='loading'] {
    opacity: 1;
  }

  .tab-bar {
    position: fixed;
    left: 50%;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 0.75rem);
    transform: translateX(-50%);
    display: grid;
    grid-template-columns: repeat(5, minmax(0, 1fr));
    gap: 0.4rem;
    background: rgba(4, 20, 22, 0.92);
    border-radius: 26px;
    padding: 0.35rem 0.6rem calc(0.45rem + env(safe-area-inset-bottom, 0px));
    border: 1px solid rgba(45, 212, 191, 0.2);
    box-shadow: 0 24px 60px rgba(2, 10, 12, 0.65);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    width: min(480px, calc(100% - 1.5rem));
    transition: box-shadow 0.45s var(--ios-ease), transform 0.45s var(--ios-ease);
    will-change: transform;
    z-index: 120;
  }

  .tab-bar__btn {
    border: none;
    border-radius: 22px;
    background: transparent;
    color: rgba(230, 255, 251, 0.64);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.2rem;
    padding: 0.55rem 0.4rem;
    font-size: 0.65rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    font-weight: 600;
    transition: background 0.35s var(--ios-ease), color 0.35s var(--ios-ease), transform 0.35s var(--ios-ease);
  }

  .tab-bar__btn.active {
    background: linear-gradient(135deg, rgba(45, 212, 191, 0.28), rgba(15, 118, 110, 0.28));
    color: var(--text);
    transform: translateY(-1px);
  }

  .tab-bar__icon {
    font-size: 1.1rem;
    line-height: 1;
  }

  .action-sheet {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: flex-end center;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s ease;
    z-index: 300;
  }

  .action-sheet.is-visible {
    pointer-events: auto;
    opacity: 1;
  }

  .action-sheet__overlay {
    position: absolute;
    inset: 0;
    background: var(--sheet-backdrop);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
  }

  .action-sheet__panel {
    position: relative;
    width: min(520px, 100%);
    margin: 0 auto calc(env(safe-area-inset-bottom) + 1.2rem);
    background: var(--sheet-bg);
    border-radius: 28px 28px 22px 22px;
    border: 1px solid var(--sheet-border);
    box-shadow: 0 40px 80px rgba(6, 10, 18, 0.72);
    transform: translateY(40px);
    transition: transform 0.45s var(--ios-ease);
    overflow: hidden;
  }

  .action-sheet.is-visible .action-sheet__panel {
    transform: translateY(0);
  }

  .action-sheet__handle {
    width: 60px;
    height: 6px;
    background: rgba(255, 255, 255, 0.18);
    border-radius: 999px;
    margin: 0.75rem auto 0.5rem;
  }

  .action-sheet__group {
    display: flex;
    flex-direction: column;
    padding: 0.5rem 1rem 1rem;
    gap: 0.65rem;
  }

  .action-sheet__button {
    border: none;
    border-radius: 18px;
    padding: 0.9rem 1rem;
    background: rgba(12, 15, 32, 0.55);
    color: var(--text);
    font-size: 0.9rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    transition: background 0.3s ease, transform 0.3s ease;
  }

  .action-sheet__button:hover {
    background: rgba(45, 212, 191, 0.22);
    transform: translateY(-1px);
  }

  .action-sheet__button.danger {
    background: rgba(255, 154, 169, 0.18);
    color: var(--err);
  }

  .sheet {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: flex-end center;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.35s ease;
    z-index: 260;
  }

  .sheet.is-visible {
    pointer-events: auto;
    opacity: 1;
  }

  .sheet__overlay {
    position: absolute;
    inset: 0;
    background: var(--sheet-backdrop);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
  }

  .sheet__panel {
    position: relative;
    width: min(520px, 100%);
    margin: 0 auto;
    background: var(--sheet-bg);
    border: 1px solid var(--sheet-border);
    border-radius: 28px 28px 0 0;
    box-shadow: 0 40px 80px rgba(6, 10, 18, 0.72);
    transform: translateY(48px);
    transition: transform 0.4s var(--ios-ease);
    overflow: hidden;
  }

  .sheet.is-visible .sheet__panel {
    transform: translateY(0);
  }

  .filter-sheet__panel {
    display: flex;
    flex-direction: column;
    gap: 0;
    padding-bottom: calc(env(safe-area-inset-bottom) + 0.75rem);
  }

  .filter-sheet__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
    padding: 1.2rem 1.5rem 0.75rem;
  }

  .filter-sheet__title {
    font-size: 0.75rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.72);
  }

  .filter-sheet__close {
    background: none;
    border: none;
    color: var(--accent);
    font-size: 0.75rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    font-weight: 600;
    padding: 0.35rem 0.65rem;
    border-radius: 999px;
    cursor: pointer;
  }

  .filter-sheet__section {
    padding: 1rem 1.5rem 1.35rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .filter-sheet__section + .filter-sheet__section {
    border-top: 1px solid rgba(255, 255, 255, 0.06);
  }

  .filter-sheet__section-title {
    font-size: 0.7rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.58);
  }

  .filter-sheet__source-btn {
    width: 100%;
    border-radius: 18px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    background: rgba(255, 255, 255, 0.03);
    padding: 0.9rem 1.1rem;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.35rem;
    color: var(--text);
    font-size: 0.85rem;
    letter-spacing: 0.04em;
    text-transform: none;
    cursor: pointer;
    transition: border-color 0.3s ease, background 0.3s ease;
  }

  .filter-sheet__source-btn:hover,
  .filter-sheet__source-btn:focus-visible {
    border-color: rgba(45, 212, 191, 0.55);
    background: rgba(45, 212, 191, 0.1);
    outline: none;
  }

  .filter-sheet__source-label {
    font-size: 0.68rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.55);
  }

  .filter-sheet__source-value {
    font-size: 0.95rem;
    font-weight: 600;
    letter-spacing: 0.06em;
  }

  .filter-sheet__source-hint {
    font-size: 0.7rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.45);
  }

  .source-sheet__panel {
    display: flex;
    flex-direction: column;
    max-height: min(80vh, 640px);
    padding: 1.2rem 1.5rem calc(env(safe-area-inset-bottom) + 1rem);
    gap: 0.75rem;
  }

  .source-sheet__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
  }

  .source-sheet__title {
    font-size: 0.82rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.75);
  }

  .source-sheet__close,
  .source-sheet__clear {
    background: none;
    border: none;
    color: var(--accent);
    font-size: 0.72rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    font-weight: 600;
    padding: 0.35rem 0.65rem;
    border-radius: 999px;
    cursor: pointer;
  }

  .source-sheet__clear:disabled {
    opacity: 0.4;
    pointer-events: none;
  }

  .source-sheet__list {
    display: grid;
    gap: 0.65rem;
    overflow-y: auto;
    padding: 0.25rem 0.25rem 0.25rem 0;
  }

  .source-option {
    border-radius: 16px;
    border: 1px solid rgba(45, 212, 191, 0.12);
    background: rgba(6, 20, 22, 0.55);
    padding: 0.85rem 1rem;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.35rem;
    color: var(--text);
    font-size: 0.88rem;
    letter-spacing: 0.02em;
    text-transform: none;
    cursor: pointer;
    transition: border-color 0.3s ease, background 0.3s ease, transform 0.3s ease;
  }

  .source-option:hover {
    border-color: rgba(45, 212, 191, 0.4);
    transform: translateY(-1px);
  }

  .source-option[aria-selected='true'] {
    border-color: rgba(45, 212, 191, 0.65);
    background: linear-gradient(135deg, rgba(45, 212, 191, 0.28), rgba(14, 165, 233, 0.2));
  }

  .source-option__name {
    font-weight: 600;
    letter-spacing: 0.06em;
  }

  .source-option__meta {
    font-size: 0.7rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: rgba(255, 255, 255, 0.55);
    display: flex;
    gap: 0.6rem;
  }

  .source-option__bias {
    font-weight: 600;
    letter-spacing: 0.12em;
  }

  .source-option__check {
    margin-left: auto;
    font-size: 0.75rem;
    color: var(--accent);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .source-option[aria-selected='true'] .source-option__check {
    opacity: 1;
  }

  @media (max-width: 520px) {
    .sheet__panel {
      width: calc(100% - 1.25rem);
    }

    .filter-sheet__header,
    .filter-sheet__section,
    .source-sheet__panel {
      padding-left: 1.1rem;
      padding-right: 1.1rem;
    }
  }

  .spring-stagger .card {
    animation-duration: 0.55s;
  }

  @keyframes cardStackIn {
    0% {
      opacity: 0;
      transform: translateY(30px) scale(0.96);
    }
    100% {
      opacity: 1;
      transform: translateY(var(--stack-offset, 0px)) scale(var(--stack-scale, 1));
    }
  }

  @media (max-width: 720px) {
    main {
      width: calc(100% - 1.5rem);
      padding: 2.2rem 0.75rem calc(3.5rem + var(--tab-bar-height) + var(--tab-bar-dynamic-offset));
    }

    .bar {
      padding: 1rem 1.1rem;
    }

    .card-head {
      grid-template-columns: auto 1fr auto;
      gap: 1rem;
      padding: 1.2rem 1.3rem 1.1rem;
    }

    .card-body {
      padding: 0 1.3rem 1.4rem;
    }
  }

  @media (max-width: 520px) {
    .tab-bar {
      width: calc(100% - 1.5rem);
    }

    .chip {
      min-width: 92px;
    }

    .card-head {
      grid-template-columns: auto 1fr;
    }

    .reading-progress,
    .expand-btn {
      display: none;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    main {
      transition: none;
    }

    .card,
    .chip,
    .tab-bar__btn {
      transition: none;
      animation: none;
    }

    .pull-indicator,
    .action-sheet {
      transition: none;
    }
  }


  .tab-bar__label {
    font-size: 0.6rem;
    letter-spacing: 0.16em;
  }

</style>
</head>
<body>
<header>
  <div class="bar">
    <div class="title">
      <span class="blip" aria-label="Live status"></span>UR NEWS
      <span class="meta" id="lastUpdated">• INITIALIZING</span>
      <span class="meta mood neutral" id="overallMood">• MOOD: CALM</span>
    </div>
  </div>
</header>

<main>
  <div class="pull-indicator" id="pullIndicator" role="status" aria-live="polite">Pull to refresh</div>
  <div class="list" id="feedList" role="main" aria-live="polite"></div>
  <div class="empty" id="emptyMsg" style="display:none;">
    <h3>NO STORIES AVAILABLE</h3>
    <p>Adjust filters or check back shortly.</p>
  </div>
</main>

<nav class="tab-bar" id="tabBar" role="tablist" aria-label="Primary navigation">
  <button type="button" class="tab-bar__btn active" data-view-target="all" role="tab" aria-selected="true">
    <span class="tab-bar__icon">◎</span>
    <span class="tab-bar__label">Feed</span>
  </button>
  <button type="button" class="tab-bar__btn" data-view-target="popular" role="tab" aria-selected="false">
    <span class="tab-bar__icon">★</span>
    <span class="tab-bar__label">Trending</span>
  </button>
  <button type="button" class="tab-bar__btn" data-view-target="breaking" role="tab" aria-selected="false">
    <span class="tab-bar__icon">!</span>
    <span class="tab-bar__label">Breaking</span>
  </button>
  <button
    type="button"
    class="tab-bar__btn"
    id="filterTrigger"
    data-filter-trigger
    role="tab"
    aria-selected="false"
    aria-haspopup="dialog"
    aria-expanded="false"
  >
    <span class="tab-bar__icon">⚙︎</span>
    <span class="tab-bar__label">Filters</span>
  </button>
  <button
    type="button"
    class="tab-bar__btn"
    id="moreActionsTrigger"
    data-sheet-trigger="true"
    role="tab"
    aria-selected="false"
    aria-haspopup="dialog"
    aria-expanded="false"
  >
    <span class="tab-bar__icon">⋯</span>
    <span class="tab-bar__label">More</span>
  </button>
</nav>

<div class="sheet filter-sheet" id="filterSheet" role="dialog" aria-modal="true" hidden>
  <div class="sheet__overlay" data-filter-close></div>
  <div class="sheet__panel filter-sheet__panel" role="document">
    <div class="filter-sheet__header">
      <h2 class="filter-sheet__title">Feed Controls</h2>
      <button type="button" class="filter-sheet__close" data-filter-close>Done</button>
    </div>
    <section class="filter-sheet__section">
      <h3 class="filter-sheet__section-title">View</h3>
      <div class="filters" id="filters" role="tablist" aria-label="Content filters">
        <button class="chip active smooth" data-view="all" role="tab" aria-selected="true" tabindex="0">ALL</button>
        <button class="chip smooth" data-view="popular" role="tab" aria-selected="false" tabindex="-1">🔥 TRENDING</button>
        <button class="chip smooth" data-view="by-source" role="tab" aria-selected="false" tabindex="-1">BY SOURCE</button>
        <button class="chip smooth" data-view="conservative" role="tab" aria-selected="false" tabindex="-1">CONSERVATIVE</button>
        <button class="chip smooth" data-view="populist" role="tab" aria-selected="false" tabindex="-1">POPULIST</button>
        <button class="chip smooth" data-view="breaking" role="tab" aria-selected="false" tabindex="-1">BREAKING</button>
      </div>
    </section>
    <section class="filter-sheet__section">
      <h3 class="filter-sheet__section-title">Source</h3>
      <button
        type="button"
        class="filter-sheet__source-btn smooth"
        id="sourceFilterButton"
        aria-haspopup="dialog"
        aria-expanded="false"
      >
        <span class="filter-sheet__source-label">Current Source</span>
        <span class="filter-sheet__source-value" id="sourceFilterValue">All Sources</span>
        <span class="filter-sheet__source-hint">Tap to focus on a single outlet</span>
      </button>
    </section>
  </div>
</div>

<div class="sheet source-sheet" id="sourceSheet" role="dialog" aria-modal="true" hidden>
  <div class="sheet__overlay" data-source-close></div>
  <div class="sheet__panel source-sheet__panel" role="document">
    <div class="source-sheet__header">
      <button type="button" class="source-sheet__close" data-source-close>Cancel</button>
      <span class="source-sheet__title">Select Source</span>
      <button type="button" class="source-sheet__clear" id="clearSourceFilter">Show All</button>
    </div>
    <div class="source-sheet__list" id="sourceToggles" role="listbox" aria-label="News sources"></div>
  </div>
</div>

<div class="action-sheet" id="actionSheet" role="dialog" aria-modal="true" hidden>
  <div class="action-sheet__overlay" data-sheet-close></div>
  <div class="action-sheet__panel" role="document">
    <div class="action-sheet__handle" aria-hidden="true"></div>
    <div class="action-sheet__group">
      <button type="button" class="action-sheet__button" data-sheet-action="refresh">Refresh Feed</button>
      <button type="button" class="action-sheet__button" data-sheet-action="mark-read">Mark All Read</button>
    </div>
    <div class="action-sheet__group">
      <button type="button" class="action-sheet__button danger" data-sheet-action="reset">Reset Workspace</button>
    </div>
    <div class="action-sheet__group">
      <button type="button" class="action-sheet__button" data-sheet-close>Cancel</button>
    </div>
  </div>
</div>

<script>


const SOURCES = [
  { id: 'breitbart', name: 'Breitbart', url: 'https://www.breitbart.com/feed/', lane: 'populist', bias: 7.5 },
  { id: 'federalist', name: 'The Federalist', url: 'https://thefederalist.com/feed/', lane: 'conservative', bias: 6.2 },
  { id: 'dailywire', name: 'Daily Wire', url: 'https://www.dailywire.com/feeds/rss.xml', lane: 'conservative', bias: 6.8 },
  { id: 'gateway', name: 'Gateway Pundit', url: 'https://www.thegatewaypundit.com/feed/', lane: 'populist', bias: 8.4 },
  { id: 'infowars', name: 'InfoWars', url: 'https://www.infowars.com/rss.xml', lane: 'populist', bias: 9 },
  { id: 'revolver', name: 'Revolver News', url: 'https://www.revolver.news/feed/', lane: 'populist', bias: 7.8 },
  { id: 'natfile', name: 'National File', url: 'https://nationalfile.com/feed/', lane: 'populist', bias: 8.2 },
  { id: 'tplvoice', name: "People's Voice", url: 'https://thepeoplesvoice.tv/feed/', lane: 'populist', bias: 8.8 },
  { id: 'libertydaily', name: 'Liberty Daily', url: 'https://thelibertydaily.com/rss.xml', lane: 'populist', bias: 7.6 },
  { id: 'naturalnews', name: 'Natural News', url: 'https://www.naturalnews.com/rss.xml', lane: 'populist', bias: 8.5 },
  { id: 'dailycaller', name: 'Daily Caller', url: 'https://dailycaller.com/feed/', lane: 'conservative', bias: 5.2 },
  { id: 'redstate', name: 'RedState', url: 'https://redstate.com/feed/', lane: 'conservative', bias: 6.4 },
  { id: 'amgreat', name: 'AmGreatness', url: 'https://amgreatness.com/feed/', lane: 'conservative', bias: 6.9 },
  { id: 'pjm', name: 'PJ Media', url: 'https://pjmedia.com/feeds/latest', lane: 'conservative', bias: 5.8 },
  { id: 'nypost', name: 'NY Post', url: 'https://nypost.com/feed/', lane: 'populist', bias: 3.2 },
  { id: 'townhall', name: 'Townhall', url: 'https://townhall.com/rss', lane: 'conservative', bias: 5.6 },
  { id: 'foxnews', name: 'Fox News', url: 'https://feeds.foxnews.com/foxnews/latest', lane: 'conservative', bias: 4.2 },
  { id: 'washexam', name: 'Washington Examiner', url: 'https://www.washingtonexaminer.com/feed', lane: 'conservative', bias: 3.8 },
  { id: 'theblaze', name: 'The Blaze', url: 'https://www.theblaze.com/feeds/latest.rss', lane: 'conservative', bias: 6.5 },
  { id: 'nbcnews', name: 'NBC News', url: 'https://feeds.nbcnews.com/nbcnews/public/news', lane: 'mainstream', bias: -3 },
  { id: 'abcnews', name: 'ABC News', url: 'https://abcnews.go.com/abcnews/topstories', lane: 'mainstream', bias: -2.2 },
  { id: 'cnn', name: 'CNN', url: 'https://rss.cnn.com/rss/cnn_topstories.rss', lane: 'mainstream', bias: -4 }
];

const persistedState = loadPersistedState();

const STATE = {
  items: [],
  view: persistedState.view || 'all',
  loading: false,
  lastFetch: 0,
  cache: new Map(),
  expandedCards: new Set(persistedState.expanded || []),
  trendingKeywords: new Map(),
  sourceFilter: persistedState.sourceFilter || null,
  readProgress: new Map(
    Object.entries(persistedState.progress || {}).map(([key, value]) => [key, Number(value) || 0])
  )
};

const VALID_VIEWS = new Set(['all', 'popular', 'by-source', 'conservative', 'populist', 'breaking']);

if (!VALID_VIEWS.has(STATE.view)) {
  STATE.view = 'all';
}

if (STATE.sourceFilter && !SOURCES.some(source => source.id === STATE.sourceFilter)) {
  STATE.sourceFilter = null;
}

const CACHE_TTL = 120000;
const FETCH_TIMEOUT = 4000;

const HAPTIC_PATTERNS = {
  tap: [8],
  tab: [12],
  expand: [14, 6, 14],
  action: [16, 8, 16],
  refresh: [24, 18, 24],
  success: [18],
  'pull-ready': [30],
  mark: [12, 4, 12]
};

function triggerHaptic(type) {
  if (!('vibrate' in navigator)) {
    return;
  }
  const pattern = HAPTIC_PATTERNS[type];
  if (pattern) {
    navigator.vibrate(pattern);
  }
}

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

function getReadProgress(cardId) {
  return STATE.readProgress.get(cardId) || 0;
}

function setReadProgress(cardId, progress) {
  const clamped = clamp(progress, 0, 100);
  STATE.readProgress.set(cardId, clamped);
  persistState();

  const card = document.querySelector(`[data-card-id="${cardId}"]`);
  if (card) {
    const meter = card.querySelector('.reading-progress__meter');
    const wrapper = card.querySelector('.reading-progress');
    if (meter) {
      meter.style.setProperty('--progress', (clamped / 100).toFixed(2));
    }
    if (wrapper) {
      wrapper.setAttribute('aria-valuenow', String(Math.round(clamped)));
    }
  }

  return clamped;
}

function ensureReadProgress(cardId, minimum) {
  const current = getReadProgress(cardId);
  if (current >= minimum) {
    return current;
  }
  return setReadProgress(cardId, minimum);
}

function isFreshStory(item) {
  const published = new Date(item.pubDate).getTime();
  if (!Number.isFinite(published)) {
    return false;
  }
  return Date.now() - published < 20 * 60 * 1000;
}

function determineImportance(item, index) {
  if (item.isBreaking) {
    return 'lead';
  }
  if (index === 0) {
    return 'lead';
  }
  if (item.trendingScore > 8 || index < 3) {
    return 'feature';
  }
  return 'standard';
}

function getCredibility(item) {
  const bias = Number(item.biasScore) || 0;
  const sentiment = Number(item.sentimentScore) || 0;
  const trending = Number(item.trendingScore) || 0;
  const isBreaking = Boolean(item.isBreaking);
  const confidence = Math.round(
    clamp(82 - Math.abs(bias) * 4 + Math.min(trending, 10) * 0.8 + sentiment * 0.6 - (isBreaking ? 4 : 0), 35, 96)
  );

  let label = 'Balanced';
  let toneClass = '';
  let description = 'Editorial review in progress.';

  if (Math.abs(bias) <= 2.2) {
    label = 'Verified';
    toneClass = 'trust';
    description = 'Cross-sourced reporting with minimal framing detected.';
  } else if (Math.abs(bias) >= 6) {
    label = 'Watch';
    toneClass = 'watch';
    description = 'Heavy narrative framing detected—verify with an additional source.';
  }

  if (isBreaking) {
    description = 'Developing story; facts may evolve as updates arrive.';
  }

  return {
    label,
    toneClass,
    detail: `Confidence ${confidence}%`,
    description
  };
}

let pullIndicatorTimer = null;

function updatePullIndicator(state, text, hideDelay = 1400) {
  const indicator = document.getElementById('pullIndicator');
  if (!indicator) {
    return;
  }

  if (text) {
    indicator.textContent = text;
  }

  indicator.dataset.state = state;

  if (state === 'idle') {
    indicator.style.opacity = 0;
  } else {
    indicator.style.opacity = 1;
  }

  if (pullIndicatorTimer) {
    clearTimeout(pullIndicatorTimer);
    pullIndicatorTimer = null;
  }

  if (state === 'updated') {
    pullIndicatorTimer = setTimeout(() => {
      indicator.dataset.state = 'idle';
      indicator.style.opacity = 0;
      indicator.textContent = 'Pull to refresh';
    }, hideDelay);
  }
}

function syncActiveNav() {
  const currentView = STATE.view;
  const filters = document.getElementById('filters');
  if (filters) {
    filters.querySelectorAll('.chip').forEach(chip => {
      const active = chip.dataset.view === currentView;
      chip.classList.toggle('active', active);
      chip.setAttribute('aria-selected', String(active));
      chip.tabIndex = active ? 0 : -1;
    });
  }

  const tabBar = document.getElementById('tabBar');
  if (tabBar) {
    tabBar.querySelectorAll('.tab-bar__btn').forEach(button => {
      const view = button.dataset.viewTarget;
      const active = Boolean(view && view === currentView);
      if (view) {
        button.classList.toggle('active', active);
        button.setAttribute('aria-selected', String(active));
      }
    });
  }
}

function changeView(view) {
  if (!view || view === STATE.view) {
    syncActiveNav();
    triggerHaptic('tap');
    return;
  }

  const applyView = () => {
    STATE.view = view;
    persistState();
    render();
  };

  if (document.startViewTransition) {
    document.startViewTransition(applyView);
  } else {
    applyView();
  }

  triggerHaptic('tab');
}

const rootElement = document.documentElement;
let viewportMetricsFrame = null;
let lastViewportOffset = null;
let lastViewportHeight = null;
let viewportMetricsListenersBound = false;

function applyViewportMetrics() {
  if (!rootElement) {
    return;
  }

  const viewport = window.visualViewport;
  const layoutHeightCandidate = window.innerHeight;
  const fallbackHeight = rootElement.clientHeight;
  const layoutHeight = Number.isFinite(layoutHeightCandidate) && layoutHeightCandidate > 0
    ? layoutHeightCandidate
    : Number.isFinite(fallbackHeight) && fallbackHeight > 0
      ? fallbackHeight
      : 0;

  let targetHeight = layoutHeight;

  if (viewport) {
    const visualHeight = viewport.height + viewport.offsetTop;
    if (Number.isFinite(visualHeight)) {
      targetHeight = Math.max(targetHeight, visualHeight);
    }
  }

  if (Number.isFinite(targetHeight) && targetHeight > 0) {
    const roundedHeight = Math.round(targetHeight);
    if (lastViewportHeight !== roundedHeight) {
      rootElement.style.setProperty('--app-height', `${roundedHeight}px`);
      lastViewportHeight = roundedHeight;
    }
  }

  let offset = 0;
  if (viewport && Number.isFinite(layoutHeight) && layoutHeight > 0) {
    const visualBottom = viewport.height + viewport.offsetTop;
    if (Number.isFinite(visualBottom)) {
      const diff = layoutHeight - visualBottom;
      if (Number.isFinite(diff)) {
        offset = Math.max(0, diff);
        if (offset < 4) {
          offset = 0;
        }
      }
    }
  }

  const roundedOffset = Math.round(offset);
  if (lastViewportOffset !== roundedOffset) {
    rootElement.style.setProperty('--tab-bar-dynamic-offset', `${roundedOffset}px`);
    rootElement.style.setProperty('--tab-bar-translate', `${-roundedOffset}px`);
    lastViewportOffset = roundedOffset;
  }
}

function scheduleViewportMetricsUpdate() {
  if (viewportMetricsFrame) {
    return;
  }
  viewportMetricsFrame = requestAnimationFrame(() => {
    viewportMetricsFrame = null;
    applyViewportMetrics();
  });
}

function bindViewportMetricListeners() {
  if (viewportMetricsListenersBound) {
    return;
  }
  viewportMetricsListenersBound = true;

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', scheduleViewportMetricsUpdate);
    window.visualViewport.addEventListener('scroll', scheduleViewportMetricsUpdate);
  }

  window.addEventListener('resize', scheduleViewportMetricsUpdate);
  window.addEventListener('orientationchange', scheduleViewportMetricsUpdate);
  try {
    window.addEventListener('scroll', scheduleViewportMetricsUpdate, { passive: true });
  } catch (error) {
    window.addEventListener('scroll', scheduleViewportMetricsUpdate);
  }
  window.addEventListener('focus', scheduleViewportMetricsUpdate);
  window.addEventListener('pageshow', scheduleViewportMetricsUpdate);
  window.addEventListener('load', scheduleViewportMetricsUpdate);
}

function setupTabBar() {
  const tabBar = document.getElementById('tabBar');
  if (!tabBar) {
    return;
  }

  bindViewportMetricListeners();
  applyViewportMetrics();
  scheduleViewportMetricsUpdate();
  setTimeout(scheduleViewportMetricsUpdate, 350);

  tabBar.addEventListener('click', event => {
    const button = event.target.closest('.tab-bar__btn');
    if (!button) {
      return;
    }

    if (button.hasAttribute('data-sheet-trigger')) {
      const sheet = document.getElementById('actionSheet');
      if (sheet?.classList.contains('is-visible')) {
        closeActionSheet();
      } else {
        openActionSheet(button);
      }
      return;
    }

    if (button.hasAttribute('data-filter-trigger')) {
      const sheet = document.getElementById('filterSheet');
      if (sheet?.classList.contains('is-visible')) {
        closeFilterSheet();
      } else {
        closeActionSheet();
        openFilterSheet(button);
      }
      return;
    }

    const view = button.dataset.viewTarget;
    if (view) {
      changeView(view);
    }
  });

  tabBar.addEventListener('keydown', event => {
    const buttons = Array.from(tabBar.querySelectorAll('.tab-bar__btn:not([data-sheet-trigger])'));
    if (!buttons.length) {
      return;
    }

    const current = document.activeElement;
    const index = buttons.indexOf(current);
    if (index === -1) {
      return;
    }

    let nextIndex = index;
    switch (event.key) {
      case 'ArrowRight':
        nextIndex = (index + 1) % buttons.length;
        break;
      case 'ArrowLeft':
        nextIndex = (index - 1 + buttons.length) % buttons.length;
        break;
      case 'Home':
        nextIndex = 0;
        break;
      case 'End':
        nextIndex = buttons.length - 1;
        break;
      default:
        return;
    }

    event.preventDefault();
    buttons[nextIndex].focus();
  });
}

let actionSheetHideTimer = null;
let actionSheetTriggerEl = null;
let filterSheetHideTimer = null;
let filterSheetTriggerEl = null;
let sourceSheetHideTimer = null;
let sourceSheetTriggerEl = null;

function openActionSheet(trigger) {
  const sheet = document.getElementById('actionSheet');
  if (!sheet) {
    return;
  }

  if (actionSheetHideTimer) {
    clearTimeout(actionSheetHideTimer);
    actionSheetHideTimer = null;
  }

  actionSheetTriggerEl = trigger || actionSheetTriggerEl || document.getElementById('moreActionsTrigger');

  sheet.hidden = false;
  sheet.classList.add('is-visible');
  sheet.setAttribute('aria-hidden', 'false');

  if (actionSheetTriggerEl) {
    actionSheetTriggerEl.setAttribute('aria-expanded', 'true');
  }

  const firstAction = sheet.querySelector('[data-sheet-action]');
  requestAnimationFrame(() => {
    firstAction?.focus({ preventScroll: true });
  });

  triggerHaptic('action');
}

function closeActionSheet() {
  const sheet = document.getElementById('actionSheet');
  if (!sheet || sheet.hidden) {
    return;
  }

  sheet.classList.remove('is-visible');
  sheet.setAttribute('aria-hidden', 'true');

  if (actionSheetTriggerEl) {
    actionSheetTriggerEl.setAttribute('aria-expanded', 'false');
    actionSheetTriggerEl.focus({ preventScroll: true });
  }

  if (actionSheetHideTimer) {
    clearTimeout(actionSheetHideTimer);
  }

  actionSheetHideTimer = setTimeout(() => {
    sheet.hidden = true;
  }, 320);
}

function markAllRead() {
  STATE.items.forEach(item => {
    const cardId = createCardId(item.link);
    setReadProgress(cardId, 100);
  });

  document.querySelectorAll('.card').forEach(card => {
    const meter = card.querySelector('.reading-progress__meter');
    const wrapper = card.querySelector('.reading-progress');
    if (meter) {
      meter.style.setProperty('--progress', '1');
    }
    if (wrapper) {
      wrapper.setAttribute('aria-valuenow', '100');
    }
    card.classList.remove('fresh');
  });

  triggerHaptic('mark');
  toast('Marked everything as read', 'success');
}

function performReset() {
  if (confirm('Reset all settings and data?')) {
    triggerHaptic('action');
    localStorage.clear();
    location.reload();
  }
}

function setupActionSheet() {
  const sheet = document.getElementById('actionSheet');
  if (!sheet) {
    return;
  }

  sheet.addEventListener('click', event => {
    const closeTarget = event.target.closest('[data-sheet-close]');
    if (closeTarget) {
      closeActionSheet();
      return;
    }

    const action = event.target.closest('[data-sheet-action]');
    if (!action) {
      return;
    }

    const { sheetAction } = action.dataset;
    switch (sheetAction) {
      case 'refresh':
        triggerHaptic('refresh');
        updatePullIndicator('loading', 'Updating…');
        loadFeeds();
        break;
      case 'mark-read':
        markAllRead();
        break;
      case 'reset':
        performReset();
        break;
      default:
        break;
    }

    closeActionSheet();
  });

  sheet.querySelector('.action-sheet__overlay')?.addEventListener('click', () => {
    closeActionSheet();
  });

  document.addEventListener('keydown', event => {
    if (event.key === 'Escape') {
      closeActionSheet();
    }
  });
}

function openFilterSheet(trigger) {
  const sheet = document.getElementById('filterSheet');
  if (!sheet) {
    return;
  }

  if (filterSheetHideTimer) {
    clearTimeout(filterSheetHideTimer);
    filterSheetHideTimer = null;
  }

  filterSheetTriggerEl = trigger || filterSheetTriggerEl || document.getElementById('filterTrigger');

  sheet.hidden = false;
  sheet.classList.add('is-visible');
  sheet.setAttribute('aria-hidden', 'false');

  if (filterSheetTriggerEl) {
    filterSheetTriggerEl.setAttribute('aria-expanded', 'true');
    filterSheetTriggerEl.setAttribute('aria-selected', 'true');
  }

  const firstChip = sheet.querySelector('.filters .chip');
  requestAnimationFrame(() => {
    firstChip?.focus({ preventScroll: true });
  });

  triggerHaptic('action');
}

function closeFilterSheet() {
  const sheet = document.getElementById('filterSheet');
  if (!sheet || sheet.hidden) {
    return;
  }

  closeSourceSheet({ skipFocus: true });

  sheet.classList.remove('is-visible');
  sheet.setAttribute('aria-hidden', 'true');

  if (filterSheetTriggerEl) {
    filterSheetTriggerEl.setAttribute('aria-expanded', 'false');
    filterSheetTriggerEl.setAttribute('aria-selected', 'false');
    filterSheetTriggerEl.focus({ preventScroll: true });
  }

  if (filterSheetHideTimer) {
    clearTimeout(filterSheetHideTimer);
  }

  filterSheetHideTimer = setTimeout(() => {
    sheet.hidden = true;
  }, 320);
}

function setupFilterSheet() {
  const sheet = document.getElementById('filterSheet');
  if (!sheet) {
    return;
  }

  sheet.addEventListener('click', event => {
    if (event.target.closest('[data-filter-close]')) {
      closeFilterSheet();
    }
  });

  document.addEventListener('keydown', event => {
    if (event.key === 'Escape' && !sheet.hidden) {
      const sourceSheet = document.getElementById('sourceSheet');
      if (sourceSheet && !sourceSheet.hidden) {
        return;
      }
      closeFilterSheet();
    }
  });

  const sourceButton = document.getElementById('sourceFilterButton');
  if (sourceButton) {
    sourceButton.addEventListener('click', () => {
      openSourceSheet(sourceButton);
    });
  }
}

function openSourceSheet(trigger) {
  const sheet = document.getElementById('sourceSheet');
  if (!sheet) {
    return;
  }

  if (sourceSheetHideTimer) {
    clearTimeout(sourceSheetHideTimer);
    sourceSheetHideTimer = null;
  }

  sourceSheetTriggerEl = trigger || sourceSheetTriggerEl || document.getElementById('sourceFilterButton');

  sheet.hidden = false;
  sheet.classList.add('is-visible');
  sheet.setAttribute('aria-hidden', 'false');

  if (sourceSheetTriggerEl) {
    sourceSheetTriggerEl.setAttribute('aria-expanded', 'true');
  }

  const selected = sheet.querySelector('.source-option[aria-selected="true"]');
  const fallback = sheet.querySelector('.source-option');
  requestAnimationFrame(() => {
    (selected || fallback)?.focus({ preventScroll: true });
  });

  triggerHaptic('action');
}

function closeSourceSheet(options = {}) {
  const sheet = document.getElementById('sourceSheet');
  if (!sheet || sheet.hidden) {
    return;
  }

  const skipFocus = typeof options === 'object' && options.skipFocus === true;

  sheet.classList.remove('is-visible');
  sheet.setAttribute('aria-hidden', 'true');

  if (sourceSheetTriggerEl) {
    sourceSheetTriggerEl.setAttribute('aria-expanded', 'false');
    if (!skipFocus) {
      sourceSheetTriggerEl.focus({ preventScroll: true });
    }
  }

  if (sourceSheetHideTimer) {
    clearTimeout(sourceSheetHideTimer);
  }

  sourceSheetHideTimer = setTimeout(() => {
    sheet.hidden = true;
  }, 320);
}

function setupSourceSheet() {
  const sheet = document.getElementById('sourceSheet');
  if (!sheet) {
    return;
  }

  sheet.addEventListener('click', event => {
    if (event.target.closest('[data-source-close]')) {
      closeSourceSheet();
    }
  });

  document.addEventListener('keydown', event => {
    if (event.key === 'Escape' && !sheet.hidden) {
      closeSourceSheet();
    }
  });

  const clearButton = document.getElementById('clearSourceFilter');
  if (clearButton) {
    clearButton.addEventListener('click', () => {
      if (!STATE.sourceFilter) {
        closeSourceSheet();
        return;
      }
      STATE.sourceFilter = null;
      persistState();
      buildSourceToggles();
      updateSourceSummary();
      render();
      triggerHaptic('tab');
      closeSourceSheet();
    });
  }
}

function setupPullToRefresh() {
  const indicator = document.getElementById('pullIndicator');
  if (!indicator) {
    return;
  }

  let startY = 0;
  let pulling = false;
  let ready = false;
  let pullActive = false;

  const resetPull = () => {
    document.body.style.setProperty('--pull-distance', '0px');
    pulling = false;
    ready = false;
    pullActive = false;
    indicator.dataset.state = 'idle';
    indicator.style.opacity = 0;
  };

  window.addEventListener(
    'touchstart',
    event => {
      if (STATE.loading || window.scrollY > 0) {
        return;
      }
      startY = event.touches[0].clientY;
      pulling = true;
      ready = false;
      pullActive = false;
      indicator.dataset.state = 'idle';
      indicator.textContent = 'Pull to refresh';
      indicator.style.opacity = 0;
    },
    { passive: true }
  );

  window.addEventListener(
    'touchmove',
    event => {
      if (!pulling) {
        return;
      }
      if (window.scrollY > 0) {
        resetPull();
        return;
      }

      const delta = event.touches[0].clientY - startY;
      if (delta <= 0) {
        resetPull();
        return;
      }

      if (!pullActive && delta < 32) {
        return;
      }

      if (!pullActive) {
        pullActive = true;
      }

      event.preventDefault();
      const limited = Math.min(220, delta);
      const eased = Math.pow(limited / 220, 0.85) * 220;
      document.body.style.setProperty('--pull-distance', `${eased}px`);
      indicator.style.opacity = Math.min(1, eased / 120);

      if (eased > 140) {
        indicator.dataset.state = 'ready';
        indicator.textContent = 'Release to refresh';
        if (!ready) {
          triggerHaptic('pull-ready');
          ready = true;
        }
      } else {
        indicator.dataset.state = 'idle';
        indicator.textContent = 'Pull to refresh';
        ready = false;
      }
    },
    { passive: false }
  );

  const endPull = () => {
    if (!pulling) {
      return;
    }

    document.body.style.setProperty('--pull-distance', '0px');
    indicator.style.opacity = 0;

    if (ready && pullActive && !STATE.loading) {
      indicator.dataset.state = 'loading';
      indicator.textContent = 'Updating…';
      triggerHaptic('refresh');
      loadFeeds();
    } else {
      indicator.dataset.state = 'idle';
    }

    pulling = false;
    ready = false;
    pullActive = false;
  };

  window.addEventListener('touchend', endPull);
  window.addEventListener('touchcancel', endPull);
}

const SENTIMENT_LEXICON = new Map([
  ['victory', 4.5],
  ['victories', 4.5],
  ['landslide', 5],
  ['triumph', 4],
  ['triumphant', 4],
  ['win', 3.5],
  ['wins', 3.5],
  ['won', 3.5],
  ['winning', 3.2],
  ['record', 3],
  ['records', 3],
  ['breakthrough', 4],
  ['surge', 2.6],
  ['surging', 2.6],
  ['surged', 2.6],
  ['boom', 3.1],
  ['booming', 3.4],
  ['boon', 2.5],
  ['resilient', 2.2],
  ['resilience', 2.2],
  ['relief', 2.4],
  ['stability', 2.1],
  ['stabilize', 2.1],
  ['stabilized', 2.1],
  ['improves', 2.2],
  ['improved', 2.2],
  ['improving', 2.2],
  ['progress', 2.5],
  ['peace', 2.6],
  ['peaceful', 2.6],
  ['secure', 2.1],
  ['secured', 2.1],
  ['support', 2],
  ['supports', 2],
  ['praise', 2.5],
  ['praised', 2.5],
  ['optimism', 2.5],
  ['optimistic', 2.5],
  ['growth', 2.3],
  ['grows', 2.3],
  ['growing', 2.3],
  ['rebound', 2.6],
  ['rebounds', 2.6],
  ['rebounded', 2.6],
  ['strength', 2.4],
  ['strengthen', 2.4],
  ['strengthens', 2.4],
  ['strengthened', 2.4],
  ['crisis', -3.5],
  ['crises', -3.5],
  ['catastrophe', -5.5],
  ['disaster', -5],
  ['collapse', -4.5],
  ['collapsed', -4.5],
  ['collapsing', -4.5],
  ['chaos', -3.5],
  ['chaotic', -3],
  ['shooting', -5],
  ['shootings', -5],
  ['attack', -3.5],
  ['attacks', -3.5],
  ['assault', -3],
  ['massacre', -6],
  ['tragedy', -5],
  ['fatal', -4],
  ['deadly', -4.5],
  ['murder', -5],
  ['murdered', -5],
  ['violence', -4],
  ['violent', -4],
  ['threat', -3],
  ['threats', -3],
  ['warning', -2.5],
  ['warnings', -2.5],
  ['fear', -2.5],
  ['fears', -2.5],
  ['panic', -4],
  ['emergency', -3.5],
  ['fraud', -3],
  ['scandal', -3.5],
  ['scandals', -3.5],
  ['corruption', -3.5],
  ['corrupt', -3],
  ['indicted', -4],
  ['indictment', -4],
  ['charged', -3],
  ['charges', -3],
  ['arrested', -3.5],
  ['arrests', -3.5],
  ['lawsuit', -2.5],
  ['lawsuits', -2.5],
  ['investigation', -2.2],
  ['investigations', -2.2],
  ['probe', -2.2],
  ['probes', -2.2],
  ['meltdown', -5],
  ['shortage', -2.5],
  ['shortages', -2.5],
  ['decline', -2.5],
  ['declines', -2.5],
  ['plunge', -3.5],
  ['plunges', -3.5],
  ['slump', -3],
  ['slumps', -3],
  ['sanction', -2.5],
  ['sanctions', -2.5],
  ['ban', -2.5],
  ['banned', -2.5],
  ['outage', -2],
  ['outages', -2],
  ['breach', -3],
  ['breaches', -3]
]);

const POSITIVE_WORDS = new Set([
  'good', 'great', 'positive', 'upbeat', 'hope', 'hopes', 'hopeful', 'advance', 'advances',
  'advancing', 'strong', 'stronger', 'sturdy', 'rescue', 'rescued', 'rescues', 'ally', 'allies',
  'agreement', 'agreements', 'calm', 'steady', 'supportive', 'boost', 'boosts', 'benefit',
  'benefits', 'recover', 'recovery', 'recovered', 'healing', 'relief', 'relieved', 'progressive',
  'peaceful', 'stable', 'stability', 'balanced', 'constructive', 'diplomatic', 'unity', 'unite',
  'unites', 'secured', 'security', 'resilient', 'cooperate', 'cooperation', 'truce', 'win-win'
]);

const NEGATIVE_WORDS = new Set([
  'loss', 'losses', 'lost', 'defeat', 'defeated', 'risk', 'risks', 'concern', 'concerns', 'doubt',
  'doubts', 'fear', 'fears', 'worry', 'worries', 'worried', 'drop', 'drops', 'fall', 'falls',
  'fallen', 'negative', 'bad', 'threat', 'threaten', 'threatened', 'danger', 'dangerous', 'fraud',
  'crash', 'crashes', 'collapsed', 'collapse', 'lawsuit', 'lawsuits', 'probe', 'probes', 'charge',
  'charges', 'investigation', 'chaos', 'violent', 'violence', 'crime', 'crimes', 'criminal',
  'riot', 'riots', 'riotous', 'storm', 'storms', 'hurricane', 'earthquake', 'wildfire', 'fire',
  'fires', 'shooting', 'shootings', 'attack', 'attacks', 'murder', 'murdered', 'extremist',
  'extremism', 'terror', 'terrorism', 'terrorist', 'scandal', 'panic', 'shortage', 'shortages',
  'decline', 'declines', 'slump', 'slumps', 'collapse', 'opposition', 'backlash', 'controversy'
]);

const BOOSTER_WORDS = new Set(['very', 'extremely', 'highly', 'truly', 'deeply', 'major', 'massive', 'hugely', 'seriously', 'significantly']);
const DAMPENER_WORDS = new Set(['slightly', 'barely', 'somewhat', 'mildly', 'modestly', 'partially']);
const NEGATION_WORDS = new Set(['no', 'not', 'never', 'without', 'hardly', 'rarely', 'scarcely', 'neither']);

const BIAS_RANGE = 10;

const BIAS_PHRASES = [
  { pattern: /climate (?:crisis|change)/i, weight: -2.4 },
  { pattern: /carbon emissions/i, weight: -2.1 },
  { pattern: /clean energy/i, weight: -1.8 },
  { pattern: /green energy/i, weight: -2 },
  { pattern: /renewable energy/i, weight: -2.2 },
  { pattern: /gun control/i, weight: -2.6 },
  { pattern: /racial justice/i, weight: -2.2 },
  { pattern: /reproductive rights/i, weight: -2.5 },
  { pattern: /abortion rights/i, weight: -2.4 },
  { pattern: /medicare for all/i, weight: -3 },
  { pattern: /universal health care/i, weight: -2.6 },
  { pattern: /student loan (?:forgiveness|relief)/i, weight: -2.1 },
  { pattern: /voting rights/i, weight: -1.7 },
  { pattern: /police reform/i, weight: -1.8 },
  { pattern: /criminal justice reform/i, weight: -1.8 },
  { pattern: /lgbtq rights/i, weight: -2.1 },
  { pattern: /trans rights/i, weight: -2.1 },
  { pattern: /marriage equality/i, weight: -2 },
  { pattern: /border security/i, weight: 2.5 },
  { pattern: /border wall/i, weight: 3 },
  { pattern: /illegal immigration/i, weight: 2.5 },
  { pattern: /secure the border/i, weight: 2.8 },
  { pattern: /america first/i, weight: 2.6 },
  { pattern: /law and order/i, weight: 2.3 },
  { pattern: /second amendment/i, weight: 3 },
  { pattern: /gun rights/i, weight: 2.4 },
  { pattern: /right to life/i, weight: 2.4 },
  { pattern: /pro-life/i, weight: 2.2 },
  { pattern: /religious liberty/i, weight: 2 },
  { pattern: /parental rights/i, weight: 2.1 },
  { pattern: /school choice/i, weight: 2.2 },
  { pattern: /limited government/i, weight: 2.2 },
  { pattern: /small government/i, weight: 2.2 },
  { pattern: /tax (?:cuts|cut)/i, weight: 1.8 },
  { pattern: /energy independence/i, weight: 1.7 },
  { pattern: /anti-woke/i, weight: 2 },
  { pattern: /woke agenda/i, weight: 2.1 }
];

const BIAS_KEYWORDS = new Map([
  ['progressive', -1.6],
  ['progressives', -1.6],
  ['liberal', -1.4],
  ['liberals', -1.4],
  ['democrat', -1.1],
  ['democrats', -1.1],
  ['biden', -0.8],
  ['harris', -0.7],
  ['climate', -1.3],
  ['emissions', -1.2],
  ['renewable', -1.1],
  ['sustainable', -1],
  ['equity', -1.3],
  ['diversity', -1.2],
  ['inclusion', -1.1],
  ['inclusive', -1],
  ['lgbtq', -1.4],
  ['transgender', -1.5],
  ['abortion', -0.9],
  ['reproductive', -1.3],
  ['union', -1],
  ['unions', -1],
  ['conservative', 1.5],
  ['conservatives', 1.5],
  ['republican', 1.2],
  ['republicans', 1.2],
  ['trump', 1.2],
  ['desantis', 1],
  ['patriot', 1.8],
  ['patriots', 1.6],
  ['liberty', 1.2],
  ['freedom', 1],
  ['border', 1.4],
  ['woke', 1.6],
  ['christian', 1.2],
  ['faith', 0.9],
  ['gun', 0.8],
  ['guns', 0.8],
  ['patriotic', 1.4],
  ['nationalist', 1.6],
  ['sovereignty', 1.3]
]);

const SOURCE_BIAS_BASELINES = new Map(SOURCES.map(source => [source.id, source.bias ?? 0]));

const CLICKBAIT_PATTERNS = [
  /you won't believe/i,
  /you will not believe/i,
  /jaw[-\s]?dropping/i,
  /what happens next/i,
  /this is why/i,
  /must see/i,
  /can't miss/i,
  /goes viral/i,
  /internet reacts/i,
  /breaks the internet/i,
  /things get/i,
  /shocking/i,
  /insane/i,
  /crazy/i,
  /epic/i,
  /unbelievable/i,
  /life[-\s]?changing/i,
  /top \d+ (things|reasons|ways|tricks|hacks)/i,
  /mind[-\s]?blowing/i,
  /game[-\s]?changer/i,
  /bombshell/i,
  /one weird trick/i,
  /this changes everything/i,
  /must[-\s]?read/i,
  /must[-\s]?watch/i,
  /can't believe/i,
  /mic drop/i,
  /claps? back/i,
  /goes off on/i,
  /freaks out/i,
  /meltdown/i,
  /epic fail/i
];

const NON_NEWS_PATTERNS = [
  /^watch:/i,
  /^listen:/i,
  /^video:/i,
  /\bopinion\b/i,
  /\bcommentary\b/i,
  /\bcolumn\b/i,
  /\beditorial\b/i,
  /\bpodcast\b/i,
  /\bnewsletter\b/i,
  /\brecap\b/i,
  /\bhow to\b/i,
  /\bhow-to\b/i,
  /\bexplainer\b/i,
  /\breview\b/i,
  /\bsponsored\b/i,
  /\badvertis/i,
  /\bdeal\b/i,
  /\bdeals\b/i,
  /\bdiscount\b/i,
  /\bsale\b/i,
  /\bmerch\b/i,
  /\bshop\b/i,
  /\bcelebrity\b/i,
  /\bentertainment\b/i,
  /\besports?\b/i,
  /\bsports?\b/i,
  /\bfootball\b/i,
  /\bbasketball\b/i,
  /\bbaseball\b/i,
  /\bsoccer\b/i,
  /\btennis\b/i,
  /\bhockey\b/i,
  /\bgolf\b/i,
  /\bnfl\b/i,
  /\bnba\b/i,
  /\bmlb\b/i,
  /\bnhl\b/i,
  /\bncaa\b/i,
  /\bsubscribe\b/i,
  /click here/i
];

const NON_NEWS_PATH_FRAGMENTS = [
  '/video',
  '/videos',
  '/podcast',
  '/opinion',
  '/commentary',
  '/column',
  '/blog',
  '/sponsored',
  '/commerce',
  '/shopping',
  '/lifestyle',
  '/entertainment',
  '/sports',
  '/sport',
  '/nfl',
  '/nba',
  '/mlb',
  '/nhl',
  '/soccer',
  '/golf',
  '/tennis'
];

const ESCAPE_MAP = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

let domUpdates = [];

function loadPersistedState() {
  try {
    const expanded = JSON.parse(localStorage.getItem('urnews.expanded'));
    const storedSource = localStorage.getItem('urnews.sourceFilter');
    const progressRaw = localStorage.getItem('urnews.progress');
    const viewPreference = localStorage.getItem('urnews.view');
    let progress = {};

    if (progressRaw) {
      try {
        const parsed = JSON.parse(progressRaw);
        if (parsed && typeof parsed === 'object') {
          progress = parsed;
        }
      } catch (error) {
        progress = {};
      }
    }

    return {
      expanded: Array.isArray(expanded) ? expanded : null,
      sourceFilter: storedSource || null,
      progress,
      view: viewPreference || 'all'
    };
  } catch (error) {
    return { expanded: null, sourceFilter: null, progress: {}, view: 'all' };
  }
}

function persistState() {
  try {
    localStorage.setItem('urnews.expanded', JSON.stringify([...STATE.expandedCards]));
    localStorage.setItem('urnews.view', STATE.view);
    localStorage.setItem('urnews.progress', JSON.stringify(Object.fromEntries(STATE.readProgress)));
    if (STATE.sourceFilter) {
      localStorage.setItem('urnews.sourceFilter', STATE.sourceFilter);
    } else {
      localStorage.removeItem('urnews.sourceFilter');
    }
  } catch (error) {
    console.warn('Storage failed:', error);
  }
}

function batchDOM(fn) {
  domUpdates.push(fn);
  if (domUpdates.length === 1) {
    requestAnimationFrame(() => {
      domUpdates.forEach(update => update());
      domUpdates = [];
    });
  }
}

function getCached(url) {
  const cached = STATE.cache.get(url);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  return null;
}

function setCached(url, data) {
  STATE.cache.set(url, { data, timestamp: Date.now() });
}

function fetchProxy(url) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), FETCH_TIMEOUT);

  const promise = fetch(url, { signal: controller.signal }).then(response => {
    clearTimeout(timer);
    if (!response.ok) {
      throw new Error('Bad response');
    }
    return response;
  }).catch(error => {
    clearTimeout(timer);
    throw error;
  });

  return {
    promise,
    cancel() {
      clearTimeout(timer);
      controller.abort();
    }
  };
}

function firstSuccessful(promises) {
  return new Promise((resolve, reject) => {
    let remaining = promises.length;
    const errors = [];

    promises.forEach((promise, index) => {
      promise
        .then(value => resolve({ value, index }))
        .catch(error => {
          errors.push(error);
          remaining -= 1;
          if (remaining === 0) {
            reject(errors[errors.length - 1] || new Error('All proxies failed'));
          }
        });
    });
  });
}

async function fetchFast(url) {
  const cached = getCached(url);
  if (cached) {
    return cached;
  }

  const targets = [
    `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    `https://corsproxy.io/?${encodeURIComponent(url)}`
  ].map(fetchProxy);

  try {
    const { value: response, index } = await firstSuccessful(targets.map(target => target.promise));
    const text = await response.text();
    targets.forEach((target, idx) => {
      if (idx !== index) {
        target.cancel();
      }
    });
    if (!text || text.length < 100) {
      throw new Error('Empty feed');
    }
    setCached(url, text);
    return text;
  } finally {
    targets.forEach(target => target.cancel());
  }
}

function calculateTrending(items) {
  const keywords = new Map();
  const now = Date.now();

  items.forEach(item => {
    const ageHours = (now - new Date(item.pubDate)) / (1000 * 60 * 60);
    if (ageHours > 24) {
      return;
    }

    const text = `${item.title} ${item.desc}`.toLowerCase();
    const words = text.match(/\b[a-z]{4,}\b/g) || [];

    words.forEach(word => {
      if (!/^(with|that|this|from|have|were|been|their|about|would|could|should)$/.test(word)) {
        const current = keywords.get(word) || 0;
        keywords.set(word, current + (1 / Math.max(1, ageHours / 6)));
      }
    });
  });

  STATE.trendingKeywords = keywords;

  items.forEach(item => {
    const text = `${item.title} ${item.desc}`.toLowerCase();
    let score = 0;
    keywords.forEach((weight, word) => {
      if (text.includes(word)) {
        score += weight;
      }
    });
    item.trendingScore = score;
  });
}

function scoreTokens(tokens, scale = 1) {
  let total = 0;

  for (let i = 0; i < tokens.length; i += 1) {
    const word = tokens[i];
    let weight = 0;

    if (SENTIMENT_LEXICON.has(word)) {
      weight = SENTIMENT_LEXICON.get(word);
    } else if (POSITIVE_WORDS.has(word)) {
      weight = 1;
    } else if (NEGATIVE_WORDS.has(word)) {
      weight = -1;
    }

    if (weight !== 0) {
      const previous = tokens[i - 1];
      if (previous && NEGATION_WORDS.has(previous)) {
        weight *= -1;
      }
      if (previous && BOOSTER_WORDS.has(previous)) {
        weight *= 1.4;
      } else if (previous && DAMPENER_WORDS.has(previous)) {
        weight *= 0.5;
      }

      total += weight * scale;
    }
  }

  return total;
}

function describeSentiment(score) {
  if (score >= 6) {
    return { label: 'ELECTRIC', tone: 'very-positive' };
  }
  if (score >= 3) {
    return { label: 'OPTIMISTIC', tone: 'positive' };
  }
  if (score > -2) {
    return { label: 'STEADY', tone: 'neutral' };
  }
  if (score > -5) {
    return { label: 'WARY', tone: 'negative' };
  }
  return { label: 'ALARMED', tone: 'very-negative' };
}

function formatSentimentScore(score = 0) {
  if (typeof score !== 'number' || Number.isNaN(score)) {
    return '0.0';
  }
  const rounded = Math.round(score * 10) / 10;
  return `${rounded > 0 ? '+' : ''}${rounded.toFixed(1)}`;
}

function analyzeSentiment(item) {
  const titleTokens = (item.title || '').toLowerCase().match(/\b[a-z'-]+\b/g) || [];
  const descTokens = (item.desc || '').toLowerCase().match(/\b[a-z'-]+\b/g) || [];

  let score = 0;
  score += scoreTokens(titleTokens, 1.4);
  score += scoreTokens(descTokens, 0.8);

  const exclamations = (item.title.match(/!/g) || []).length;
  if (exclamations > 1) {
    score -= (exclamations - 1) * 0.6;
  }

  score = Math.max(-12, Math.min(12, score));

  const descriptor = describeSentiment(score);

  return { label: descriptor.label, tone: descriptor.tone, score };
}

function describeBias(score) {
  if (score <= -4.5) {
    return { label: 'Leans Left', className: 'left' };
  }
  if (score < -1.5) {
    return { label: 'Left of Center', className: 'left-soft' };
  }
  if (score <= 1.5) {
    return { label: 'Center', className: 'center' };
  }
  if (score < 4.5) {
    return { label: 'Right of Center', className: 'right-soft' };
  }
  return { label: 'Leans Right', className: 'right' };
}

function analyzeBias(item) {
  const text = `${item.title || ''} ${item.desc || ''}`.toLowerCase();
  let score = SOURCE_BIAS_BASELINES.get(item.id) ?? 0;

  BIAS_PHRASES.forEach(({ pattern, weight }) => {
    if (pattern.test(text)) {
      score += weight;
    }
  });

  const tokens = new Set(text.match(/\b[a-z]{3,}\b/g) || []);
  tokens.forEach(token => {
    if (BIAS_KEYWORDS.has(token)) {
      score += BIAS_KEYWORDS.get(token);
    }
  });

  if (/fact[-\s]?check/i.test(text)) {
    score -= 1.4;
  }

  if (/hunter biden/i.test(text)) {
    score += 1.4;
  }

  if (/white house/i.test(text)) {
    score -= 0.4;
  }

  const bounded = Math.max(-BIAS_RANGE, Math.min(BIAS_RANGE, score));
  const descriptor = describeBias(bounded);
  const displayScore = Number(bounded.toFixed(2));

  return {
    score: displayScore,
    label: descriptor.label,
    className: descriptor.className
  };
}

function createCardId(link) {
  let hash = 0;
  for (let i = 0; i < link.length; i += 1) {
    hash = (hash << 5) - hash + link.charCodeAt(i);
    hash |= 0;
  }
  return `card-${Math.abs(hash)}`;
}

function parseRSS(xmlString, source) {
  const doc = new DOMParser().parseFromString(xmlString, 'text/xml');
  if (doc.getElementsByTagName('parsererror')[0]) {
    return [];
  }

  return Array.from(doc.querySelectorAll('item, entry'))
    .slice(0, 15)
    .map(entry => {
      const title = (entry.querySelector('title')?.textContent || '').trim();
      const link = (entry.querySelector('link')?.getAttribute('href') || entry.querySelector('link')?.textContent || '').trim();
      const pubDate = (entry.querySelector('pubDate, updated, published')?.textContent || '').trim();
      const desc = (entry.querySelector('description, summary')?.textContent || '').trim();

      return {
        title,
        link,
        pubDate: pubDate || new Date().toISOString(),
        source: source.name,
        lane: source.lane,
        id: source.id,
        desc: stripHTML(desc).slice(0, 250),
        isBreaking: /breaking|urgent|just in|developing|exclusive/i.test(title),
        trendingScore: 0
      };
    })
    .filter(item => item.title && item.link && item.title.length > 15);
}

function stripHTML(html) {
  const temp = document.createElement('div');
  temp.innerHTML = html;
  return temp.textContent.replace(/\s+/g, ' ').trim();
}

function isLikelyNews(item) {
  const title = (item.title || '').trim();
  if (!title) {
    return false;
  }

  const description = (item.desc || '').trim();
  const combined = `${title} ${description}`.toLowerCase();

  if (/\?{2,}/.test(title) || /!{2,}/.test(title)) {
    return false;
  }

  if (CLICKBAIT_PATTERNS.some(pattern => pattern.test(combined))) {
    return false;
  }

  if (NON_NEWS_PATTERNS.some(pattern => pattern.test(title)) || NON_NEWS_PATTERNS.some(pattern => pattern.test(description))) {
    return false;
  }

  try {
    const url = new URL(item.link);
    const path = `${url.pathname}${url.search}`.toLowerCase();
    if (NON_NEWS_PATH_FRAGMENTS.some(fragment => path.includes(fragment))) {
      return false;
    }
  } catch (error) {
    const fallback = (item.link || '').toLowerCase();
    if (NON_NEWS_PATH_FRAGMENTS.some(fragment => fallback.includes(fragment))) {
      return false;
    }
  }

  const exclamationCount = (title.match(/!/g) || []).length;
  if (exclamationCount > 2) {
    return false;
  }

  return true;
}

function showLoading() {
  const feedList = document.getElementById('feedList');
  feedList.innerHTML = '';
  const fragment = document.createDocumentFragment();

  for (let i = 0; i < 8; i += 1) {
    const skeleton = document.createElement('div');
    skeleton.className = 'loading-card';
    skeleton.innerHTML = `
      <div class="skeleton loading-title"></div>
      <div class="skeleton loading-meta"></div>
    `;
    fragment.appendChild(skeleton);
  }

  feedList.appendChild(fragment);
}

async function loadFeeds() {
  if (STATE.loading) {
    return;
  }

  STATE.loading = true;
  STATE.lastFetch = Date.now();
  showLoading();
  const indicator = document.getElementById('pullIndicator');
  if (indicator && (indicator.dataset.state === 'ready' || indicator.dataset.state === 'loading')) {
    updatePullIndicator('loading', 'Updating…');
  }

  try {
    const fetches = SOURCES.map(source =>
      fetchFast(source.url)
        .then(text => parseRSS(text, source))
        .catch(error => {
          console.warn('Feed failed:', source.name, error);
          return [];
        })
    );

    const results = await Promise.all(fetches);
    const allItems = results.flat();

    const deduped = [];
    const seen = new Set();

    allItems
      .sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate))
      .forEach(item => {
        if (!seen.has(item.link)) {
          seen.add(item.link);
          deduped.push(item);
        }
      });

    const curated = deduped.filter(isLikelyNews);
    STATE.items = curated.slice(0, 100);
    calculateTrending(STATE.items);
    STATE.items.forEach(item => {
      const sentiment = analyzeSentiment(item);
      item.sentimentScore = Number(sentiment.score.toFixed(2));
      item.sentimentLabel = sentiment.label;
      item.sentimentTone = sentiment.tone;

      const bias = analyzeBias(item);
      item.biasScore = bias.score;
    });

    render();
    const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    document.getElementById('lastUpdated').textContent = `• ${timestamp}`;
    const reportMessage = STATE.items.length ? `${STATE.items.length} reports ready` : 'Feed refreshed';
    toast(reportMessage, 'success');
    triggerHaptic('success');
    if (indicator && indicator.dataset.state === 'loading') {
      updatePullIndicator('updated', 'Updated');
    }
  } catch (error) {
    console.error('Failed:', error);
    document.getElementById('lastUpdated').textContent = '• RETRY';
    updateMoodIndicator([]);
    toast('Loading failed', 'error');
    if (indicator && indicator.dataset.state === 'loading') {
      updatePullIndicator('updated', 'Refresh failed');
    }
  } finally {
    STATE.loading = false;
  }
}


function createCard(item, index = 0, total = 1) {
  const cardId = createCardId(item.link);
  const isExpanded = STATE.expandedCards.has(cardId);
  const isTrending = item.trendingScore > 5;
  const isFresh = isFreshStory(item);
  const importance = determineImportance(item, index);
  const credibility = getCredibility(item);
  const sentimentTone = ['very-positive', 'positive', 'neutral', 'negative', 'very-negative'].includes(item.sentimentTone)
    ? item.sentimentTone
    : 'neutral';
  const sentimentScoreFormatted = formatSentimentScore(item.sentimentScore);
  const progressValue = getReadProgress(cardId);

  const article = document.createElement('article');
  const classes = ['card', 'smooth', `card--${importance}`];
  if (isExpanded) {
    classes.push('open');
  }
  if (isTrending) {
    classes.push('popular', 'card--trending');
  }
  if (item.isBreaking) {
    classes.push('card--breaking');
  }
  if (isFresh) {
    classes.push('fresh');
  }
  article.className = classes.join(' ');
  article.dataset.cardId = cardId;
  article.dataset.importance = importance;

  const stackIndex = Math.min(index, 4);
  article.style.setProperty('--stack-offset', `${stackIndex * 12}px`);
  article.style.setProperty('--stack-scale', (1 - stackIndex * 0.015).toFixed(3));
  article.style.setProperty('--card-delay', `${Math.min(index * 60, 420)}ms`);

  let hostname = '';
  try {
    hostname = new URL(item.link).hostname;
  } catch (error) {
    hostname = '';
  }

  const timeString = fmtTime(item.pubDate);
  const sentimentBadge = item.sentimentLabel
    ? `<span class="badge sentiment ${sentimentTone}" title="Sentiment score ${sentimentScoreFormatted}">${escapeHTML(item.sentimentLabel)} • ${sentimentScoreFormatted}</span>`
    : '';
  const credibilityBadge = `<span class="badge credibility${credibility.toneClass ? ` ${credibility.toneClass}` : ''}" title="${escapeHTML(credibility.description)}">${escapeHTML(credibility.label)}</span>`;
  const freshBadge = isFresh ? '<span class="badge badge-fresh">NEW</span>' : '';

  const progressFraction = clamp(progressValue / 100, 0, 1);

  article.innerHTML = `
    <div class="card-glow" aria-hidden="true"></div>
    <div class="card-head" tabindex="0" role="button" aria-expanded="${isExpanded}" aria-controls="body-${cardId}">
      <span class="favicon" style="background-image:url('https://www.google.com/s2/favicons?domain=${hostname}&sz=64');" aria-hidden="true"></span>
      <div>
        <div class="titleline">
          ${escapeHTML(item.title)}
          ${item.isBreaking ? '<span class="breaking-indicator">BREAKING</span>' : ''}
        </div>
        <div class="tag">
          ${escapeHTML(item.source)} • <span class="time${isFresh ? ' time--fresh' : ''}">${timeString}</span>
          ${credibilityBadge}
          ${freshBadge}
          ${isTrending ? '<span class="badge trending">TRENDING</span>' : ''}
          ${sentimentBadge}
        </div>
      </div>
      <div class="reading-progress" role="progressbar" aria-label="Reading progress" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${Math.round(progressValue)}">
        <span class="reading-progress__meter" style="--progress:${progressFraction.toFixed(2)};"></span>
      </div>
      <div class="expand-btn" aria-hidden="true">${isExpanded ? '▼' : '▶'}</div>
    </div>
    <div class="card-body" id="body-${cardId}" role="region">
      <div class="card-summary">${escapeHTML(item.desc || 'No summary available.')}</div>
      <div class="card-actions">
        <a href="${escapeHTML(item.link)}" target="_blank" rel="noopener" class="article-link smooth">
          OPEN ARTICLE
        </a>
      </div>
    </div>
  `;

  const header = article.querySelector('.card-head');
  const expandBtn = article.querySelector('.expand-btn');
  const readingProgressEl = article.querySelector('.reading-progress');
  const progressMeter = article.querySelector('.reading-progress__meter');
  const articleLink = article.querySelector('.article-link');
  const cardBody = article.querySelector('.card-body');

  if (cardBody) {
    cardBody.hidden = !isExpanded;
  }

  const applyProgress = value => {
    const normalized = clamp(value, 0, 100);
    if (progressMeter) {
      progressMeter.style.setProperty('--progress', (normalized / 100).toFixed(2));
    }
    if (readingProgressEl) {
      readingProgressEl.setAttribute('aria-valuenow', String(Math.round(normalized)));
    }
    if (normalized >= 60) {
      article.classList.remove('fresh');
    }
    return normalized;
  };

  applyProgress(progressValue);

  const toggleCard = () => {
    const isOpen = article.classList.toggle('open');
    expandBtn.textContent = isOpen ? '▼' : '▶';
    header.setAttribute('aria-expanded', String(isOpen));
    if (cardBody) {
      cardBody.hidden = !isOpen;
    }

    if (isOpen) {
      triggerHaptic('expand');
      const ensured = ensureReadProgress(cardId, 40);
      applyProgress(ensured);
      STATE.expandedCards.add(cardId);
      document.querySelectorAll('.card.open').forEach(card => {
        if (card !== article) {
          card.classList.remove('open');
          const otherBtn = card.querySelector('.expand-btn');
          const otherHeader = card.querySelector('.card-head');
          const otherBody = card.querySelector('.card-body');
          if (otherBtn) {
            otherBtn.textContent = '▶';
          }
          if (otherHeader) {
            otherHeader.setAttribute('aria-expanded', 'false');
          }
          if (otherBody) {
            otherBody.hidden = true;
          }
          STATE.expandedCards.delete(card.dataset.cardId);
        }
      });
    } else {
      STATE.expandedCards.delete(cardId);
      if (cardBody) {
        cardBody.hidden = true;
      }
    }

    persistState();
  };

  header.addEventListener('click', toggleCard);
  header.addEventListener('keydown', event => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      toggleCard();
    }
  });

  if (articleLink) {
    articleLink.addEventListener('click', () => {
      const updated = setReadProgress(cardId, 100);
      applyProgress(updated);
      triggerHaptic('action');
    });
  }

  return article;
}


function updateMoodIndicator(items) {
  const moodEl = document.getElementById('overallMood');
  if (!moodEl) {
    return;
  }

  if (!Array.isArray(items) || items.length === 0) {
    moodEl.textContent = '• MOOD: QUIET';
    moodEl.className = 'meta mood neutral';
    return;
  }

  const total = items.reduce((sum, item) => sum + (item.sentimentScore || 0), 0);
  const average = total / items.length;
  const descriptor = describeSentiment(average);

  moodEl.textContent = `• MOOD: ${descriptor.label}`;
  moodEl.className = `meta mood ${descriptor.tone}`;
}

function render() {
  const feedList = document.getElementById('feedList');
  const emptyMsg = document.getElementById('emptyMsg');
  updateSourceSummary();

  batchDOM(() => {
    feedList.innerHTML = '';
    let filtered = STATE.items.slice();

    if (STATE.sourceFilter) {
      filtered = filtered.filter(item => item.id === STATE.sourceFilter);
    }

    let viewItems;

    switch (STATE.view) {
      case 'popular':
        viewItems = filtered
          .slice()
          .sort((a, b) => b.trendingScore - a.trendingScore)
          .slice(0, 30);
        break;
      case 'conservative':
        viewItems = filtered.filter(item => item.lane === 'conservative');
        break;
      case 'populist':
        viewItems = filtered.filter(item => item.lane === 'populist');
        break;
      case 'breaking':
        viewItems = filtered.filter(item => item.isBreaking);
        break;
      case 'by-source':
        viewItems = filtered.slice();
        break;
      default:
        viewItems = filtered.slice(0, 60);
    }

    updateMoodIndicator(viewItems);
    const totalItems = viewItems.length;

    if (viewItems.length === 0) {
      emptyMsg.style.display = 'block';
      return;
    }

    emptyMsg.style.display = 'none';

    if (STATE.view === 'by-source') {
      const grouped = new Map();
      viewItems.forEach(item => {
        if (!grouped.has(item.source)) {
          grouped.set(item.source, []);
        }
        grouped.get(item.source).push(item);
      });

      const fragment = document.createDocumentFragment();
      let indexCounter = 0;
      Array.from(grouped.keys()).sort().forEach(sourceName => {
        const header = document.createElement('div');
        header.className = 'source-header';
        header.textContent = sourceName;
        fragment.appendChild(header);
        grouped.get(sourceName).forEach(article => {
          fragment.appendChild(createCard(article, indexCounter, totalItems));
          indexCounter += 1;
        });
      });

      feedList.appendChild(fragment);
      feedList.classList.add('spring-stagger');
      setTimeout(() => feedList.classList.remove('spring-stagger'), 650);
      return;
    }

    const fragment = document.createDocumentFragment();
    viewItems.forEach((item, idx) => {
      fragment.appendChild(createCard(item, idx, totalItems));
    });
    feedList.appendChild(fragment);
    feedList.classList.add('spring-stagger');
    setTimeout(() => feedList.classList.remove('spring-stagger'), 650);
  });
  syncActiveNav();
}

function updateSourceSummary() {
  const valueEl = document.getElementById('sourceFilterValue');
  const trigger = document.getElementById('sourceFilterButton');
  const navTrigger = document.getElementById('filterTrigger');
  const clearButton = document.getElementById('clearSourceFilter');
  const selection = SOURCES.find(source => source.id === STATE.sourceFilter);

  if (valueEl) {
    valueEl.textContent = selection ? selection.name : 'All Sources';
  }

  if (trigger) {
    trigger.setAttribute('aria-label', selection ? `Current source ${selection.name}` : 'Current source All Sources');
    trigger.dataset.selectedSource = selection ? selection.id : '';
  }

  if (navTrigger) {
    navTrigger.classList.toggle('active', Boolean(selection));
  }

  if (clearButton) {
    clearButton.disabled = !selection;
  }
}

function buildSourceToggles() {
  const container = document.getElementById('sourceToggles');
  if (!container) {
    return;
  }

  container.innerHTML = '';
  const fragment = document.createDocumentFragment();

  const appendOption = (label, metaSegments, sourceId, isActive, onSelect) => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'source-option smooth';
    button.dataset.sourceId = sourceId || '';
    button.setAttribute('role', 'option');
    button.tabIndex = 0;
    button.setAttribute('aria-selected', String(isActive));
    const metaHTML = metaSegments.map(part => `<span>${escapeHTML(part)}</span>`).join('');
    button.innerHTML = `
      <span class="source-option__name">${escapeHTML(label)}</span>
      <span class="source-option__meta">${metaHTML}</span>
      <span class="source-option__check" aria-hidden="true">✓</span>
    `;
    button.addEventListener('click', () => {
      onSelect();
      buildSourceToggles();
      updateSourceSummary();
      render();
      triggerHaptic('tab');
      closeSourceSheet();
    });
    fragment.appendChild(button);
  };

  appendOption(
    'All Sources',
    ['All outlets'],
    '',
    !STATE.sourceFilter,
    () => {
      STATE.sourceFilter = null;
      persistState();
    }
  );

  SOURCES.forEach(source => {
    const isActive = STATE.sourceFilter === source.id;
    const laneLabel = source.lane ? source.lane.replace(/\b\w/g, char => char.toUpperCase()) : 'General';
    const biasLabel = Number.isFinite(source.bias)
      ? `Bias ${source.bias >= 0 ? '+' : ''}${source.bias.toFixed(1)}`
      : 'Bias N/A';

    appendOption(
      source.name,
      [laneLabel, biasLabel],
      source.id,
      isActive,
      () => {
        STATE.sourceFilter = source.id;
        persistState();
      }
    );
  });

  container.appendChild(fragment);
}

function initFilterNavigation() {
  const filters = document.getElementById('filters');
  const chips = filters.querySelectorAll('.chip');

  filters.addEventListener('keydown', event => {
    const current = document.activeElement;
    const currentIndex = Array.from(chips).indexOf(current);
    let nextIndex = currentIndex;

    switch (event.key) {
      case 'ArrowRight':
        nextIndex = (currentIndex + 1) % chips.length;
        break;
      case 'ArrowLeft':
        nextIndex = (currentIndex - 1 + chips.length) % chips.length;
        break;
      case 'Home':
        nextIndex = 0;
        break;
      case 'End':
        nextIndex = chips.length - 1;
        break;
      default:
        return;
    }

    event.preventDefault();
    chips[nextIndex].focus();
  });
}

function fmtTime(ts) {
  const date = new Date(ts);
  const diffSeconds = (Date.now() - date.getTime()) / 1000;
  if (diffSeconds < 60) {
    return 'NOW';
  }
  if (diffSeconds < 3600) {
    return `${Math.floor(diffSeconds / 60)}m`;
  }
  if (diffSeconds < 86400) {
    return `${Math.floor(diffSeconds / 3600)}h`;
  }
  return `${Math.floor(diffSeconds / 86400)}d`;
}

function toast(msg, type = 'info') {
  const el = document.createElement('div');
  el.className = `toast ${type} fade`;
  el.textContent = msg;
  el.setAttribute('role', 'alert');
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 2500);
  return el;
}

function escapeHTML(str = '') {
  if (typeof str !== 'string') {
    str = String(str || '');
  }
  return str.replace(/[&<>"']/g, char => ESCAPE_MAP[char]);
}

document.addEventListener('DOMContentLoaded', () => {
  buildSourceToggles();
  updateSourceSummary();
  initFilterNavigation();
  setupTabBar();
  setupActionSheet();
  setupFilterSheet();
  setupSourceSheet();
  setupPullToRefresh();
  syncActiveNav();

  const filters = document.getElementById('filters');
  filters.addEventListener('click', event => {
    const chip = event.target.closest('.chip');
    if (!chip) {
      return;
    }
    changeView(chip.dataset.view);
    closeFilterSheet();
  });

  setInterval(() => {
    if (!STATE.loading && Date.now() - STATE.lastFetch > 120000) {
      loadFeeds();
    }
  }, 30000);

  loadFeeds();
});
</script>
</body>
</html>
