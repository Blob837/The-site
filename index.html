<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="description" content="College Football Winner Predictor with live data and calibrated probabilities">
    <title>CFB Winner Predictor</title>
    
    <style>
        :root {
            --primary-bg: #ffffff;
            --secondary-bg: #f5f5f5;
            --card-bg: #ffffff;
            --text-primary: #000000;
            --text-secondary: #666666;
            --accent: #0066cc;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --border: #e0e0e0;
            --shadow: rgba(0,0,0,0.1);
        }
        
        @media (prefers-color-scheme: dark) {
            :root {
                --primary-bg: #1a1a1a;
                --secondary-bg: #2a2a2a;
                --card-bg: #333333;
                --text-primary: #ffffff;
                --text-secondary: #cccccc;
                --accent: #4da6ff;
                --border: #444444;
                --shadow: rgba(0,0,0,0.3);
            }
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.4;
            min-height: 100vh;
            padding-bottom: 80px;
        }
        
        .header {
            background: var(--secondary-bg);
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .week-picker {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            transition: opacity 0.2s;
        }
        
        .btn:hover:not(:disabled) {
            opacity: 0.8;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-sm {
            padding: 6px 10px;
            font-size: 12px;
            min-height: 36px;
            min-width: 36px;
        }
        
        .btn-secondary {
            background: var(--secondary-bg);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .week-display {
            font-size: 16px;
            font-weight: 500;
            min-width: 120px;
            text-align: center;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 16px;
        }
        
        .game-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 12px;
            padding: 16px;
            box-shadow: 0 2px 4px var(--shadow);
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }
        
        .teams {
            flex: 1;
        }
        
        .team-line {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            font-size: 16px;
            font-weight: 500;
        }
        
        .team-away {
            color: var(--text-secondary);
        }
        
        .probability-pill {
            background: var(--accent);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .venue-tags {
            display: flex;
            gap: 6px;
        }
        
        .tag {
            background: var(--secondary-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            text-transform: uppercase;
        }
        
        .drivers {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }
        
        .driver-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .chip {
            background: var(--secondary-bg);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .chip-positive {
            background: var(--success);
            color: white;
        }
        
        .chip-negative {
            background: var(--danger);
            color: white;
        }
        
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--secondary-bg);
            border-top: 1px solid var(--border);
            padding: 12px 16px;
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--card-bg);
            margin: 20px;
            padding: 20px;
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            min-height: 44px;
            min-width: 44px;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
        }
        
        .input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--primary-bg);
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox {
            width: 18px;
            height: 18px;
        }
        
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }
        
        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-banner {
            background: var(--danger);
            color: white;
            padding: 12px 16px;
            margin: 16px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        .skeleton {
            background: linear-gradient(90deg, var(--border) 25%, transparent 50%, var(--border) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .skeleton-card {
            height: 120px;
            border-radius: 12px;
            margin-bottom: 12px;
        }
        
        .demo-banner {
            background: var(--warning);
            color: var(--text-primary);
            padding: 8px 16px;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="demo-banner" class="demo-banner" style="display: none;">
        DEMO MODE - Using sample data. Configure API keys in Settings for live data.
    </div>
    
    <header class="header">
        <div class="header-row">
            <div class="title">CFB Predictor</div>
            <div class="week-picker">
                <button class="btn btn-sm btn-secondary" id="prev-week">‹</button>
                <div class="week-display" id="week-display">This Week</div>
                <button class="btn btn-sm btn-secondary" id="next-week">›</button>
                <button class="btn btn-sm" id="settings-btn">⚙</button>
            </div>
        </div>
    </header>
    
    <div class="container">
        <div id="error-container"></div>
        <div id="games-container">
            <div class="loading">
                <div class="spinner"></div>
                Loading games...
            </div>
        </div>
    </div>
    
    <div class="bottom-bar">
        <button class="btn btn-sm" id="refresh-btn">Refresh Data</button>
        <button class="btn btn-sm" id="predict-btn">Predict</button>
        <button class="btn btn-sm btn-secondary" id="export-btn">Export</button>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settings-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Settings</div>
                <button class="close" id="settings-close">&times;</button>
            </div>
            
            <div class="form-group">
                <label class="label" for="cfbd-key">CFBD API Key</label>
                <input type="password" class="input" id="cfbd-key" placeholder="Enter your CFBD API key">
                <small style="color: var(--text-secondary); font-size: 12px;">
                    Get your free key at <a href="https://collegefootballdata.com/" target="_blank" style="color: var(--accent);">collegefootballdata.com</a>
                </small>
            </div>
            
            <div class="form-group">
                <div class="checkbox-group">
                    <input type="checkbox" class="checkbox" id="use-markets" checked>
                    <label class="label" for="use-markets">Use betting markets (optional)</label>
                </div>
            </div>
            
            <div class="form-group">
                <div class="checkbox-group">
                    <input type="checkbox" class="checkbox" id="use-weather" checked>
                    <label class="label" for="use-weather">Use weather forecasts</label>
                </div>
            </div>
            
            <div class="form-group">
                <div class="checkbox-group">
                    <input type="checkbox" class="checkbox" id="demo-mode">
                    <label class="label" for="demo-mode">Demo mode (use sample data)</label>
                </div>
            </div>
            
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="btn btn-secondary" id="forget-keys">Forget Keys</button>
                <button class="btn" id="save-settings">Save Settings</button>
            </div>
        </div>
    </div>
    
    <script>
        // === CONFIGURATION ===
        const CONFIG = {
            CFBD_BASE_URL: 'https://api.collegefootballdata.com',
            WEATHER_BASE_URL: 'https://api.open-meteo.com/v1/forecast',
            CACHE_TTL: {
                METRICS: 24 * 60 * 60 * 1000, // 24 hours
                WEATHER: 6 * 60 * 60 * 1000,  // 6 hours  
                LINES: 2 * 60 * 60 * 1000,    // 2 hours
                GAMES: 12 * 60 * 60 * 1000    // 12 hours
            },
            RATE_LIMIT: {
                TOKENS: 10,
                REFILL_RATE: 1000, // 1 per second
                MAX_RETRIES: 3
            }
        };
        
        // === UTILITY FUNCTIONS ===
        
        // Simple date utilities
        const DateUtils = {
            now: () => new Date(),
            
            getWeekStart: (date) => {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Monday
                return new Date(d.setDate(diff));
            },
            
            getWeekend: (date) => {
                const start = DateUtils.getWeekStart(date);
                const friday = new Date(start);
                friday.setDate(start.getDate() + 4);
                const sunday = new Date(start);
                sunday.setDate(start.getDate() + 6);
                return { friday, sunday };
            },
            
            addWeeks: (date, weeks) => {
                const d = new Date(date);
                d.setDate(d.getDate() + weeks * 7);
                return d;
            },
            
            formatDate: (date) => {
                return date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric' 
                });
            },
            
            formatTime: (date) => {
                return date.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
            }
        };
        
        // Math utilities
        const MathUtils = {
            sigmoid: (x) => 1 / (1 + Math.exp(-x)),
            
            logit: (p) => Math.log(p / (1 - p)),
            
            clamp: (value, min, max) => Math.max(min, Math.min(max, value)),
            
            mean: (arr) => arr.length ? arr.reduce((a, b) => a + b) / arr.length : 0,
            
            standardDev: (arr) => {
                const mean = MathUtils.mean(arr);
                const variance = MathUtils.mean(arr.map(x => (x - mean) ** 2));
                return Math.sqrt(variance);
            }
        };
        
        // Seeded random number generator
        class SeededRandom {
            constructor(seed = 12345) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }
        
        // Rate limiter
        class RateLimiter {
            constructor(tokens, refillRate) {
                this.tokens = tokens;
                this.maxTokens = tokens;
                this.refillRate = refillRate;
                this.lastRefill = Date.now();
            }
            
            async acquire() {
                const now = Date.now();
                const timePassed = now - this.lastRefill;
                const tokensToAdd = Math.floor(timePassed / this.refillRate);
                
                this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
                this.lastRefill = now;
                
                if (this.tokens > 0) {
                    this.tokens--;
                    return;
                }
                
                // Wait for next token
                await new Promise(resolve => setTimeout(resolve, this.refillRate));
                return this.acquire();
            }
        }
        
        // === CACHE LAYER ===
        
        class Cache {
            static get(key) {
                try {
                    const item = localStorage.getItem(`cfb_${key}`);
                    if (!item) return null;
                    
                    const parsed = JSON.parse(item);
                    if (Date.now() > parsed.expires) {
                        localStorage.removeItem(`cfb_${key}`);
                        return null;
                    }
                    
                    return parsed.data;
                } catch (e) {
                    return null;
                }
            }
            
            static set(key, data, ttl) {
                try {
                    const item = {
                        data,
                        expires: Date.now() + ttl
                    };
                    localStorage.setItem(`cfb_${key}`, JSON.stringify(item));
                } catch (e) {
                    console.warn('Cache write failed:', e);
                }
            }
            
            static clear() {
                const keys = Object.keys(localStorage);
                keys.filter(k => k.startsWith('cfb_')).forEach(k => {
                    localStorage.removeItem(k);
                });
            }
        }
        
        // === API CLIENTS ===
        
        class CFBDClient {
            constructor() {
                this.baseUrl = CONFIG.CFBD_BASE_URL;
                this.rateLimiter = new RateLimiter(CONFIG.RATE_LIMIT.TOKENS, CONFIG.RATE_LIMIT.REFILL_RATE);
            }
            
            async request(endpoint, params = {}) {
                await this.rateLimiter.acquire();
                
                const apiKey = AppState.getApiKey();
                if (!apiKey && !AppState.isDemoMode()) {
                    throw new Error('CFBD API key required');
                }
                
                const url = new URL(endpoint, this.baseUrl);
                Object.keys(params).forEach(key => {
                    if (params[key] != null) {
                        url.searchParams.append(key, params[key]);
                    }
                });
                
                const headers = {};
                if (apiKey) {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }
                
                let retries = 0;
                while (retries < CONFIG.RATE_LIMIT.MAX_RETRIES) {
                    try {
                        const response = await fetch(url, { headers });
                        
                        if (response.status === 401) {
                            throw new Error('CFBD 401: Invalid API key');
                        }
                        
                        if (response.status === 429) {
                            const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            retries++;
                            continue;
                        }
                        
                        if (!response.ok) {
                            throw new Error(`CFBD ${response.status}: ${response.statusText}`);
                        }
                        
                        return await response.json();
                    } catch (error) {
                        if (retries === CONFIG.RATE_LIMIT.MAX_RETRIES - 1) {
                            throw error;
                        }
                        retries++;
                        await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                    }
                }
            }
            
            async getGames(year, week) {
                const cacheKey = `games_${year}_${week}`;
                let games = Cache.get(cacheKey);
                
                if (!games) {
                    games = await this.request('/games', { year, week, seasonType: 'regular' });
                    Cache.set(cacheKey, games, CONFIG.CACHE_TTL.GAMES);
                }
                
                return games;
            }
            
            async getTeamMetrics(year) {
                const cacheKey = `metrics_${year}`;
                let metrics = Cache.get(cacheKey);
                
                if (!metrics) {
                    const [ppa, elo] = await Promise.all([
                        this.request('/ppa/teams', { year }).catch(() => []),
                        this.request('/ratings/elo', { year }).catch(() => [])
                    ]);
                    
                    metrics = { ppa, elo };
                    Cache.set(cacheKey, metrics, CONFIG.CACHE_TTL.METRICS);
                }
                
                return metrics;
            }
            
            async getLines(year, week) {
                if (!AppState.getSettings().useMarkets) return [];
                
                const cacheKey = `lines_${year}_${week}`;
                let lines = Cache.get(cacheKey);
                
                if (!lines) {
                    lines = await this.request('/lines', { year, week }).catch(() => []);
                    Cache.set(cacheKey, lines, CONFIG.CACHE_TTL.LINES);
                }
                
                return lines;
            }
            
            async getVenues() {
                const cacheKey = 'venues';
                let venues = Cache.get(cacheKey);
                
                if (!venues) {
                    venues = await this.request('/venues').catch(() => []);
                    Cache.set(cacheKey, venues, CONFIG.CACHE_TTL.METRICS);
                }
                
                return venues;
            }
        }
        
        class WeatherClient {
            constructor() {
                this.baseUrl = CONFIG.WEATHER_BASE_URL;
            }
            
            async getForecast(lat, lon, datetime) {
                if (!AppState.getSettings().useWeather) return null;
                
                const date = new Date(datetime);
                const dateStr = date.toISOString().split('T')[0];
                const hour = date.getHours();
                
                const cacheKey = `weather_${lat}_${lon}_${dateStr}_${hour}`;
                let forecast = Cache.get(cacheKey);
                
                if (!forecast) {
                    try {
                        const params = {
                            latitude: lat,
                            longitude: lon,
                            hourly: 'temperature_2m,precipitation,wind_speed_10m,wind_gusts_10m,precipitation_probability',
                            start_date: dateStr,
                            end_date: dateStr,
                            timezone: 'auto'
                        };
                        
                        const url = new URL(this.baseUrl);
                        Object.keys(params).forEach(key => {
                            url.searchParams.append(key, params[key]);
                        });
                        
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`Weather API ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        // Find closest hour
                        const hourly = data.hourly;
                        let closestIndex = 0;
                        let minDiff = Infinity;
                        
                        hourly.time.forEach((time, index) => {
                            const forecastHour = new Date(time).getHours();
                            const diff = Math.abs(forecastHour - hour);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestIndex = index;
                            }
                        });
                        
                        forecast = {
                            temperature: hourly.temperature_2m[closestIndex] || 20,
                            precipitation: hourly.precipitation[closestIndex] || 0,
                            wind_speed: hourly.wind_speed_10m[closestIndex] || 0,
                            wind_gusts: hourly.wind_gusts_10m[closestIndex] || 0,
                            precipitation_probability: hourly.precipitation_probability[closestIndex] || 0
                        };
                        
                        Cache.set(cacheKey, forecast, CONFIG.CACHE_TTL.WEATHER);
                    } catch (error) {
                        console.warn('Weather fetch failed:', error);
                        forecast = null;
                    }
                }
                
                return forecast;
            }
        }
        
        // === DATA MODELS ===
        
        class FeatureEngineering {
            static buildGameFeatures(game, homeMetrics, awayMetrics, weather = null, lines = null) {
                const features = {
                    game_id: game.id,
                    home_team: game.home_team,
                    away_team: game.away_team,
                    date: game.start_date,
                    neutral_site: game.neutral_site
                };
                
                // ELO differential
                const homeElo = homeMetrics?.elo || 1200;
                const awayElo = awayMetrics?.elo || 1200;
                const homeAdvantage = game.neutral_site ? 0 : 45;
                features.elo_diff = homeElo + homeAdvantage - awayElo;
                
                // PPA features
                const homePPA = homeMetrics?.ppa || { offense: 0, defense: 0 };
                const awayPPA = awayMetrics?.ppa || { offense: 0, defense: 0 };
                features.net_ppa_off = homePPA.offense - awayPPA.defense;
                features.net_ppa_def = homePPA.defense - awayPPA.offense;
                
                // Weather adjustments
                if (weather) {
                    features.weather_wind = weather.wind_speed || 0;
                    features.weather_precip = weather.precipitation_probability > 50 ? 1 : 0;
                } else {
                    features.weather_wind = 0;
                    features.weather_precip = 0;
                }
                
                // Market features
                if (lines && lines.length > 0) {
                    const line = lines[0];
                    features.market_spread = line.spread || 0;
                } else {
                    features.market_spread = 0;
                }
                
                return features;
            }
            
            static applyWeatherAdjustments(features) {
                const windMph = features.weather_wind || 0;
                const hasPrecip = features.weather_precip || 0;
                
                // Reduce passing efficiency in wind/rain
                const windPenalty = -0.01 * Math.max(0, windMph - 12);
                const precipPenalty = -0.05 * hasPrecip;
                
                features.weather_adjustment = windPenalty + precipPenalty;
                return features;
            }
        }
        
        // Simple logistic regression
        class LogisticRegression {
            constructor(alpha = 0.01) {
                this.alpha = alpha; // L2 regularization
                this.weights = null;
                this.intercept = 0;
            }
            
            fit(X, y, maxIter = 100) {
                if (X.length === 0) return this;
                
                const nFeatures = X[0].length;
                this.weights = new Array(nFeatures).fill(0);
                this.intercept = 0;
                
                const learningRate = 0.01;
                
                for (let iter = 0; iter < maxIter; iter++) {
                    let gradWeights = new Array(nFeatures).fill(0);
                    let gradIntercept = 0;
                    
                    for (let i = 0; i < X.length; i++) {
                        const prediction = this.predictProba([X[i]])[0];
                        const error = prediction - y[i];
                        
                        for (let j = 0; j < nFeatures; j++) {
                            gradWeights[j] += error * X[i][j] + this.alpha * this.weights[j];
                        }
                        gradIntercept += error;
                    }
                    
                    // Update weights
                    for (let j = 0; j < nFeatures; j++) {
                        this.weights[j] -= learningRate * gradWeights[j] / X.length;
                    }
                    this.intercept -= learningRate * gradIntercept / X.length;
                }
                
                return this;
            }
            
            predictProba(X) {
                if (!this.weights) return X.map(() => 0.5);
                
                return X.map(row => {
                    let logit = this.intercept;
                    for (let i = 0; i < row.length; i++) {
                        logit += this.weights[i] * row[i];
                    }
                    return MathUtils.sigmoid(logit);
                });
            }
        }
        
        // Simple calibration using Platt scaling
        class PlattCalibration {
            constructor() {
                this.a = 1;
                this.b = 0;
            }
            
            fit(predictions, trueLabels) {
                if (predictions.length < 3) return this;
                
                // Simple optimization for Platt scaling parameters
                let bestA = 1, bestB = 0, bestLoss = Infinity;
                
                for (let a = 0.1; a <= 3; a += 0.1) {
                    for (let b = -2; b <= 2; b += 0.1) {
                        let loss = 0;
                        for (let i = 0; i < predictions.length; i++) {
                            const calibrated = MathUtils.sigmoid(a * MathUtils.logit(predictions[i]) + b);
                            const clampedCalibrated = MathUtils.clamp(calibrated, 0.001, 0.999);
                            loss -= trueLabels[i] * Math.log(clampedCalibrated) + 
                                   (1 - trueLabels[i]) * Math.log(1 - clampedCalibrated);
                        }
                        
                        if (loss < bestLoss) {
                            bestLoss = loss;
                            bestA = a;
                            bestB = b;
                        }
                    }
                }
                
                this.a = bestA;
                this.b = bestB;
                return this;
            }
            
            transform(predictions) {
                return predictions.map(p => {
                    const clampedP = MathUtils.clamp(p, 0.001, 0.999);
                    return MathUtils.sigmoid(this.a * MathUtils.logit(clampedP) + this.b);
                });
            }
        }
        
        // === PREDICTION MODEL ===
        
        class CFBPredictor {
            constructor() {
                this.eloModel = new LogisticRegression(0.001);
                this.advancedModel = new LogisticRegression(0.01);
                this.metaModel = new LogisticRegression(0.001);
                this.calibrator = new PlattCalibration();
                this.isFitted = false;
                this.featureNames = ['elo_diff', 'net_ppa_off', 'net_ppa_def', 'weather_adjustment', 'market_spread'];
            }
            
            async fit(historicalGames, metrics, weather = []) {
                if (historicalGames.length < 10) {
                    console.warn('Insufficient training data');
                    return this;
                }
                
                // Build training features
                const features = [];
                const labels = [];
                
                for (const game of historicalGames) {
                    if (!game.home_points != null || !game.away_points != null) continue;
                    
                    const homeWon = game.home_points > game.away_points ? 1 : 0;
                    const homeMetrics = metrics.find(m => m.team === game.home_team);
                    const awayMetrics = metrics.find(m => m.team === game.away_team);
                    
                    if (!homeMetrics || !awayMetrics) continue;
                    
                    const gameFeatures = FeatureEngineering.buildGameFeatures(
                        game, homeMetrics, awayMetrics, null, null
                    );
                    
                    features.push([
                        gameFeatures.elo_diff,
                        gameFeatures.net_ppa_off,
                        gameFeatures.net_ppa_def,
                        gameFeatures.weather_adjustment || 0,
                        gameFeatures.market_spread || 0
                    ]);
                    labels.push(homeWon);
                }
                
                if (features.length < 5) {
                    console.warn('Insufficient valid training samples');
                    return this;
                }
                
                // Fit models
                this.eloModel.fit(features.map(f => [f[0]]), labels);
                this.advancedModel.fit(features, labels);
                
                // Meta-model: stack predictions
                const eloPreds = this.eloModel.predictProba(features.map(f => [f[0]]));
                const advPreds = this.advancedModel.predictProba(features);
                const metaFeatures = features.map((_, i) => [eloPreds[i], advPreds[i]]);
                
                this.metaModel.fit(metaFeatures, labels);
                
                // Calibration
                const metaPreds = this.metaModel.predictProba(metaFeatures);
                this.calibrator.fit(metaPreds, labels);
                
                this.isFitted = true;
                return this;
            }
            
            predict(gameFeatures) {
                if (!this.isFitted) {
                    return { probability: 0.5, confidence: 0, drivers: [] };
                }
                
                const features = [
                    gameFeatures.elo_diff || 0,
                    gameFeatures.net_ppa_off || 0,
                    gameFeatures.net_ppa_def || 0,
                    gameFeatures.weather_adjustment || 0,
                    gameFeatures.market_spread || 0
                ];
                
                const eloProb = this.eloModel.predictProba([features.slice(0, 1)])[0];
                const advProb = this.advancedModel.predictProba([features])[0];
                const metaProb = this.metaModel.predictProba([[eloProb, advProb]])[0];
                const calibratedProb = this.calibrator.transform([metaProb])[0];
                
                // Calculate drivers
                const drivers = this.calculateDrivers(features, gameFeatures);
                
                // Confidence based on distance from 0.5
                const confidence = Math.abs(calibratedProb - 0.5) * 2;
                
                return {
                    probability: MathUtils.clamp(calibratedProb, 0.01, 0.99),
                    confidence: MathUtils.clamp(confidence, 0, 1),
                    drivers
                };
            }
            
            calculateDrivers(features, gameFeatures) {
                const drivers = [];
                
                if (Math.abs(features[0]) > 50) {
                    drivers.push({
                        name: 'ELO',
                        impact: features[0] > 0 ? 'positive' : 'negative',
                        strength: Math.min(Math.abs(features[0]) / 100, 1)
                    });
                }
                
                if (Math.abs(features[1]) > 0.1) {
                    drivers.push({
                        name: 'Offense',
                        impact: features[1] > 0 ? 'positive' : 'negative',
                        strength: Math.min(Math.abs(features[1]) * 2, 1)
                    });
                }
                
                if (Math.abs(features[2]) > 0.1) {
                    drivers.push({
                        name: 'Defense',
                        impact: features[2] > 0 ? 'positive' : 'negative',
                        strength: Math.min(Math.abs(features[2]) * 2, 1)
                    });
                }
                
                if (features[3] < -0.02) {
                    drivers.push({
                        name: 'Weather',
                        impact: 'negative',
                        strength: Math.min(Math.abs(features[3]) * 10, 1)
                    });
                }
                
                return drivers.slice(0, 3); // Top 3 drivers
            }
        }
        
        // === APPLICATION STATE ===
        
        class AppState {
            static state = {
                currentWeek: DateUtils.now(),
                games: [],
                predictions: [],
                isLoading: false,
                error: null,
                settings: {
                    cfbdKey: '',
                    useMarkets: true,
                    useWeather: true,
                    demoMode: false
                }
            };
            
            static listeners = [];
            
            static subscribe(listener) {
                this.listeners.push(listener);
                return () => {
                    this.listeners = this.listeners.filter(l => l !== listener);
                };
            }
            
            static notify() {
                this.listeners.forEach(listener => listener(this.state));
            }
            
            static setState(updates) {
                this.state = { ...this.state, ...updates };
                this.notify();
            }
            
            static loadSettings() {
                try {
                    const stored = localStorage.getItem('cfb_settings');
                    if (stored) {
                        this.state.settings = { ...this.state.settings, ...JSON.parse(stored) };
                    }
                } catch (e) {
                    console.warn('Failed to load settings:', e);
                }
            }
            
            static saveSettings(settings) {
                this.state.settings = { ...this.state.settings, ...settings };
                try {
                    localStorage.setItem('cfb_settings', JSON.stringify(this.state.settings));
                } catch (e) {
                    console.warn('Failed to save settings:', e);
                }
                this.notify();
            }
            
            static getSettings() {
                return this.state.settings;
            }
            
            static getApiKey() {
                return this.state.settings.cfbdKey;
            }
            
            static isDemoMode() {
                return this.state.settings.demoMode;
            }
            
            static clearKeys() {
                this.saveSettings({ cfbdKey: '' });
                Cache.clear();
            }
        }
        
        // === DATA SERVICE ===
        
        class DataService {
            constructor() {
                this.cfbdClient = new CFBDClient();
                this.weatherClient = new WeatherClient();
                this.predictor = new CFBPredictor();
                this.venues = new Map();
            }
            
            async initialize() {
                try {
                    if (!AppState.isDemoMode()) {
                        const venueData = await this.cfbdClient.getVenues();
                        venueData.forEach(venue => {
                            this.venues.set(venue.name, {
                                lat: venue.latitude,
                                lon: venue.longitude,
                                dome: venue.dome,
                                grass: venue.grass
                            });
                        });
                    }
                } catch (error) {
                    console.warn('Failed to load venues:', error);
                }
            }
            
            async loadWeekGames(date) {
                if (AppState.isDemoMode()) {
                    return this.getDemoGames();
                }
                
                const year = date.getFullYear();
                const week = this.getCollegeWeek(date);
                
                try {
                    const games = await this.cfbdClient.getGames(year, week);
                    const weekStart = DateUtils.getWeekStart(date);
                    weekStart.setHours(0, 0, 0, 0);
                    const weekEnd = DateUtils.addWeeks(weekStart, 1);
                    weekEnd.setHours(0, 0, 0, 0);

                    return games
                        .filter(game => {
                            if (!game.start_date) return false;

                            const gameDate = new Date(game.start_date);
                            return gameDate >= weekStart && gameDate < weekEnd;
                        })
                        .sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
                } catch (error) {
                    throw new Error(`Failed to load games: ${error.message}`);
                }
            }
            
            async loadTeamMetrics(year) {
                if (AppState.isDemoMode()) {
                    return this.getDemoMetrics();
                }
                
                try {
                    const metrics = await this.cfbdClient.getTeamMetrics(year);
                    
                    // Combine PPA and ELO data
                    const combined = new Map();
                    
                    metrics.ppa.forEach(team => {
                        combined.set(team.team, {
                            team: team.team,
                            ppa: {
                                offense: team.offense?.overall || 0,
                                defense: team.defense?.overall || 0
                            }
                        });
                    });
                    
                    metrics.elo.forEach(rating => {
                        const existing = combined.get(rating.team) || { team: rating.team, ppa: { offense: 0, defense: 0 } };
                        existing.elo = rating.elo;
                        combined.set(rating.team, existing);
                    });
                    
                    return Array.from(combined.values());
                } catch (error) {
                    throw new Error(`Failed to load team metrics: ${error.message}`);
                }
            }
            
            async predictGames(games) {
                AppState.setState({ isLoading: true, error: null });
                
                try {
                    const year = new Date().getFullYear();
                    
                    // Load training data and metrics
                    const [metrics, historicalGames] = await Promise.all([
                        this.loadTeamMetrics(year),
                        this.loadHistoricalGames(year)
                    ]);
                    
                    // Train the model
                    await this.predictor.fit(historicalGames, metrics);
                    
                    // Generate predictions
                    const predictions = [];
                    
                    for (const game of games) {
                        const homeMetrics = metrics.find(m => m.team === game.home_team);
                        const awayMetrics = metrics.find(m => m.team === game.away_team);
                        
                        if (!homeMetrics || !awayMetrics) {
                            predictions.push({
                                game_id: game.id,
                                probability: 0.5,
                                confidence: 0,
                                drivers: [],
                                error: 'Missing team metrics'
                            });
                            continue;
                        }
                        
                        // Get weather if enabled
                        let weather = null;
                        if (AppState.getSettings().useWeather && game.venue) {
                            const venue = this.venues.get(game.venue);
                            if (venue && !venue.dome) {
                                try {
                                    weather = await this.weatherClient.getForecast(
                                        venue.lat, venue.lon, game.start_date
                                    );
                                } catch (e) {
                                    console.warn('Weather fetch failed for', game.venue);
                                }
                            }
                        }
                        
                        // Build features
                        const features = FeatureEngineering.buildGameFeatures(
                            game, homeMetrics, awayMetrics, weather
                        );
                        FeatureEngineering.applyWeatherAdjustments(features);
                        
                        // Predict
                        const prediction = this.predictor.predict(features);
                        
                        predictions.push({
                            game_id: game.id,
                            game,
                            probability: prediction.probability,
                            confidence: prediction.confidence,
                            drivers: prediction.drivers,
                            features
                        });
                    }
                    
                    AppState.setState({ predictions, isLoading: false });
                    return predictions;
                    
                } catch (error) {
                    AppState.setState({ isLoading: false, error: error.message });
                    throw error;
                }
            }
            
            async loadHistoricalGames(year) {
                if (AppState.isDemoMode()) {
                    return this.getDemoHistoricalGames();
                }
                
                try {
                    // Load completed games from current season
                    const allGames = [];
                    const currentWeek = this.getCollegeWeek(DateUtils.now());
                    
                    for (let week = 1; week < currentWeek; week++) {
                        try {
                            const weekGames = await this.cfbdClient.getGames(year, week);
                            const completedGames = weekGames.filter(g => 
                                g.home_points != null && g.away_points != null
                            );
                            allGames.push(...completedGames);
                            
                            if (allGames.length > 500) break; // Limit for performance
                        } catch (e) {
                            console.warn(`Failed to load week ${week}:`, e);
                        }
                    }
                    
                    return allGames;
                } catch (error) {
                    console.warn('Failed to load historical games:', error);
                    return [];
                }
            }
            
            getCollegeWeek(date) {
                // Simple approximation - week 1 typically starts around Aug 26
                const seasonStart = new Date(date.getFullYear(), 7, 26); // Aug 26
                const diffTime = date - seasonStart;
                const diffWeeks = Math.ceil(diffTime / (1000 * 60 * 60 * 24 * 7));
                return Math.max(1, diffWeeks);
            }
            
            // Demo data for when APIs are unavailable
            getDemoGames() {
                return [
                    {
                        id: 1,
                        home_team: 'Georgia',
                        away_team: 'Alabama',
                        start_date: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString(),
                        venue: 'Sanford Stadium',
                        neutral_site: false
                    },
                    {
                        id: 2,
                        home_team: 'Ohio State',
                        away_team: 'Michigan',
                        start_date: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(),
                        venue: 'Ohio Stadium',
                        neutral_site: false
                    },
                    {
                        id: 3,
                        home_team: 'Texas',
                        away_team: 'Oklahoma',
                        start_date: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),
                        venue: 'Cotton Bowl',
                        neutral_site: true
                    }
                ];
            }
            
            getDemoMetrics() {
                return [
                    { team: 'Georgia', ppa: { offense: 0.25, defense: -0.18 }, elo: 1650 },
                    { team: 'Alabama', ppa: { offense: 0.22, defense: -0.15 }, elo: 1645 },
                    { team: 'Ohio State', ppa: { offense: 0.28, defense: -0.20 }, elo: 1660 },
                    { team: 'Michigan', ppa: { offense: 0.15, defense: -0.12 }, elo: 1580 },
                    { team: 'Texas', ppa: { offense: 0.20, defense: -0.16 }, elo: 1620 },
                    { team: 'Oklahoma', ppa: { offense: 0.18, defense: -0.10 }, elo: 1590 }
                ];
            }
            
            getDemoHistoricalGames() {
                return [
                    { home_team: 'Georgia', away_team: 'Auburn', home_points: 31, away_points: 13 },
                    { home_team: 'Alabama', away_team: 'LSU', home_points: 42, away_points: 21 },
                    { home_team: 'Ohio State', away_team: 'Penn State', home_points: 28, away_points: 17 }
                ];
            }
        }
        
        // === UI CONTROLLER ===
        
        class UIController {
            constructor() {
                this.dataService = new DataService();
                this.initializeElements();
                this.attachEventListeners();
                this.loadInitialData();
            }
            
            initializeElements() {
                this.elements = {
                    weekDisplay: document.getElementById('week-display'),
                    prevWeekBtn: document.getElementById('prev-week'),
                    nextWeekBtn: document.getElementById('next-week'),
                    settingsBtn: document.getElementById('settings-btn'),
                    settingsModal: document.getElementById('settings-modal'),
                    settingsClose: document.getElementById('settings-close'),
                    gamesContainer: document.getElementById('games-container'),
                    errorContainer: document.getElementById('error-container'),
                    refreshBtn: document.getElementById('refresh-btn'),
                    predictBtn: document.getElementById('predict-btn'),
                    exportBtn: document.getElementById('export-btn'),
                    cfbdKeyInput: document.getElementById('cfbd-key'),
                    useMarketsCheck: document.getElementById('use-markets'),
                    useWeatherCheck: document.getElementById('use-weather'),
                    demoModeCheck: document.getElementById('demo-mode'),
                    saveSettingsBtn: document.getElementById('save-settings'),
                    forgetKeysBtn: document.getElementById('forget-keys'),
                    demoBanner: document.getElementById('demo-banner')
                };
            }
            
            attachEventListeners() {
                // Week navigation
                this.elements.prevWeekBtn.addEventListener('click', () => this.changeWeek(-1));
                this.elements.nextWeekBtn.addEventListener('click', () => this.changeWeek(1));
                
                // Settings modal
                this.elements.settingsBtn.addEventListener('click', () => this.showSettings());
                this.elements.settingsClose.addEventListener('click', () => this.hideSettings());
                this.elements.settingsModal.addEventListener('click', (e) => {
                    if (e.target === this.elements.settingsModal) this.hideSettings();
                });
                
                // Settings actions
                this.elements.saveSettingsBtn.addEventListener('click', () => this.saveSettings());
                this.elements.forgetKeysBtn.addEventListener('click', () => this.forgetKeys());
                
                // Bottom bar actions
                this.elements.refreshBtn.addEventListener('click', () => this.refreshData());
                this.elements.predictBtn.addEventListener('click', () => this.runPredictions());
                this.elements.exportBtn.addEventListener('click', () => this.exportData());
                
                // State changes
                AppState.subscribe((state) => this.updateUI(state));
            }
            
            async loadInitialData() {
                AppState.loadSettings();
                await this.dataService.initialize();
                this.updateWeekDisplay();
                this.updateSettingsUI();
                await this.loadCurrentWeekGames();
            }
            
            updateUI(state) {
                this.updateWeekDisplay();
                this.renderGames(state.games, state.predictions);
                this.renderErrors(state.error);
                this.updateLoadingState(state.isLoading);
                this.updateDemoBanner(state.settings.demoMode);
            }
            
            updateWeekDisplay() {
                const { friday, sunday } = DateUtils.getWeekend(AppState.state.currentWeek);
                this.elements.weekDisplay.textContent = 
                    `${DateUtils.formatDate(friday)} - ${DateUtils.formatDate(sunday)}`;
            }
            
            updateDemoBanner(demoMode) {
                this.elements.demoBanner.style.display = demoMode ? 'block' : 'none';
            }
            
            async changeWeek(direction) {
                const newWeek = DateUtils.addWeeks(AppState.state.currentWeek, direction);
                AppState.setState({ currentWeek: newWeek, predictions: [] });
                await this.loadCurrentWeekGames();
            }
            
            async loadCurrentWeekGames() {
                AppState.setState({ isLoading: true, error: null });
                
                try {
                    const games = await this.dataService.loadWeekGames(AppState.state.currentWeek);
                    AppState.setState({ games, isLoading: false });
                } catch (error) {
                    AppState.setState({ isLoading: false, error: error.message });
                }
            }
            
            async runPredictions() {
                if (AppState.state.games.length === 0) {
                    AppState.setState({ error: 'No games loaded' });
                    return;
                }
                
                try {
                    await this.dataService.predictGames(AppState.state.games);
                } catch (error) {
                    AppState.setState({ error: error.message });
                }
            }
            
            async refreshData() {
                Cache.clear();
                await this.loadCurrentWeekGames();
            }
            
            renderGames(games, predictions) {
                if (!games || games.length === 0) {
                    this.elements.gamesContainer.innerHTML = `
                        <div class="empty-state">
                            <div style="font-size: 48px; margin-bottom: 16px;">🏈</div>
                            <div style="font-size: 18px; margin-bottom: 8px;">No games this week</div>
                            <div style="font-size: 14px;">Try selecting a different week</div>
                        </div>
                    `;
                    return;
                }
                
                const html = games.map(game => {
                    const prediction = predictions.find(p => p.game_id === game.id);
                    return this.renderGameCard(game, prediction);
                }).join('');
                
                this.elements.gamesContainer.innerHTML = html;
            }
            
            renderGameCard(game, prediction) {
                const gameDate = new Date(game.start_date);
                const homeProb = prediction ? Math.round(prediction.probability * 100) : 50;
                const awayProb = 100 - homeProb;
                
                const driversHtml = prediction && prediction.drivers ? 
                    prediction.drivers.map(driver => 
                        `<span class="chip ${driver.impact === 'positive' ? 'chip-positive' : 'chip-negative'}">
                            ${driver.name}
                        </span>`
                    ).join('') : '';
                
                const venueTagsHtml = this.renderVenueTags(game);
                
                return `
                    <div class="game-card">
                        <div class="game-header">
                            <div class="teams">
                                <div class="team-line team-away">
                                    ${game.away_team} <span style="font-size: 12px; color: var(--text-secondary);">(${awayProb}%)</span>
                                </div>
                                <div class="team-line" style="font-weight: 600;">
                                    @ ${game.home_team}
                                </div>
                            </div>
                            <div class="probability-pill">
                                ${homeProb}%
                            </div>
                        </div>
                        <div class="game-info">
                            <div>
                                ${DateUtils.formatTime(gameDate)}<br>
                                <span style="font-size: 12px;">${game.venue || 'TBD'}</span>
                            </div>
                            <div class="venue-tags">
                                ${venueTagsHtml}
                            </div>
                        </div>
                        ${driversHtml ? `
                            <div class="drivers">
                                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                                    Key factors:
                                </div>
                                <div class="driver-chips">
                                    ${driversHtml}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            renderVenueTags(game) {
                const tags = [];
                
                if (game.neutral_site) {
                    tags.push('<span class="tag">NEUTRAL</span>');
                }
                
                const venue = this.dataService.venues.get(game.venue);
                if (venue) {
                    if (venue.dome) {
                        tags.push('<span class="tag">DOME</span>');
                    }
                    if (!venue.grass) {
                        tags.push('<span class="tag">TURF</span>');
                    }
                }
                
                return tags.join('');
            }
            
            renderErrors(error) {
                if (error) {
                    this.elements.errorContainer.innerHTML = `
                        <div class="error-banner">
                            ${error}
                        </div>
                    `;
                } else {
                    this.elements.errorContainer.innerHTML = '';
                }
            }
            
            updateLoadingState(isLoading) {
                if (isLoading) {
                    this.elements.gamesContainer.innerHTML = `
                        <div class="loading">
                            <div class="spinner"></div>
                            Processing predictions...
                        </div>
                    `;
                }
                
                this.elements.refreshBtn.disabled = isLoading;
                this.elements.predictBtn.disabled = isLoading;
            }
            
            showSettings() {
                this.updateSettingsUI();
                this.elements.settingsModal.classList.add('show');
            }
            
            hideSettings() {
                this.elements.settingsModal.classList.remove('show');
            }
            
            updateSettingsUI() {
                const settings = AppState.getSettings();
                this.elements.cfbdKeyInput.value = settings.cfbdKey || '';
                this.elements.useMarketsCheck.checked = settings.useMarkets;
                this.elements.useWeatherCheck.checked = settings.useWeather;
                this.elements.demoModeCheck.checked = settings.demoMode;
            }
            
            saveSettings() {
                const settings = {
                    cfbdKey: this.elements.cfbdKeyInput.value.trim(),
                    useMarkets: this.elements.useMarketsCheck.checked,
                    useWeather: this.elements.useWeatherCheck.checked,
                    demoMode: this.elements.demoModeCheck.checked
                };
                
                AppState.saveSettings(settings);
                this.hideSettings();
                
                // Reload data if demo mode changed
                if (settings.demoMode !== AppState.state.settings.demoMode) {
                    this.loadCurrentWeekGames();
                }
            }
            
            forgetKeys() {
                if (confirm('This will clear all stored API keys and cached data. Continue?')) {
                    AppState.clearKeys();
                    this.updateSettingsUI();
                    this.hideSettings();
                }
            }
            
            exportData() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    week: AppState.state.currentWeek,
                    games: AppState.state.games,
                    predictions: AppState.state.predictions,
                    settings: { ...AppState.getSettings(), cfbdKey: '' } // Don't export API key
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cfb-predictions-${DateUtils.formatDate(AppState.state.currentWeek)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }
        
        // === INITIALIZATION ===
        
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize the application
            window.cfbApp = new UIController();
        });
        
        // === WEB WORKER FOR HEAVY COMPUTATION ===
        
        // Create worker as blob URL for self-contained deployment
        const workerCode = `
            // Worker thread for heavy ML computations
            self.onmessage = function(e) {
                const { type, data } = e.data;
                
                try {
                    switch (type) {
                        case 'TRAIN_MODEL':
                            const result = trainModel(data);
                            self.postMessage({ type: 'TRAIN_COMPLETE', result });
                            break;
                            
                        case 'BATCH_PREDICT':
                            const predictions = batchPredict(data);
                            self.postMessage({ type: 'PREDICT_COMPLETE', predictions });
                            break;
                            
                        default:
                            throw new Error('Unknown worker task: ' + type);
                    }
                } catch (error) {
                    self.postMessage({ type: 'ERROR', error: error.message });
                }
            };
            
            function trainModel(data) {
                // Simplified training in worker
                const { features, labels } = data;
                
                if (features.length === 0) {
                    return { weights: [0, 0, 0, 0, 0], intercept: 0 };
                }
                
                // Simple gradient descent
                let weights = new Array(features[0].length).fill(0);
                let intercept = 0;
                const learningRate = 0.01;
                const iterations = 50;
                
                for (let iter = 0; iter < iterations; iter++) {
                    let gradWeights = new Array(weights.length).fill(0);
                    let gradIntercept = 0;
                    
                    for (let i = 0; i < features.length; i++) {
                        let prediction = intercept;
                        for (let j = 0; j < weights.length; j++) {
                            prediction += weights[j] * features[i][j];
                        }
                        prediction = 1 / (1 + Math.exp(-prediction));
                        
                        const error = prediction - labels[i];
                        
                        for (let j = 0; j < weights.length; j++) {
                            gradWeights[j] += error * features[i][j];
                        }
                        gradIntercept += error;
                    }
                    
                    for (let j = 0; j < weights.length; j++) {
                        weights[j] -= learningRate * gradWeights[j] / features.length;
                    }
                    intercept -= learningRate * gradIntercept / features.length;
                }
                
                return { weights, intercept };
            }
            
            function batchPredict(data) {
                const { features, model } = data;
                const predictions = [];
                
                for (const feature of features) {
                    let logit = model.intercept;
                    for (let i = 0; i < feature.length; i++) {
                        logit += model.weights[i] * feature[i];
                    }
                    const probability = 1 / (1 + Math.exp(-logit));
                    predictions.push(Math.max(0.01, Math.min(0.99, probability)));
                }
                
                return predictions;
            }
        `;
        
        // Create worker
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            URL.revokeObjectURL(workerUrl);
        });
        
        // === SERVICE WORKER FOR OFFLINE SUPPORT ===
        
        if ('serviceWorker' in navigator) {
            // Register minimal service worker for offline HTML cache
            const swCode = `
                const CACHE_NAME = 'cfb-predictor-v1';
                const urlsToCache = ['/'];
                
                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => cache.addAll(urlsToCache))
                    );
                });
                
                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => response || fetch(event.request))
                    );
                });
            `;
            
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            
            navigator.serviceWorker.register(swUrl).catch(err => {
                console.warn('ServiceWorker registration failed:', err);
            });
        }
        
        // === DEMO DATA CONSTANT ===
        
        const DEMO_DATASET = {
            games: [
                {
                    id: 401547420,
                    season: 2024,
                    week: 6,
                    home_team: "Georgia",
                    away_team: "Alabama", 
                    start_date: "2024-09-28T19:30:00.000Z",
                    venue: "Sanford Stadium",
                    neutral_site: false,
                    conference_game: true
                },
                {
                    id: 401547421,
                    season: 2024,
                    week: 6,
                    home_team: "Ohio State",
                    away_team: "Michigan",
                    start_date: "2024-09-28T16:00:00.000Z", 
                    venue: "Ohio Stadium",
                    neutral_site: false,
                    conference_game: true
                },
                {
                    id: 401547422,
                    season: 2024,
                    week: 6,
                    home_team: "Texas",
                    away_team: "Oklahoma",
                    start_date: "2024-09-28T15:30:00.000Z",
                    venue: "Cotton Bowl Stadium",
                    neutral_site: true,
                    conference_game: false
                },
                {
                    id: 401547423,
                    season: 2024,
                    week: 6,
                    home_team: "Oregon",
                    away_team: "Washington",
                    start_date: "2024-09-28T22:00:00.000Z",
                    venue: "Autzen Stadium", 
                    neutral_site: false,
                    conference_game: true
                },
                {
                    id: 401547424,
                    season: 2024,
                    week: 6,
                    home_team: "Clemson",
                    away_team: "Florida State",
                    start_date: "2024-09-28T20:00:00.000Z",
                    venue: "Memorial Stadium",
                    neutral_site: false,
                    conference_game: true
                }
            ],
            metrics: {
                ppa: [
                    { team: "Georgia", offense: { overall: 0.285 }, defense: { overall: -0.195 } },
                    { team: "Alabama", offense: { overall: 0.265 }, defense: { overall: -0.175 } },
                    { team: "Ohio State", offense: { overall: 0.315 }, defense: { overall: -0.225 } },
                    { team: "Michigan", offense: { overall: 0.185 }, defense: { overall: -0.155 } },
                    { team: "Texas", offense: { overall: 0.245 }, defense: { overall: -0.185 } },
                    { team: "Oklahoma", offense: { overall: 0.205 }, defense: { overall: -0.125 } },
                    { team: "Oregon", offense: { overall: 0.275 }, defense: { overall: -0.165 } },
                    { team: "Washington", offense: { overall: 0.165 }, defense: { overall: -0.105 } },
                    { team: "Clemson", offense: { overall: 0.195 }, defense: { overall: -0.145 } },
                    { team: "Florida State", offense: { overall: 0.155 }, defense: { overall: -0.095 } }
                ],
                elo: [
                    { team: "Georgia", elo: 1685 },
                    { team: "Alabama", elo: 1675 },
                    { team: "Ohio State", elo: 1695 },
                    { team: "Michigan", elo: 1615 },
                    { team: "Texas", elo: 1655 },
                    { team: "Oklahoma", elo: 1625 },
                    { team: "Oregon", elo: 1665 },
                    { team: "Washington", elo: 1585 },
                    { team: "Clemson", elo: 1635 },
                    { team: "Florida State", elo: 1595 }
                ]
            },
            historicalGames: [
                { home_team: "Georgia", away_team: "Auburn", home_points: 31, away_points: 13, week: 4 },
                { home_team: "Alabama", away_team: "LSU", home_points: 42, away_points: 21, week: 4 },
                { home_team: "Ohio State", away_team: "Penn State", home_points: 28, away_points: 17, week: 4 },
                { home_team: "Michigan", away_team: "Iowa", home_points: 24, away_points: 14, week: 4 },
                { home_team: "Texas", away_team: "TCU", home_points: 35, away_points: 28, week: 4 },
                { home_team: "Oklahoma", away_team: "Kansas", home_points: 38, away_points: 17, week: 4 },
                { home_team: "Oregon", away_team: "Stanford", home_points: 45, away_points: 21, week: 4 },
                { home_team: "Washington", away_team: "Arizona", home_points: 31, away_points: 24, week: 4 },
                { home_team: "Clemson", away_team: "NC State", home_points: 28, away_points: 21, week: 4 },
                { home_team: "Florida State", away_team: "Wake Forest", home_points: 35, away_points: 14, week: 4 }
            ],
            venues: [
                { name: "Sanford Stadium", latitude: 33.9496, longitude: -83.3732, dome: false, grass: true },
                { name: "Ohio Stadium", latitude: 40.0017, longitude: -83.0197, dome: false, grass: true },
                { name: "Cotton Bowl Stadium", latitude: 32.7828, longitude: -96.7594, dome: false, grass: true },
                { name: "Autzen Stadium", latitude: 44.0684, longitude: -123.0708, dome: false, grass: false },
                { name: "Memorial Stadium", latitude: 34.6776, longitude: -82.8374, dome: false, grass: true }
            ]
        };
        
        // Make demo data globally available
        window.DEMO_DATASET = DEMO_DATASET;
    </script>
</body>
</html>

<!--
README

# CFB Winner Predictor

A single-file mobile web app for predicting college football game winners using live data and machine learning.

## Features

- Mobile-first responsive design with dark mode support
- Live data from College Football Data API and weather services
- Machine learning predictions with ELO ratings, PPA metrics, and weather adjustments
- Offline-capable with localStorage caching
- Export predictions to JSON
- Demo mode for testing without API keys

## Getting Started

### 1. Get a CFBD API Key

1. Visit https://collegefootballdata.com/
2. Sign up for a free account
3. Generate an API key from your dashboard
4. Paste the key into the app's Settings panel

### 2. Deploy to GitHub Pages

1. Create a new GitHub repository
2. Upload this `index.html` file to the repository
3. Go to repository Settings > Pages
4. Set source to "Deploy from a branch" and select "main" branch
5. Your app will be available at `https://yourusername.github.io/repository-name`

### 3. Using Demo Mode

If you don't have API keys or want to test the interface:

1. Open Settings (gear icon)
2. Check "Demo mode (use sample data)"
3. Click "Save Settings"

The app will use built-in sample data to demonstrate all features.

## Usage

1. **Week Navigation**: Use arrow buttons to browse different weeks
2. **Settings**: Configure API keys and feature toggles
3. **Refresh Data**: Clear cache and reload fresh data  
4. **Predict**: Run machine learning predictions on loaded games
5. **Export**: Download predictions as JSON file

## Technical Details

- Pure vanilla JavaScript, HTML, and CSS
- No external dependencies or frameworks
- Web Workers for heavy ML computations
- Rate limiting and error handling for API calls
- Responsive design optimized for mobile devices
- Supports both light and dark themes

## Troubleshooting

- **401 Error**: Check your CFBD API key is correct
- **No Games**: Try a different week or check if it's off-season
- **Slow Performance**: Enable demo mode or clear browser cache
- **CORS Errors**: Use a different browser or enable demo mode

Built tough for production use. This thing won't break when the wind shifts.
-->
