<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <title>CFB Winner Predictor</title>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-card: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --accent-color: #007bff;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --border-color: #e0e0e0;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #1a1a1a;
                --bg-secondary: #2d2d2d;
                --bg-card: #2d2d2d;
                --text-primary: #ffffff;
                --text-secondary: #cccccc;
                --border-color: #404040;
                --shadow: 0 2px 4px rgba(255,255,255,0.1);
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            padding-bottom: 80px;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 16px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: var(--shadow);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        }

        .logo {
            font-size: 18px;
            font-weight: 600;
        }

        .week-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .week-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            min-height: 44px;
            min-width: 44px;
        }

        .week-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .settings-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 20px;
            cursor: pointer;
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 16px;
        }

        .game-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: var(--shadow);
            position: relative;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .game-time {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .venue-info {
            font-size: 10px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .team {
            text-align: center;
            flex: 1;
        }

        .team-name {
            font-weight: 600;
            font-size: 16px;
        }

        .team-record {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .vs {
            margin: 0 16px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .prediction {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .prob-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prob-pill {
            background: var(--accent-color);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .confidence-ring {
            width: 24px;
            height: 24px;
        }

        .edge-badge {
            background: var(--success-color);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .why-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            min-height: 32px;
        }

        .drivers {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            display: none;
        }

        .drivers.show {
            display: block;
        }

        .driver-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .driver-chip {
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        .driver-chip.positive {
            color: var(--success-color);
        }

        .driver-chip.negative {
            color: var(--danger-color);
        }

        .rationale {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-top: 1px solid var(--border-color);
            padding: 12px 16px;
            display: flex;
            justify-content: center;
            gap: 8px;
            box-shadow: var(--shadow);
        }

        .action-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            min-height: 44px;
            flex: 1;
            max-width: 120px;
        }

        .action-btn.secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            cursor: pointer;
            min-height: 44px;
            min-width: 44px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox {
            width: 18px;
            height: 18px;
        }

        .banner {
            background: var(--warning-color);
            color: white;
            padding: 12px 16px;
            text-align: center;
            font-size: 14px;
            display: none;
        }

        .banner.show {
            display: block;
        }

        .banner.error {
            background: var(--danger-color);
        }

        .banner.success {
            background: var(--success-color);
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .skeleton {
            background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--border-color) 50%, var(--bg-secondary) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 4px;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-card {
            height: 140px;
            margin-bottom: 12px;
            border-radius: 12px;
        }

        .sort-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .sort-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            min-height: 32px;
        }

        .sort-btn.active {
            background: var(--accent-color);
            color: white;
        }

        .demo-notice {
            background: var(--warning-color);
            color: white;
            padding: 8px 16px;
            text-align: center;
            font-size: 12px;
            margin-bottom: 16px;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div id="banner" class="banner"></div>
    
    <header class="header">
        <div class="header-content">
            <div class="logo">CFB Predictor</div>
            <div class="week-selector">
                <button id="prevWeek" class="week-btn">‹</button>
                <span id="currentWeek">This Week</span>
                <button id="nextWeek" class="week-btn">›</button>
            </div>
            <button id="settingsBtn" class="settings-btn">⚙</button>
        </div>
    </header>

    <main class="main-content">
        <div id="demoNotice" class="demo-notice" style="display: none;">
            Demo Mode: Using sample data. Configure API keys in settings for live predictions.
        </div>
        
        <div class="sort-controls">
            <button id="sortConfidence" class="sort-btn active">By Confidence</button>
            <button id="sortEdge" class="sort-btn">By Edge</button>
            <button id="sortTime" class="sort-btn">By Time</button>
        </div>

        <div id="gamesContainer">
            <div class="loading">
                <div class="spinner"></div>
            </div>
        </div>
    </main>

    <div class="bottom-bar">
        <button id="refreshBtn" class="action-btn">Refresh</button>
        <button id="predictBtn" class="action-btn">Predict</button>
        <button id="exportBtn" class="action-btn secondary">Export</button>
        <button id="resetBtn" class="action-btn secondary">Reset</button>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button id="closeSettings" class="close-btn">×</button>
            </div>
            
            <div class="form-group">
                <label class="form-label" for="cfbdKey">CFBD API Key</label>
                <input type="password" id="cfbdKey" class="form-input" placeholder="Enter your CollegeFootballData API key">
                <small style="color: var(--text-secondary); font-size: 12px;">
                    Get free key at <a href="https://collegefootballdata.com" target="_blank">collegefootballdata.com</a>
                </small>
            </div>

            <div class="form-group">
                <label class="form-label" for="oddsKey">TheOddsAPI Key (Optional)</label>
                <input type="password" id="oddsKey" class="form-input" placeholder="Optional: For betting markets">
            </div>

            <div class="form-group">
                <div class="form-checkbox">
                    <input type="checkbox" id="useMarkets" class="checkbox">
                    <label for="useMarkets">Use betting markets</label>
                </div>
            </div>

            <div class="form-group">
                <div class="form-checkbox">
                    <input type="checkbox" id="useWeather" class="checkbox" checked>
                    <label for="useWeather">Use weather forecasts</label>
                </div>
            </div>

            <div class="form-group">
                <div class="form-checkbox">
                    <input type="checkbox" id="demoMode" class="checkbox">
                    <label for="demoMode">Demo Mode (sample data)</label>
                </div>
            </div>

            <div class="form-group">
                <div class="form-checkbox">
                    <input type="checkbox" id="debugMode" class="checkbox">
                    <label for="debugMode">Debug Mode (show console logs)</label>
                </div>
            </div>

            <div class="form-group">
                <button id="testApi" class="action-btn secondary" style="width: 100%; margin-bottom: 8px;">Test API Connection</button>
                <button id="openConsole" class="action-btn secondary" style="width: 100%; margin-bottom: 8px;">Open Browser Console (F12)</button>
                <button id="forgetKeys" class="action-btn secondary" style="width: 100%;">Forget All Keys</button>
            </div>

            <div class="form-group">
                <button id="saveSettings" class="action-btn" style="width: 100%;">Save Settings</button>
            </div>
        </div>
    </div>

    <script>
        // === CONFIGURATION & CONSTANTS ===
        const CONFIG = {
            CFBD_BASE_URL: 'https://api.collegefootballdata.com',
            WEATHER_BASE_URL: 'https://api.open-meteo.com/v1/forecast',
            CACHE_TTL: {
                metrics: 24 * 60 * 60 * 1000, // 24h
                weather: 6 * 60 * 60 * 1000,  // 6h
                lines: 2 * 60 * 60 * 1000,    // 2h
                games: 1 * 60 * 60 * 1000     // 1h
            },
            RATE_LIMIT: {
                tokens: 3,
                refillRate: 1000,
                maxTokens: 3
            }
        };

        // Stadium coordinates lookup
        const STADIUM_COORDS = {
            'Alabama': [32.6149, -87.5500],
            'Auburn': [32.6099, -85.4808],
            'Georgia': [33.9495, -83.3735],
            'Florida': [29.6516, -82.3248],
            'LSU': [30.4118, -91.1838],
            'Tennessee': [35.9551, -83.9250],
            'Arkansas': [36.0686, -94.1574],
            'Mississippi State': [33.4596, -88.7955],
            'Ole Miss': [34.3649, -89.5348],
            'Kentucky': [38.0226, -84.5041],
            'Missouri': [38.9359, -92.3399],
            'South Carolina': [34.0192, -81.0350],
            'Texas A&M': [30.6280, -96.3344],
            'Vanderbilt': [36.1447, -86.8027],
            // Add more as needed...
        };

        // === UTILITY FUNCTIONS ===
        class MathUtils {
            static sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            static logit(p) {
                p = Math.max(0.001, Math.min(0.999, p));
                return Math.log(p / (1 - p));
            }

            static dotProduct(a, b) {
                return a.reduce((sum, val, i) => sum + val * b[i], 0);
            }

            static mean(arr) {
                return arr.reduce((sum, val) => sum + val, 0) / arr.length;
            }

            static std(arr) {
                const m = this.mean(arr);
                const variance = arr.reduce((sum, val) => sum + Math.pow(val - m, 2), 0) / arr.length;
                return Math.sqrt(variance);
            }
        }

        class TimeUtils {
            static getWeekStart(date = new Date()) {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Monday
                return new Date(d.setDate(diff));
            }

            static getWeekEnd(date = new Date()) {
                const start = this.getWeekStart(date);
                return new Date(start.getTime() + 6 * 24 * 60 * 60 * 1000);
            }

            static formatGameTime(dateStr) {
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
            }

            static getCurrentSeason() {
                const now = new Date();
                const year = now.getFullYear();
                // College football season starts in August
                return now.getMonth() >= 7 ? year : year - 1;
            }

            static getCurrentWeek() {
                const now = new Date();
                const seasonStart = new Date(this.getCurrentSeason(), 7, 26); // Rough season start
                const weeksDiff = Math.floor((now - seasonStart) / (7 * 24 * 60 * 60 * 1000));
                return Math.max(1, Math.min(15, weeksDiff + 1));
            }
        }

        // === STORAGE MANAGER ===
        class StorageManager {
            static set(key, value, ttl = null) {
                const item = {
                    value: value,
                    timestamp: Date.now(),
                    ttl: ttl
                };
                localStorage.setItem(key, JSON.stringify(item));
            }

            static get(key) {
                const item = localStorage.getItem(key);
                if (!item) return null;

                try {
                    const parsed = JSON.parse(item);
                    if (parsed.ttl && Date.now() > parsed.timestamp + parsed.ttl) {
                        localStorage.removeItem(key);
                        return null;
                    }
                    return parsed.value;
                } catch (e) {
                    localStorage.removeItem(key);
                    return null;
                }
            }

            static remove(key) {
                localStorage.removeItem(key);
            }

            static clear() {
                localStorage.clear();
            }
        }

        // === RATE LIMITER ===
        class RateLimiter {
            constructor(tokensPerSecond = 1, maxTokens = 3) {
                this.tokens = maxTokens;
                this.maxTokens = maxTokens;
                this.refillRate = 1000 / tokensPerSecond;
                this.lastRefill = Date.now();
            }

            async waitForToken() {
                this.refill();
                
                if (this.tokens >= 1) {
                    this.tokens--;
                    return;
                }

                const waitTime = this.refillRate;
                await new Promise(resolve => setTimeout(resolve, waitTime));
                return this.waitForToken();
            }

            refill() {
                const now = Date.now();
                const timePassed = now - this.lastRefill;
                const tokensToAdd = timePassed / this.refillRate;
                
                this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
                this.lastRefill = now;
            }
        }

        // === API CLIENTS ===
        class CFBDClient {
            constructor() {
                this.baseURL = CONFIG.CFBD_BASE_URL;
                this.rateLimiter = new RateLimiter(2, 3);
            }

            async request(endpoint, params = {}) {
                await this.rateLimiter.waitForToken();
                
                const apiKey = StorageManager.get('cfbd_key');
                if (!apiKey) {
                    throw new Error('CFBD API key not configured');
                }

                const url = new URL(endpoint, this.baseURL);
                Object.keys(params).forEach(key => {
                    if (params[key] !== undefined) {
                        url.searchParams.append(key, params[key]);
                    }
                });

                console.log(`CFBD Request: ${url.toString()}`);

                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Accept': 'application/json'
                    }
                });

                console.log(`CFBD Response: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`CFBD Error: ${response.status} - ${errorText}`);
                    throw new Error(`CFBD API Error ${response.status}: ${response.statusText}${errorText ? ' - ' + errorText : ''}`);
                }

                const data = await response.json();
                console.log(`CFBD Data received:`, data?.length || 'N/A', 'items');
                return data;
            }

            async getGames(season, week, seasonType = 'regular') {
                return this.request('/games', { year: season, week, seasonType });
            }

            async getTeams(season) {
                return this.request('/teams', { year: season });
            }

            async getMetrics(season, metric = 'ppa') {
                return this.request(`/metrics/${metric}`, { year: season });
            }

            async getLines(season, week, seasonType = 'regular') {
                return this.request('/lines', { year: season, week, seasonType });
            }

            async getElo(season) {
                return this.request('/metrics/elo', { year: season });
            }
        }

        class WeatherClient {
            constructor() {
                this.baseURL = CONFIG.WEATHER_BASE_URL;
            }

            async getForecast(lat, lon, datetime) {
                const url = new URL(this.baseURL);
                url.searchParams.append('latitude', lat);
                url.searchParams.append('longitude', lon);
                url.searchParams.append('hourly', 'temperature_2m,precipitation,wind_speed_10m,wind_gusts_10m,precipitation_probability');
                url.searchParams.append('timezone', 'auto');
                url.searchParams.append('forecast_days', '7');

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Weather API ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                return this.extractGameTimeWeather(data, datetime);
            }

            extractGameTimeWeather(data, gameTime) {
                const gameDate = new Date(gameTime);
                const hourly = data.hourly;
                
                // Find closest hour to game time
                let closestIndex = 0;
                let minDiff = Infinity;
                
                hourly.time.forEach((time, index) => {
                    const diff = Math.abs(new Date(time) - gameDate);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = index;
                    }
                });

                return {
                    temperature: hourly.temperature_2m[closestIndex] || 70,
                    precipitation_probability: hourly.precipitation_probability[closestIndex] || 0,
                    wind_speed: hourly.wind_speed_10m[closestIndex] || 0,
                    wind_gusts: hourly.wind_gusts_10m[closestIndex] || 0
                };
            }
        }

        // === FEATURE ENGINEERING ===
        class FeatureEngine {
            constructor() {
                this.cfbdClient = new CFBDClient();
                this.weatherClient = new WeatherClient();
            }

            async buildFeatures(game, teamMetrics, eloData, linesData = null, weatherData = null) {
                const homeTeam = game.home_team;
                const awayTeam = game.away_team;
                
                // ELO differential
                const homeElo = this.getTeamElo(homeTeam, eloData) || 1500;
                const awayElo = this.getTeamElo(awayTeam, eloData) || 1500;
                const eloThug = homeElo - awayElo;

                // PPA metrics
                const homePPA = this.getTeamPPA(homeTeam, teamMetrics);
                const awayPPA = this.getTeamPPA(awayTeam, teamMetrics);
                const netPPAOff = (homePPA.offense || 0) - (awayPPA.offense || 0);
                const netPPADef = (awayPPA.defense || 0) - (homePPA.defense || 0); // Lower defense is better

                // Weather adjustments
                let weatherWind = 0;
                let weatherPrecip = 0;
                if (weatherData && StorageManager.get('use_weather')) {
                    weatherWind = Math.max(0, weatherData.wind_speed - 12) * -0.01;
                    weatherPrecip = weatherData.precipitation_probability > 30 ? -0.05 : 0;
                }

                // Market data
                let marketSpread = 0;
                if (linesData) {
                    const line = linesData.find(l => 
                        l.awayTeam === awayTeam && l.homeTeam === homeTeam
                    );
                    if (line && line.lines && line.lines.length > 0) {
                        marketSpread = line.lines[0].spread || 0;
                    }
                }

                return {
                    eloThug,
                    netPPAOff,
                    netPPADef,
                    homeField: game.neutral_site ? 0 : 1,
                    neutralSite: game.neutral_site ? 1 : 0,
                    weatherWind,
                    weatherPrecip,
                    marketSpread,
                    // Add more features as needed
                };
            }

            getTeamElo(teamName, eloData) {
                const team = eloData.find(t => t.team === teamName);
                return team ? team.elo : null;
            }

            getTeamPPA(teamName, teamMetrics) {
                const team = teamMetrics.find(t => t.team === teamName);
                return team ? {
                    offense: team.overall?.offense || 0,
                    defense: team.overall?.defense || 0
                } : { offense: 0, defense: 0 };
            }
        }

        // === MODELS ===
        class EloModel {
            constructor() {
                this.a = 0.1;  // Calibrated intercept
                this.b = 0.004; // Calibrated slope
            }

            predict(eloThug) {
                return MathUtils.sigmoid(this.a + this.b * eloThug);
            }

            calibrate(games, eloData) {
                // Simple logistic regression via IRLS
                // This is a simplified version - production would use proper IRLS
                const features = [];
                const targets = [];

                games.forEach(game => {
                    if (game.completed) {
                        const homeElo = this.getGameElo(game.home_team, eloData);
                        const awayElo = this.getGameElo(game.away_team, eloData);
                        if (homeElo && awayElo) {
                            features.push(homeElo - awayElo);
                            targets.push(game.home_points > game.away_points ? 1 : 0);
                        }
                    }
                });

                if (features.length > 10) {
                    // Simplified calibration
                    const winsByEloThug = {};
                    const countsByEloThug = {};

                    features.forEach((elo, i) => {
                        const bucket = Math.floor(elo / 50) * 50;
                        winsByEloThug[bucket] = (winsByEloThug[bucket] || 0) + targets[i];
                        countsByEloThug[bucket] = (countsByEloThug[bucket] || 0) + 1;
                    });

                    // Find best fit (simplified)
                    let bestA = 0.1, bestB = 0.004;
                    // In production, use proper maximum likelihood estimation
                }
            }

            getGameElo(teamName, eloData) {
                const team = eloData.find(t => t.team === teamName);
                return team ? team.elo : null;
            }
        }

        class GLMModel {
            constructor() {
                this.coefficients = null;
                this.featureNames = [
                    'eloThug', 'netPPAOff', 'netPPADef', 'homeField', 
                    'neutralSite', 'weatherWind', 'weatherPrecip', 'marketSpread'
                ];
            }

            predict(features) {
                if (!this.coefficients) {
                    // Fallback to simple model
                    return MathUtils.sigmoid(0.1 + 0.004 * features.eloThug);
                }

                const x = this.featureNames.map(name => features[name] || 0);
                const logit = MathUtils.dotProduct(this.coefficients, x);
                return MathUtils.sigmoid(logit);
            }

            train(trainingData) {
                // Simplified training - production would use proper IRLS
                // For now, use simple heuristics
                this.coefficients = [
                    0.004,  // eloThug
                    0.15,   // netPPAOff
                    0.12,   // netPPADef
                    0.08,   // homeField
                    -0.02,  // neutralSite
                    -2.0,   // weatherWind
                    -1.5,   // weatherPrecip
                    -0.02   // marketSpread
                ];
            }
        }

        class StackingModel {
            constructor() {
                this.metaCoeffs = [0.4, 0.6]; // ELO weight, GLM weight
            }

            predict(eloProb, glmProb) {
                return this.metaCoeffs[0] * eloProb + this.metaCoeffs[1] * glmProb;
            }
        }

        // === MAIN PREDICTOR ===
        class GamePredictor {
            constructor() {
                this.cfbdClient = new CFBDClient();
                this.weatherClient = new WeatherClient();
                this.featureEngine = new FeatureEngine();
                this.eloModel = new EloModel();
                this.glmModel = new GLMModel();
                this.stackingModel = new StackingModel();
                
                this.currentSeason = TimeUtils.getCurrentSeason();
                this.currentWeek = TimeUtils.getCurrentWeek();
            }

            async predictGames(season, week) {
                try {
                    // Check for demo mode
                    if (StorageManager.get('demo_mode')) {
                        console.log('Using demo mode');
                        return this.getDemoData();
                    }

                    console.log(`Starting predictions for season ${season}, week ${week}`);
                    UI.showBanner('Loading game data...', 'info');

                    // Test API connectivity first
                    try {
                        console.log('Testing CFBD API connectivity...');
                        const testGames = await this.cfbdClient.getGames(season, week);
                        console.log(`API test successful: found ${testGames?.length || 0} games`);
                    } catch (apiError) {
                        console.error('API connectivity test failed:', apiError);
                        throw new Error(`API Connection Failed: ${apiError.message}. Check your API key and network connection.`);
                    }

                    // Fetch all required data with individual error handling
                    console.log('Fetching game data...');
                    const games = await this.getCachedOrFetch('games', () => this.cfbdClient.getGames(season, week));
                    console.log(`Games loaded: ${games?.length || 0}`);

                    console.log('Fetching team data...');
                    const teams = await this.getCachedOrFetch('teams', () => this.cfbdClient.getTeams(season));
                    console.log(`Teams loaded: ${teams?.length || 0}`);

                    console.log('Fetching metrics...');
                    const metrics = await this.getCachedOrFetch('metrics', () => this.cfbdClient.getMetrics(season, 'ppa'));
                    console.log(`Metrics loaded: ${metrics?.length || 0}`);

                    console.log('Fetching ELO data...');
                    const eloData = await this.getCachedOrFetch('elo', () => this.cfbdClient.getElo(season));
                    console.log(`ELO data loaded: ${eloData?.length || 0}`);

                    let linesData = [];
                    if (StorageManager.get('use_markets')) {
                        try {
                            console.log('Fetching betting lines...');
                            linesData = await this.getCachedOrFetch('lines', () => this.cfbdClient.getLines(season, week));
                            console.log(`Lines loaded: ${linesData?.length || 0}`);
                        } catch (error) {
                            console.warn('Lines data unavailable:', error.message);
                        }
                    }

                    if (!games || games.length === 0) {
                        throw new Error('No games found for this week. Check if the season/week parameters are correct.');
                    }

                    UI.showBanner('Generating predictions...', 'info');

                    // Filter to upcoming games only
                    const upcomingGames = games.filter(game => 
                        !game.completed && new Date(game.start_date) > new Date()
                    );

                    console.log(`Found ${upcomingGames.length} upcoming games`);

                    if (upcomingGames.length === 0) {
                        UI.hideBanner();
                        return []; // No upcoming games
                    }

                    const predictions = [];

                    for (const game of upcomingGames) {
                        try {
                            console.log(`Predicting: ${game.away_team} @ ${game.home_team}`);
                            const prediction = await this.predictGame(game, metrics, eloData, linesData);
                            predictions.push(prediction);
                        } catch (error) {
                            console.warn(`Failed to predict game: ${game.away_team} @ ${game.home_team}`, error);
                        }
                    }

                    console.log(`Generated ${predictions.length} predictions`);
                    UI.hideBanner();
                    return predictions;

                } catch (error) {
                    console.error('Prediction error:', error);
                    UI.showBanner(`Error: ${error.message}`, 'error');
                    throw error;
                }
            }

            async predictGame(game, teamMetrics, eloData, linesData = []) {
                // Get weather data if enabled
                let weatherData = null;
                if (StorageManager.get('use_weather')) {
                    try {
                        const coords = this.getStadiumCoords(game.home_team);
                        if (coords) {
                            weatherData = await this.weatherClient.getForecast(
                                coords[0], coords[1], game.start_date
                            );
                        }
                    } catch (error) {
                        console.warn('Weather data unavailable:', error);
                    }
                }

                // Build features
                const features = await this.featureEngine.buildFeatures(
                    game, teamMetrics, eloData, linesData, weatherData
                );

                // Generate predictions
                const eloProb = this.eloModel.predict(features.eloThug);
                const glmProb = this.glmModel.predict(features);
                const stackedProb = this.stackingModel.predict(eloProb, glmProb);

                // Calculate edge vs market if available
                let marketEdge = null;
                if (features.marketSpread !== 0) {
                    const impliedProb = this.spreadToProb(features.marketSpread);
                    marketEdge = stackedProb - impliedProb;
                }

                // Generate key drivers
                const drivers = this.getKeyDrivers(features, stackedProb);

                return {
                    game_id: game.id,
                    away_team: game.away_team,
                    home_team: game.home_team,
                    start_date: game.start_date,
                    venue: game.venue,
                    neutral_site: game.neutral_site,
                    home_prob: stackedProb,
                    away_prob: 1 - stackedProb,
                    confidence: Math.abs(stackedProb - 0.5) * 2,
                    market_edge: marketEdge,
                    weather: weatherData,
                    drivers: drivers,
                    features: features
                };
            }

            getStadiumCoords(teamName) {
                return STADIUM_COORDS[teamName] || null;
            }

            spreadToProb(spread) {
                // Convert point spread to win probability
                // Simplified model: P = sigmoid(spread / 14)
                return MathUtils.sigmoid(-spread / 14);
            }

            getKeyDrivers(features, prob) {
                const drivers = [];
                const neutral = 0.5;
                const impact = prob - neutral;

                // ELO impact
                if (Math.abs(features.eloThug) > 50) {
                    drivers.push({
                        name: 'ELO Rating',
                        impact: features.eloThug > 0 ? 'positive' : 'negative',
                        value: `${features.eloThug > 0 ? '+' : ''}${Math.round(features.eloThug)}`
                    });
                }

                // PPA impact
                if (Math.abs(features.netPPAOff) > 0.1) {
                    drivers.push({
                        name: 'Offensive Edge',
                        impact: features.netPPAOff > 0 ? 'positive' : 'negative',
                        value: `${features.netPPAOff > 0 ? '+' : ''}${features.netPPAOff.toFixed(2)} PPA`
                    });
                }

                // Weather impact
                if (features.weatherWind < -0.005 || features.weatherPrecip < -0.02) {
                    drivers.push({
                        name: 'Weather',
                        impact: 'negative',
                        value: 'Poor conditions'
                    });
                }

                // Home field
                if (features.homeField) {
                    drivers.push({
                        name: 'Home Field',
                        impact: 'positive',
                        value: 'HFA'
                    });
                }

                return drivers;
            }

            async getCachedOrFetch(key, fetchFn) {
                const cached = StorageManager.get(`cache_${key}`);
                if (cached) {
                    return cached;
                }

                const data = await fetchFn();
                StorageManager.set(`cache_${key}`, data, CONFIG.CACHE_TTL.metrics);
                return data;
            }

            getDemoData() {
                // Sample data for demo mode
                return [
                    {
                        game_id: 'demo_1',
                        away_team: 'Alabama',
                        home_team: 'Georgia',
                        start_date: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString(),
                        venue: 'Sanford Stadium',
                        neutral_site: false,
                        home_prob: 0.65,
                        away_prob: 0.35,
                        confidence: 0.30,
                        market_edge: 0.08,
                        weather: { temperature: 72, wind_speed: 8, precipitation_probability: 20 },
                        drivers: [
                            { name: 'ELO Rating', impact: 'positive', value: '+45' },
                            { name: 'Home Field', impact: 'positive', value: 'HFA' }
                        ]
                    },
                    {
                        game_id: 'demo_2',
                        away_team: 'LSU',
                        home_team: 'Auburn',
                        start_date: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(),
                        venue: 'Jordan-Hare Stadium',
                        neutral_site: false,
                        home_prob: 0.42,
                        away_prob: 0.58,
                        confidence: 0.16,
                        market_edge: -0.03,
                        weather: { temperature: 68, wind_speed: 12, precipitation_probability: 45 },
                        drivers: [
                            { name: 'Offensive Edge', impact: 'negative', value: '-0.15 PPA' },
                            { name: 'Weather', impact: 'negative', value: 'Poor conditions' }
                        ]
                    }
                ];
            }
        }

        // === UI MANAGER ===
        class UIManager {
            constructor() {
                this.currentSort = 'confidence';
                this.predictions = [];
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Settings modal
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.showSettings();
                });

                document.getElementById('closeSettings').addEventListener('click', () => {
                    this.hideSettings();
                });

                document.getElementById('saveSettings').addEventListener('click', () => {
                    this.saveSettings();
                });

                document.getElementById('forgetKeys').addEventListener('click', () => {
                    this.forgetKeys();
                });

                document.getElementById('testApi').addEventListener('click', () => {
                    this.testApiConnection();
                });

                document.getElementById('openConsole').addEventListener('click', () => {
                    alert('Press F12 or right-click → Inspect Element → Console tab to see debug logs');
                });

                // Week navigation
                document.getElementById('prevWeek').addEventListener('click', () => {
                    this.changeWeek(-1);
                });

                document.getElementById('nextWeek').addEventListener('click', () => {
                    this.changeWeek(1);
                });

                // Sort controls
                document.getElementById('sortConfidence').addEventListener('click', () => {
                    this.setSortMode('confidence');
                });

                document.getElementById('sortEdge').addEventListener('click', () => {
                    this.setSortMode('edge');
                });

                document.getElementById('sortTime').addEventListener('click', () => {
                    this.setSortMode('time');
                });

                // Action buttons
                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.refreshData();
                });

                document.getElementById('predictBtn').addEventListener('click', () => {
                    this.runPredictions();
                });

                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportData();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetApp();
                });

                // Modal click outside to close
                document.getElementById('settingsModal').addEventListener('click', (e) => {
                    if (e.target.id === 'settingsModal') {
                        this.hideSettings();
                    }
                });

                // Load saved settings
                this.loadSettings();
            }

            showSettings() {
                document.getElementById('settingsModal').classList.add('show');
            }

            hideSettings() {
                document.getElementById('settingsModal').classList.remove('show');
            }

            loadSettings() {
                const cfbdKey = StorageManager.get('cfbd_key');
                const oddsKey = StorageManager.get('odds_key');
                const useMarkets = StorageManager.get('use_markets');
                const useWeather = StorageManager.get('use_weather');
                const demoMode = StorageManager.get('demo_mode');
                const debugMode = StorageManager.get('debug_mode');

                if (cfbdKey) {
                    document.getElementById('cfbdKey').value = cfbdKey;
                }
                if (oddsKey) {
                    document.getElementById('oddsKey').value = oddsKey;
                }
                
                document.getElementById('useMarkets').checked = useMarkets || false;
                document.getElementById('useWeather').checked = useWeather !== false; // Default true
                document.getElementById('demoMode').checked = demoMode || false;
                document.getElementById('debugMode').checked = debugMode || false;

                // Show demo notice if in demo mode
                if (demoMode) {
                    document.getElementById('demoNotice').style.display = 'block';
                }
            }

            saveSettings() {
                const cfbdKey = document.getElementById('cfbdKey').value.trim();
                const oddsKey = document.getElementById('oddsKey').value.trim();
                const useMarkets = document.getElementById('useMarkets').checked;
                const useWeather = document.getElementById('useWeather').checked;
                const demoMode = document.getElementById('demoMode').checked;
                const debugMode = document.getElementById('debugMode').checked;

                if (cfbdKey) {
                    StorageManager.set('cfbd_key', cfbdKey);
                }
                if (oddsKey) {
                    StorageManager.set('odds_key', oddsKey);
                }

                StorageManager.set('use_markets', useMarkets);
                StorageManager.set('use_weather', useWeather);
                StorageManager.set('demo_mode', demoMode);
                StorageManager.set('debug_mode', debugMode);

                // Show/hide demo notice
                document.getElementById('demoNotice').style.display = demoMode ? 'block' : 'none';

                this.hideSettings();
                this.showBanner('Settings saved successfully', 'success');

                // Auto-refresh if we have valid settings
                if (cfbdKey || demoMode) {
                    setTimeout(() => this.runPredictions(), 1000);
                }
            }

            async testApiConnection() {
                const cfbdKey = document.getElementById('cfbdKey').value.trim();
                
                if (!cfbdKey) {
                    this.showBanner('Please enter a CFBD API key first', 'error');
                    return;
                }

                try {
                    this.showBanner('Testing API connection...', 'info');
                    
                    // Temporarily save the key for testing
                    const originalKey = StorageManager.get('cfbd_key');
                    StorageManager.set('cfbd_key', cfbdKey);
                    
                    const cfbdClient = new CFBDClient();
                    const testResult = await cfbdClient.getGames(TimeUtils.getCurrentSeason(), TimeUtils.getCurrentWeek());
                    
                    console.log('API Test Result:', testResult);
                    
                    if (testResult && Array.isArray(testResult)) {
                        this.showBanner(`✅ API Connection Successful! Found ${testResult.length} games.`, 'success');
                    } else {
                        this.showBanner('⚠️ API responded but data format unexpected', 'warning');
                    }
                    
                    // Restore original key if test key was different
                    if (originalKey && originalKey !== cfbdKey) {
                        StorageManager.set('cfbd_key', originalKey);
                    }
                    
                } catch (error) {
                    console.error('API Test Failed:', error);
                    
                    let errorMsg = '❌ API Test Failed: ';
                    if (error.message.includes('401')) {
                        errorMsg += 'Invalid API key';
                    } else if (error.message.includes('CORS')) {
                        errorMsg += 'CORS error - try Demo Mode';
                    } else if (error.message.includes('network')) {
                        errorMsg += 'Network error - check connection';
                    } else {
                        errorMsg += error.message;
                    }
                    
                    this.showBanner(errorMsg, 'error');
                }
            }

            forgetKeys() {
                if (confirm('Are you sure you want to forget all API keys and cached data?')) {
                    StorageManager.clear();
                    document.getElementById('cfbdKey').value = '';
                    document.getElementById('oddsKey').value = '';
                    document.getElementById('useMarkets').checked = false;
                    document.getElementById('useWeather').checked = true;
                    document.getElementById('demoMode').checked = false;
                    document.getElementById('debugMode').checked = false;
                    
                    this.showBanner('All data cleared', 'success');
                    this.renderGames([]);
                }
            }

            changeWeek(direction) {
                // For now, just show message - implement week navigation later
                this.showBanner('Week navigation coming soon', 'info');
            }

            setSortMode(mode) {
                this.currentSort = mode;
                
                // Update button states
                document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`sort${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
                
                // Re-render with new sort
                this.renderGames(this.predictions);
            }

            async refreshData() {
                // Clear relevant caches
                ['games', 'metrics', 'elo', 'lines', 'weather'].forEach(key => {
                    StorageManager.remove(`cache_${key}`);
                });
                
                this.showBanner('Cache cleared, refreshing...', 'info');
                await this.runPredictions();
            }

            async runPredictions() {
                const startTime = Date.now();
                
                try {
                    console.log('=== Starting prediction run ===');
                    this.showLoading();
                    
                    const predictor = new GamePredictor();
                    const predictions = await predictor.predictGames(
                        TimeUtils.getCurrentSeason(),
                        TimeUtils.getCurrentWeek()
                    );
                    
                    console.log(`Prediction run completed in ${Date.now() - startTime}ms`);
                    this.predictions = predictions;
                    this.renderGames(predictions);
                    
                } catch (error) {
                    console.error('Prediction run failed:', error);
                    this.showBanner(`Prediction failed: ${error.message}`, 'error');
                    
                    // Show helpful error message based on error type
                    if (error.message.includes('401') || error.message.includes('unauthorized')) {
                        this.showBanner('Invalid API key. Check your CFBD key in settings.', 'error');
                    } else if (error.message.includes('CORS') || error.message.includes('network')) {
                        this.showBanner('Network error. Try enabling Demo Mode in settings.', 'error');
                    } else if (error.message.includes('rate limit') || error.message.includes('429')) {
                        this.showBanner('Rate limited. Please wait and try again.', 'error');
                    }
                    
                    // Show debug info
                    console.error('Full error details:', {
                        message: error.message,
                        stack: error.stack,
                        timestamp: new Date().toISOString(),
                        hasApiKey: !!StorageManager.get('cfbd_key'),
                        demoMode: !!StorageManager.get('demo_mode'),
                        currentSeason: TimeUtils.getCurrentSeason(),
                        currentWeek: TimeUtils.getCurrentWeek()
                    });
                    
                    // Always render something, even if empty
                    this.renderGames([]);
                } finally {
                    // Always clear loading state
                    console.log('=== Prediction run finished ===');
                }
            }

            exportData() {
                const exportData = {
                    predictions: this.predictions,
                    timestamp: new Date().toISOString(),
                    settings: {
                        use_markets: StorageManager.get('use_markets'),
                        use_weather: StorageManager.get('use_weather'),
                        demo_mode: StorageManager.get('demo_mode')
                    }
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cfb_predictions_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                this.showBanner('Data exported successfully', 'success');
            }

            resetApp() {
                if (confirm('Reset app to default state? This will clear all data.')) {
                    StorageManager.clear();
                    location.reload();
                }
            }

            showLoading() {
                document.getElementById('gamesContainer').innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                    </div>
                `;
            }

            hideLoading() {
                // Will be replaced by renderGames
            }

            renderGames(predictions) {
                const container = document.getElementById('gamesContainer');
                
                if (!predictions || predictions.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            <p>No upcoming games found.</p>
                            <p style="font-size: 14px; margin-top: 8px;">
                                ${StorageManager.get('demo_mode') ? 
                                    'Demo mode is enabled with sample data.' : 
                                    'Configure your API key in settings to load live data.'
                                }
                            </p>
                        </div>
                    `;
                    return;
                }

                // Sort predictions
                const sorted = [...predictions].sort((a, b) => {
                    switch (this.currentSort) {
                        case 'confidence':
                            return (b.confidence || 0) - (a.confidence || 0);
                        case 'edge':
                            return Math.abs(b.market_edge || 0) - Math.abs(a.market_edge || 0);
                        case 'time':
                            return new Date(a.start_date) - new Date(b.start_date);
                        default:
                            return 0;
                    }
                });

                container.innerHTML = sorted.map(prediction => this.renderGameCard(prediction)).join('');
                
                // Add event listeners for "Why" buttons
                container.querySelectorAll('.why-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const gameId = e.target.dataset.gameId;
                        this.toggleDrivers(gameId);
                    });
                });
            }

            renderGameCard(prediction) {
                const homeWinProb = Math.round(prediction.home_prob * 100);
                const awayWinProb = Math.round(prediction.away_prob * 100);
                const confidence = Math.round(prediction.confidence * 100);
                
                const edgeBadge = prediction.market_edge && Math.abs(prediction.market_edge) > 0.05 ? 
                    `<span class="edge-badge">${prediction.market_edge > 0 ? '+' : ''}${Math.round(prediction.market_edge * 100)}%</span>` : '';

                const venueInfo = prediction.neutral_site ? 
                    `<span class="venue-info">Neutral</span>` : 
                    `<span class="venue-info">${prediction.venue || 'Home'}</span>`;

                const driversHtml = prediction.drivers ? 
                    prediction.drivers.map(driver => 
                        `<span class="driver-chip ${driver.impact}">${driver.name}: ${driver.value}</span>`
                    ).join('') : '';

                const rationale = this.generateRationale(prediction);

                return `
                    <div class="game-card">
                        <div class="game-header">
                            <div class="game-time">${TimeUtils.formatGameTime(prediction.start_date)}</div>
                            ${venueInfo}
                        </div>
                        
                        <div class="matchup">
                            <div class="team">
                                <div class="team-name">${prediction.away_team}</div>
                                <div class="team-record">Away</div>
                            </div>
                            <div class="vs">@</div>
                            <div class="team">
                                <div class="team-name">${prediction.home_team}</div>
                                <div class="team-record">Home</div>
                            </div>
                        </div>
                        
                        <div class="prediction">
                            <div class="prob-display">
                                <span class="prob-pill">${homeWinProb}%</span>
                                <svg class="confidence-ring" viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="10" fill="none" stroke="var(--border-color)" stroke-width="2"/>
                                    <circle cx="12" cy="12" r="10" fill="none" stroke="var(--accent-color)" stroke-width="2"
                                            stroke-dasharray="${confidence * 0.628} 62.8" stroke-dashoffset="15.7"/>
                                </svg>
                                ${edgeBadge}
                            </div>
                            <button class="why-btn" data-game-id="${prediction.game_id}">Why?</button>
                        </div>
                        
                        <div id="drivers-${prediction.game_id}" class="drivers">
                            <div class="driver-chips">${driversHtml}</div>
                            <div class="rationale">${rationale}</div>
                        </div>
                    </div>
                `;
            }

            generateRationale(prediction) {
                const homeTeam = prediction.home_team;
                const homeProb = Math.round(prediction.home_prob * 100);
                
                let reasons = [];
                
                if (prediction.features && prediction.features.eloThug > 50) {
                    reasons.push('superior rating');
                } else if (prediction.features && prediction.features.eloThug < -50) {
                    reasons.push('rating disadvantage');
                }
                
                if (!prediction.neutral_site) {
                    reasons.push('home field advantage');
                }
                
                if (prediction.weather && prediction.weather.wind_speed > 15) {
                    reasons.push('weather concerns');
                }
                
                const mainReason = reasons.length > 0 ? ` due to ${reasons.join(' and ')}` : '';
                
                return `${homeTeam} favored ${homeProb}%${mainReason}.`;
            }

            toggleDrivers(gameId) {
                const driversEl = document.getElementById(`drivers-${gameId}`);
                if (driversEl) {
                    driversEl.classList.toggle('show');
                }
            }

            showBanner(message, type = 'info') {
                const banner = document.getElementById('banner');
                banner.textContent = message;
                banner.className = `banner show ${type}`;
                
                // Auto-hide after 3 seconds for success/info messages
                if (type !== 'error') {
                    setTimeout(() => this.hideBanner(), 3000);
                }
            }

            hideBanner() {
                const banner = document.getElementById('banner');
                banner.classList.remove('show');
            }
        }

        // === INITIALIZATION ===
        const UI = new UIManager();

        // Enhanced logging for debug mode
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;

        function debugLog(...args) {
            originalConsoleLog(...args);
            if (StorageManager.get('debug_mode')) {
                const timestamp = new Date().toLocaleTimeString();
                const message = args.join(' ');
                UI.showBanner(`[${timestamp}] ${message}`, 'info');
            }
        }

        // Override console methods for debug mode
        console.log = debugLog;

        // Auto-load on page load if we have settings
        document.addEventListener('DOMContentLoaded', () => {
            console.log('CFB Predictor starting up...');
            
            const hasKey = StorageManager.get('cfbd_key');
            const demoMode = StorageManager.get('demo_mode');
            
            console.log(`Has API key: ${!!hasKey}, Demo mode: ${!!demoMode}`);
            
            if (hasKey || demoMode) {
                setTimeout(() => {
                    console.log('Auto-starting predictions...');
                    UI.runPredictions();
                }, 500);
            } else {
                UI.showBanner('Configure your CFBD API key in settings to get started', 'info');
                // Show some skeleton cards
                document.getElementById('gamesContainer').innerHTML = `
                    <div class="skeleton skeleton-card"></div>
                    <div class="skeleton skeleton-card"></div>
                    <div class="skeleton skeleton-card"></div>
                `.replace(/skeleton-card/g, 'skeleton-card');
                
                console.log('No API key configured. Showing setup message.');
            }
        });

        // Web Worker for heavy computation (simplified for single file)
        // In production, this would be a separate file
        const createWorker = () => {
            const workerCode = `
                // Web Worker code for heavy ML computations
                self.onmessage = function(e) {
                    const { type, data } = e.data;
                    
                    switch (type) {
                        case 'irls':
                            // Simplified IRLS implementation
                            const result = performIRLS(data);
                            self.postMessage({ type: 'irls_result', result });
                            break;
                        case 'calibration':
                            // Isotonic regression implementation
                            const calibration = performCalibration(data);
                            self.postMessage({ type: 'calibration_result', result: calibration });
                            break;
                    }
                };
                
                function performIRLS(data) {
                    // Simplified IRLS for logistic regression
                    // In production, implement proper iteratively reweighted least squares
                    return { coefficients: [0.1, 0.004] };
                }
                
                function performCalibration(data) {
                    // Simplified isotonic regression
                    // In production, implement proper PAV algorithm
                    return { mapping: x => x };
                }
            `;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        };

        // Global error handler
        window.addEventListener('error', (e) => {
            console.error('App error:', e.error);
            UI.showBanner('An unexpected error occurred', 'error');
        });

        // Service worker registration (for PWA capabilities)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript,// Minimal SW')
                .catch(err => console.log('SW registration failed'));
        }
    </script>

    <!-- 
    README:
    
    CFB Winner Predictor - Single File Mobile Web App
    ================================================
    
    ## Getting Started
    
    1. **Get a CFBD API Key**
       - Visit https://collegefootballdata.com
       - Sign up for a free account
       - Generate an API key
       - Paste it in the app settings
    
    2. **Deploy to GitHub Pages**
       - Create a new GitHub repository
       - Upload this index.html file
       - Go to Settings > Pages
       - Select "Deploy from a branch" and choose main/master
       - Your app will be available at https://username.github.io/repository-name
    
    3. **Using Demo Mode**
       - If APIs are blocked or unavailable, enable "Demo Mode" in settings
       - This loads sample data so you can explore the UI
       - Perfect for testing before configuring real API keys
    
    ## Features
    
    - Live college football game predictions
    - Weather-adjusted probabilities
    - Market edge detection (when betting lines available)
    - Mobile-optimized interface
    - Offline-capable with data caching
    - Dark mode support
    - Accessibility features
    
    ## API Requirements
    
    - CFBD API key (required): Free at collegefootballdata.com
    - TheOddsAPI key (optional): For betting market data
    - Weather data: Uses free Open-Meteo API (no key required)
    
    ## Privacy & Security
    
    - All API keys stored locally on your device only
    - No data transmitted to third parties
    - Use "Forget Keys" to clear all stored data
    
    Built with no external dependencies - pure HTML/CSS/JavaScript.
    -->
</body>
</html>
