<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Bias Detector</title>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #808080;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #10b981;
            --border-color: #404040;
            --glow-blue: rgba(59, 130, 246, 0.3);
            --glow-red: rgba(239, 68, 68, 0.3);
            --gradient-left: linear-gradient(90deg, #3b82f6, #6366f1);
            --gradient-right: linear-gradient(90deg, #f59e0b, #ef4444);
            --gradient-neutral: linear-gradient(90deg, #6b7280, #9ca3af);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 390px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-top: env(safe-area-inset-top, 20px);
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            background: var(--gradient-neutral);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px var(--glow-blue);
        }

        .subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-field {
            width: 100%;
            padding: 16px;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.3s ease;
            -webkit-appearance: none;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px var(--glow-blue);
        }

        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: var(--gradient-left);
            color: white;
            box-shadow: 0 4px 20px var(--glow-blue);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px var(--glow-blue);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .collapsible {
            margin-bottom: 20px;
        }

        .collapsible-header {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .collapsible-header:hover {
            background: var(--bg-tertiary);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.open {
            max-height: 500px;
        }

        .collapsible-inner {
            padding: 16px;
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
            background: var(--bg-secondary);
        }

        .textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            resize: vertical;
            font-family: inherit;
        }

        .result-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .result-card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .score-display {
            text-align: center;
            margin-bottom: 24px;
        }

        .score-number {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .confidence {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .bias-scale {
            position: relative;
            height: 40px;
            background: linear-gradient(90deg, var(--accent-blue), #6b7280, var(--accent-red));
            border-radius: 20px;
            margin: 24px 0;
            overflow: hidden;
        }

        .scale-ticks {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        .scale-tick {
            width: 2px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 1px;
        }

        .scale-marker {
            position: absolute;
            top: 50%;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            transition: left 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .explanation {
            margin-top: 20px;
        }

        .explanation-text {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .evidence-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .evidence-chip {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 6px 12px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .evidence-chip.positive {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .evidence-chip.negative {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .bias-sentence {
            background: var(--bg-primary);
            border-left: 4px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 14px;
            line-height: 1.5;
        }

        .bias-sentence.left-positive {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .bias-sentence.left-negative {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.05);
        }

        .bias-sentence.right-positive {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.05);
        }

        .bias-sentence.right-negative {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .bias-sentence.left-framing {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .bias-sentence.right-framing {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.05);
        }

        .bias-sentence.emotional-language {
            border-left-color: var(--accent-green);
            background: rgba(16, 185, 129, 0.05);
        }

        .sentence-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 6px;
            opacity: 0.8;
        }

        .sentence-label.left-positive { color: var(--accent-blue); }
        .sentence-label.left-negative { color: var(--accent-red); }
        .sentence-label.right-positive { color: var(--accent-red); }
        .sentence-label.right-negative { color: var(--accent-blue); }
        .sentence-label.left-framing { color: var(--accent-blue); }
        .sentence-label.right-framing { color: var(--accent-red); }
        .sentence-label.emotional-language { color: var(--accent-green); }

        .history-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .history-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: var(--bg-tertiary);
            transform: translateX(4px);
        }

        .history-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .history-score {
            font-weight: 600;
        }

        .history-time {
            font-size: 12px;
            color: var(--text-muted);
        }

        .history-url {
            font-size: 12px;
            color: var(--text-secondary);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .error-message {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            color: var(--accent-red);
            text-align: center;
        }

        .about-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .about-title {
            cursor: pointer;
            user-select: none;
        }

        .dev-panel {
            background: var(--bg-primary);
            border: 2px solid var(--accent-green);
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }

        .dev-panel.visible {
            display: block;
        }

        .dev-section {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .dev-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .dev-label {
            color: var(--accent-green);
            font-weight: bold;
        }

        .safe-area-bottom {
            height: env(safe-area-inset-bottom, 20px);
        }

        /* iOS specific optimizations */
        @supports (-webkit-touch-callout: none) {
            .input-field {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus indicators */
        .btn:focus,
        .input-field:focus,
        .collapsible-header:focus,
        .history-item:focus {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">Bias Detector</h1>
            <p class="subtitle">Natural language analysis via contextual patterns</p>
        </header>

        <main>
            <section class="input-section">
                <div class="input-group">
                    <label for="url-input" class="sr-only">Article URL</label>
                    <input 
                        type="url" 
                        id="url-input" 
                        class="input-field" 
                        placeholder="Enter article URL..." 
                        aria-describedby="url-help"
                    >
                </div>
                <button id="analyze-btn" class="btn btn-primary" aria-describedby="analyze-help">
                    <span id="analyze-text">Analyze Article</span>
                    <span id="analyze-loading" class="loading" style="display: none;" aria-hidden="true"></span>
                </button>
                <div id="url-help" class="sr-only">Enter the URL of a news article to analyze for political bias</div>
                <div id="analyze-help" class="sr-only">Click to start bias analysis</div>
            </section>

            <section class="collapsible">
                <div class="collapsible-header" tabindex="0" role="button" aria-expanded="false" aria-controls="paste-content">
                    <span>Paste Article Text</span>
                    <span class="chevron">▼</span>
                </div>
                <div class="collapsible-content" id="paste-content">
                    <div class="collapsible-inner">
                        <textarea 
                            id="article-text" 
                            class="textarea" 
                            placeholder="Paste article text here as fallback..."
                            aria-label="Article text for manual analysis"
                        ></textarea>
                        <button id="analyze-text-btn" class="btn btn-secondary" style="margin-top: 12px;">
                            Analyze Text
                        </button>
                    </div>
                </div>
            </section>

            <div id="error-container"></div>

            <section id="result-section" class="result-card" style="display: none;" role="region" aria-label="Analysis results">
                <div class="score-display">
                    <div id="score-number" class="score-number" aria-label="Bias score">0</div>
                    <div id="confidence-display" class="confidence">Confidence: <span id="confidence-value">0</span>%</div>
                </div>
                
                <div class="bias-scale" role="img" aria-label="Political bias scale">
                    <div class="scale-ticks">
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                    </div>
                    <div id="scale-marker" class="scale-marker"></div>
                </div>
                <div class="scale-labels">
                    <span>Left -100</span>
                    <span>-50</span>
                    <span>0</span>
                    <span>+50</span>
                    <span>Right +100</span>
                </div>

                <div class="explanation">
                    <div id="explanation-text" class="explanation-text"></div>
                    <div id="evidence-chips" class="evidence-chips" aria-label="Evidence keywords"></div>
                    
                    <div class="bias-sentences" style="margin-top: 20px;">
                        <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">Key Sentences Showing Bias:</h3>
                        <div id="bias-sentences-list" aria-label="Sentences that demonstrate bias"></div>
                    </div>
                </div>
            </section>

            <section class="history-section">
                <h2 class="section-title">Recent Analyses</h2>
                <div id="history-list" aria-label="Analysis history">
                    <p id="no-history" class="history-item" style="opacity: 0.6; cursor: default;">No analyses yet</p>
                </div>
            </section>

            <section class="about-section">
                <h2 class="section-title about-title" id="about-title">About & Method</h2>
                <p style="font-size: 14px; line-height: 1.6; color: var(--text-secondary);">
                    This tool analyzes news articles for political bias using natural language processing techniques. 
                    It examines contextual sentiment around political entities, linguistic patterns, argument structure, 
                    source attribution, and topic framing to estimate bias on a left-right scale. The analysis focuses 
                    on <em>how</em> things are said rather than just <em>what</em> is said. 
                    <strong>Results are estimates</strong> - use critical thinking.
                </p>
                
                <div id="dev-panel" class="dev-panel">
                    <div class="dev-section">
                        <div class="dev-label">Proxy Used:</div>
                        <div id="dev-proxy">None</div>
                    </div>
                    <div class="dev-section">
                        <div class="dev-label">Feature Scores:</div>
                        <div id="dev-features">N/A</div>
                    </div>
                    <div class="dev-section">
                        <div class="dev-label">Lexicon Hits:</div>
                        <div id="dev-lexicon">N/A</div>
                    </div>
                    <div class="dev-section">
                        <div class="dev-label">Outlet Prior:</div>
                        <div id="dev-outlet">N/A</div>
                    </div>
                    <div class="dev-section">
                        <div class="dev-label">Normalization:</div>
                        <div id="dev-norm">N/A</div>
                    </div>
                    <div class="dev-section">
                        <div class="dev-label">Timing:</div>
                        <div id="dev-timing">N/A</div>
                    </div>
                </div>
            </section>
        </main>

        <div class="safe-area-bottom"></div>
    </div>

    <script>
        'use strict';

        // Configuration
        const CONFIG = {
            maxWordCount: 2500,
            proxyTimeout: 7000,
            maxRetries: 3,
            storageVersion: 1,
            storageKey: 'bias_detector_v1',
            maxHistoryItems: 5
        };

        // CORS Proxy rotation - Add more proxies as needed
        const PROXIES = [
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/',
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/'
        ];

        // Outlet bias priors (small influence, max ±8)
        const OUTLET_PRIORS = {
            'cnn.com': -5,
            'msnbc.com': -6,
            'nytimes.com': -3,
            'washingtonpost.com': -3,
            'huffpost.com': -7,
            'foxnews.com': 6,
            'breitbart.com': 8,
            'dailywire.com': 7,
            'nypost.com': 4,
            'wsj.com': 2,
            'reuters.com': 0,
            'ap.org': 0,
            'apnews.com': 0,
            'bbc.com': -1,
            'npr.org': -2
        };

        // Application state
        let currentAnalysis = null;
        let devPanelTaps = 0;
        let devPanelVisible = false;

        // DOM elements
        const elements = {
            urlInput: document.getElementById('url-input'),
            analyzeBtn: document.getElementById('analyze-btn'),
            analyzeText: document.getElementById('analyze-text'),
            analyzeLoading: document.getElementById('analyze-loading'),
            articleText: document.getElementById('article-text'),
            analyzeTextBtn: document.getElementById('analyze-text-btn'),
            errorContainer: document.getElementById('error-container'),
            resultSection: document.getElementById('result-section'),
            scoreNumber: document.getElementById('score-number'),
            confidenceValue: document.getElementById('confidence-value'),
            scaleMarker: document.getElementById('scale-marker'),
            explanationText: document.getElementById('explanation-text'),
            evidenceChips: document.getElementById('evidence-chips'),
            biasSentencesList: document.getElementById('bias-sentences-list'),
            historyList: document.getElementById('history-list'),
            noHistory: document.getElementById('no-history'),
            aboutTitle: document.getElementById('about-title'),
            devPanel: document.getElementById('dev-panel'),
            devProxy: document.getElementById('dev-proxy'),
            devFeatures: document.getElementById('dev-features'),
            devLexicon: document.getElementById('dev-lexicon'),
            devOutlet: document.getElementById('dev-outlet'),
            devNorm: document.getElementById('dev-norm'),
            devTiming: document.getElementById('dev-timing')
        };

        // Utility functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return ['http:', 'https:'].includes(url.protocol);
            } catch {
                return false;
            }
        }

        function sanitizeUrl(url) {
            if (!url) return null;
            url = url.trim();
            if (!url.startsWith('http')) {
                url = 'https://' + url;
            }
            return isValidUrl(url) ? url : null;
        }

        function showError(message) {
            elements.errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
            setTimeout(() => {
                elements.errorContainer.innerHTML = '';
            }, 5000);
        }

        function setLoading(isLoading) {
            elements.analyzeBtn.disabled = isLoading;
            elements.analyzeTextBtn.disabled = isLoading;
            elements.analyzeText.style.display = isLoading ? 'none' : 'inline';
            elements.analyzeLoading.style.display = isLoading ? 'inline-block' : 'none';
        }

        // Storage functions
        function saveToStorage(analysis) {
            try {
                const stored = localStorage.getItem(CONFIG.storageKey);
                let history = stored ? JSON.parse(stored) : { version: CONFIG.storageVersion, analyses: [] };
                
                if (history.version !== CONFIG.storageVersion) {
                    history = { version: CONFIG.storageVersion, analyses: [] };
                }

                history.analyses.unshift({
                    timestamp: Date.now(),
                    url: analysis.url || 'Manual Text',
                    title: analysis.title || 'Untitled',
                    score: analysis.score,
                    confidence: analysis.confidence
                });

                // Keep only last 5 analyses
                history.analyses = history.analyses.slice(0, CONFIG.maxHistoryItems);
                
                localStorage.setItem(CONFIG.storageKey, JSON.stringify(history));
                renderHistory();
            } catch (error) {
                console.warn('Failed to save to localStorage:', error);
            }
        }

        function loadFromStorage() {
            try {
                const stored = localStorage.getItem(CONFIG.storageKey);
                if (!stored) return [];
                
                const history = JSON.parse(stored);
                if (history.version !== CONFIG.storageVersion) return [];
                
                return history.analyses || [];
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
                return [];
            }
        }

        function renderHistory() {
            const history = loadFromStorage();
            
            if (history.length === 0) {
                elements.noHistory.style.display = 'block';
                return;
            }

            elements.noHistory.style.display = 'none';
            
            const historyItems = history.map(item => {
                const date = new Date(item.timestamp).toLocaleDateString();
                const scoreColor = item.score > 0 ? 'var(--accent-red)' : item.score < 0 ? 'var(--accent-blue)' : 'var(--text-secondary)';
                
                return `
                    <div class="history-item" tabindex="0" role="button" onclick="restoreAnalysis(${item.timestamp})" onkeydown="handleHistoryKeydown(event, ${item.timestamp})">
                        <div class="history-meta">
                            <span class="history-score" style="color: ${scoreColor}">${item.score > 0 ? '+' : ''}${item.score}</span>
                            <span class="history-time">${date}</span>
                        </div>
                        <div class="history-url">${item.url}</div>
                    </div>
                `;
            }).join('');

            elements.historyList.innerHTML = historyItems;
        }

        window.restoreAnalysis = function(timestamp) {
            const history = loadFromStorage();
            const item = history.find(h => h.timestamp === timestamp);
            if (!item) return;

            if (item.url !== 'Manual Text') {
                elements.urlInput.value = item.url;
            }
            
            // Could restore full analysis here if we saved more details
            showError(`Restored: ${item.title} (Score: ${item.score})`);
        };

        window.handleHistoryKeydown = function(event, timestamp) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                restoreAnalysis(timestamp);
            }
        };

        // Content extraction from HTML
        function extractContent(html, url) {
            try {
                // Create a new DOMParser instance for safe parsing
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Remove scripts, styles, and other unwanted elements
                const unwanted = doc.querySelectorAll('script, style, nav, footer, aside, header, .ad, .advertisement, .sidebar, .related, .comments, .social, .share');
                unwanted.forEach(el => el.remove());

                // Extract title
                let title = '';
                const titleEl = doc.querySelector('title, h1, .title, .headline');
                if (titleEl) {
                    title = titleEl.textContent.trim();
                }

                // Extract main content
                const contentSelectors = [
                    'article',
                    '.article-content',
                    '.content',
                    '.post-content',
                    '.entry-content',
                    'main',
                    '.main-content',
                    '.story-body',
                    '.article-body'
                ];

                let content = '';
                for (const selector of contentSelectors) {
                    const element = doc.querySelector(selector);
                    if (element) {
                        content = element.textContent;
                        break;
                    }
                }

                // Fallback to body if no specific content found
                if (!content) {
                    const body = doc.querySelector('body');
                    if (body) {
                        content = body.textContent;
                    }
                }

                // Clean and normalize text
                content = content
                    .replace(/\s+/g, ' ')
                    .replace(/[""'']/g, '"')
                    .replace(/[–—]/g, '-')
                    .trim();

                // Limit word count
                const words = content.split(/\s+/);
                if (words.length > CONFIG.maxWordCount) {
                    content = words.slice(0, CONFIG.maxWordCount).join(' ') + '...';
                }

                return { title, content, wordCount: words.length };
            } catch (error) {
                throw new Error('Failed to parse HTML content');
            }
        }

        // Proxy rotation with timeout and error handling
        async function fetchWithProxies(url) {
            const startTime = Date.now();
            let lastError = null;
            let proxyUsed = 'Direct';

            // Try direct fetch first (for CORS-enabled sites)
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), CONFIG.proxyTimeout);
                
                const response = await fetch(url, {
                    signal: controller.signal,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const text = await response.text();
                    updateDevPanel({ proxy: 'Direct', timing: Date.now() - startTime });
                    return text;
                }
            } catch (error) {
                lastError = error;
            }

            // Try proxies
            for (let i = 0; i < PROXIES.length; i++) {
                const proxy = PROXIES[i];
                proxyUsed = `Proxy ${i + 1}`;
                
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), CONFIG.proxyTimeout);
                    
                    const proxyUrl = proxy + encodeURIComponent(url);
                    const response = await fetch(proxyUrl, {
                        signal: controller.signal,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const text = await response.text();
                        updateDevPanel({ proxy: proxyUsed, timing: Date.now() - startTime });
                        return text;
                    }
                } catch (error) {
                    lastError = error;
                    console.warn(`Proxy ${i + 1} failed:`, error.message);
                }
            }

            throw new Error(`All proxies failed. Last error: ${lastError?.message || 'Unknown error'}`);
        }

        // Natural bias detection algorithm - analyzes context, tone, and argumentation patterns
        function analyzeBias(text, title = '', url = '') {
            const startTime = Date.now();
            
            // Normalize and prepare text
            const normalizedText = text.toLowerCase();
            const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 10);
            
            // Political entities for contextual analysis
            const politicalEntities = {
                left: ['democrats', 'biden', 'harris', 'pelosi', 'schumer', 'aoc', 'sanders', 'warren'],
                right: ['republicans', 'trump', 'desantis', 'mcconnell', 'cruz', 'hawley', 'greene'],
                neutral: ['congress', 'senate', 'house', 'government', 'administration', 'officials']
            };

            // Initialize scoring components
            let features = {};
            let evidenceTerms = [];
            let contextualSignals = 0;
            let biasSentences = []; // Store sentences that show bias

            // 1. CONTEXTUAL SENTIMENT ANALYSIS
            // Analyze sentiment around political entities and capture biased sentences
            function analyzeContextualSentiment() {
                let leftSentiment = 0;
                let rightSentiment = 0;
                const contextWindow = 20; // words around entity
                
                sentences.forEach(sentence => {
                    const words = sentence.toLowerCase().split(/\s+/);
                    let sentenceBias = 0;
                    let sentenceDirection = null;
                    let foundEntities = [];
                    
                    // Find political entities in sentence
                    words.forEach((word, index) => {
                        let entityBias = null;
                        if (politicalEntities.left.some(entity => word.includes(entity))) {
                            entityBias = 'left';
                            foundEntities.push(word);
                        }
                        if (politicalEntities.right.some(entity => word.includes(entity))) {
                            entityBias = 'right';
                            foundEntities.push(word);
                        }
                        
                        if (entityBias) {
                            // Analyze context around entity
                            const start = Math.max(0, index - contextWindow);
                            const end = Math.min(words.length, index + contextWindow);
                            const context = words.slice(start, end).join(' ');
                            
                            // Positive sentiment indicators
                            const positiveContext = /\b(successful|effective|strong|praised|support|defend|champion|fight for|stand up|deliver|accomplish|achieve|brilliant|outstanding|excellent)\b/g;
                            const negativeContext = /\b(failed|ineffective|weak|criticized|attack|oppose|undermine|damage|hurt|threaten|dangerous|extreme|ridiculous|absurd|disaster)\b/g;
                            
                            const positiveMatches = (context.match(positiveContext) || []).length;
                            const negativeMatches = (context.match(negativeContext) || []).length;
                            const sentimentScore = positiveMatches - negativeMatches;
                            
                            // Track sentence-level bias
                            if (Math.abs(sentimentScore) > 0) {
                                sentenceBias += sentimentScore;
                                sentenceDirection = entityBias;
                            }
                            
                            // Apply sentiment based on entity bias
                            if (entityBias === 'left') {
                                leftSentiment += sentimentScore;
                            } else {
                                rightSentiment += sentimentScore;
                            }
                            
                            if (Math.abs(sentimentScore) > 0) {
                                evidenceTerms.push({
                                    term: word,
                                    context: sentimentScore > 0 ? 'positive' : 'negative',
                                    strength: Math.abs(sentimentScore),
                                    bias: entityBias
                                });
                            }
                        }
                    });
                    
                    // Store biased sentences for display
                    if (Math.abs(sentenceBias) > 0 && foundEntities.length > 0) {
                        const finalBias = sentenceBias > 0 ? 
                            (sentenceDirection === 'left' ? 'left-positive' : 'right-positive') :
                            (sentenceDirection === 'left' ? 'left-negative' : 'right-negative');
                            
                        biasSentences.push({
                            text: sentence.trim(),
                            bias: finalBias,
                            strength: Math.abs(sentenceBias),
                            entities: foundEntities,
                            type: 'contextual'
                        });
                    }
                });
                
                return { leftSentiment, rightSentiment };
            }

            // 2. LINGUISTIC PATTERN ANALYSIS
            // Detect rhetorical patterns that indicate bias and capture sentences
            function analyzeLinguisticPatterns() {
                let patterns = { certainty: 0, hedging: 0, emotional: 0, factual: 0 };
                
                // Certainty vs hedging language
                const certaintyMarkers = /\b(clearly|obviously|undoubtedly|definitely|certainly|without question|no doubt|absolutely)\b/gi;
                const hedgingMarkers = /\b(might|could|perhaps|possibly|allegedly|reportedly|sources say|appears to|seems to|may have)\b/gi;
                
                patterns.certainty = (normalizedText.match(certaintyMarkers) || []).length;
                patterns.hedging = (normalizedText.match(hedgingMarkers) || []).length;
                
                // Emotional vs factual language
                const emotionalMarkers = /\b(outrageous|shocking|devastating|alarming|dangerous|disaster|crisis|betrayal|attack|defend|fight|slams|blasts|destroys)\b/gi;
                const factualMarkers = /\b(according to|data shows|study found|research indicates|statistics|analysis|report|survey)\b/gi;
                
                patterns.emotional = (normalizedText.match(emotionalMarkers) || []).length;
                patterns.factual = (normalizedText.match(factualMarkers) || []).length;
                
                // Find sentences with strong emotional or certainty language
                sentences.forEach(sentence => {
                    const sentenceLower = sentence.toLowerCase();
                    const emotionalMatches = (sentenceLower.match(emotionalMarkers) || []).length;
                    const certaintyMatches = (sentenceLower.match(certaintyMarkers) || []).length;
                    
                    if (emotionalMatches > 1 || certaintyMatches > 1) {
                        const biasStrength = emotionalMatches + certaintyMatches;
                        biasSentences.push({
                            text: sentence.trim(),
                            bias: 'emotional-language',
                            strength: biasStrength,
                            type: 'linguistic',
                            indicators: emotionalMatches > 0 ? 'emotional' : 'certainty'
                        });
                    }
                });
                
                return patterns;
            }

            // 3. SOURCE AND ATTRIBUTION ANALYSIS
            function analyzeSourcePatterns() {
                let sourceScore = 0;
                
                // Anonymous sources (can indicate speculation)
                const anonymousSources = /\b(sources say|unnamed official|according to sources|insiders report|leaked|off the record)\b/gi;
                const namedSources = /\b(said|stated|announced|declared|confirmed|according to [A-Z][a-z]+ [A-Z][a-z]+)\b/gi;
                
                const anonymousCount = (normalizedText.match(anonymousSources) || []).length;
                const namedCount = (normalizedText.match(namedSources) || []).length;
                
                // More anonymous sources may indicate less reliable reporting
                sourceScore = namedCount - (anonymousCount * 0.5);
                
                return { sourceScore, anonymousCount, namedCount };
            }

            // 4. ARGUMENT STRUCTURE ANALYSIS
            function analyzeArgumentStructure() {
                let structureScore = 0;
                
                // Look for balanced reporting indicators
                const balanceIndicators = /\b(however|but|on the other hand|meanwhile|in contrast|alternatively|critics argue|supporters say|both sides)\b/gi;
                const onesided = /\b(all|every|always|never|completely|totally|entirely|absolutely no|zero|none)\b/gi;
                
                const balanceCount = (normalizedText.match(balanceIndicators) || []).length;
                const onesidedCount = (normalizedText.match(onesided) || []).length;
                
                structureScore = balanceCount - (onesidedCount * 0.3);
                
                return { structureScore, balanceCount, onesidedCount };
            }

            // 5. TOPIC FRAMING ANALYSIS
            // Analyze how topics are framed and capture biased framing sentences
            function analyzeTopicFraming() {
                let framingBias = 0;
                
                // Economic framing
                const economicLeft = /\b(inequality|corporate greed|tax the rich|worker rights|minimum wage|wealth gap)\b/gi;
                const economicRight = /\b(job creators|free market|economic growth|business friendly|tax burden|regulation hurts)\b/gi;
                
                // Social framing  
                const socialLeft = /\b(social justice|systemic racism|reproductive rights|lgbtq rights|inclusion|equity)\b/gi;
                const socialRight = /\b(traditional values|family values|religious freedom|law and order|personal responsibility)\b/gi;
                
                // Government framing
                const govLeft = /\b(public investment|government programs|safety net|public option|infrastructure)\b/gi;
                const govRight = /\b(government overreach|bureaucracy|red tape|states rights|limited government)\b/gi;
                
                const leftFraming = (normalizedText.match(economicLeft) || []).length + 
                                  (normalizedText.match(socialLeft) || []).length +
                                  (normalizedText.match(govLeft) || []).length;
                
                const rightFraming = (normalizedText.match(economicRight) || []).length + 
                                   (normalizedText.match(socialRight) || []).length +
                                   (normalizedText.match(govRight) || []).length;
                
                framingBias = rightFraming - leftFraming;
                
                // Find sentences with strong framing language
                sentences.forEach(sentence => {
                    const sentenceLower = sentence.toLowerCase();
                    const leftMatches = (sentenceLower.match(economicLeft) || []).length +
                                       (sentenceLower.match(socialLeft) || []).length +
                                       (sentenceLower.match(govLeft) || []).length;
                    const rightMatches = (sentenceLower.match(economicRight) || []).length +
                                        (sentenceLower.match(socialRight) || []).length +
                                        (sentenceLower.match(govRight) || []).length;
                    
                    if (leftMatches > 0 || rightMatches > 0) {
                        const netBias = rightMatches - leftMatches;
                        if (Math.abs(netBias) > 0) {
                            biasSentences.push({
                                text: sentence.trim(),
                                bias: netBias > 0 ? 'right-framing' : 'left-framing',
                                strength: Math.abs(netBias),
                                type: 'framing'
                            });
                        }
                    }
                });
                
                return { framingBias, leftFraming, rightFraming };
            }

            // Execute all analyses
            const sentimentAnalysis = analyzeContextualSentiment();
            const linguisticPatterns = analyzeLinguisticPatterns();
            const sourcePatterns = analyzeSourcePatterns();
            const argumentStructure = analyzeArgumentStructure();
            const topicFraming = analyzeTopicFraming();

            // COMPOSITE SCORING
            // Weight different aspects of bias detection
            let biasScore = 0;
            
            // Contextual sentiment (40% weight) - most important
            const sentimentScore = sentimentAnalysis.rightSentiment - sentimentAnalysis.leftSentiment;
            biasScore += sentimentScore * 4;
            features.sentiment = sentimentScore;
            
            // Topic framing (25% weight)
            biasScore += topicFraming.framingBias * 2.5;
            features.framing = topicFraming.framingBias;
            
            // Linguistic patterns (20% weight)
            const linguisticBias = (linguisticPatterns.certainty - linguisticPatterns.hedging) + 
                                 (linguisticPatterns.emotional - linguisticPatterns.factual) * 0.5;
            biasScore += linguisticBias * 0.8;
            features.linguistic = linguisticBias;
            
            // Argument structure (10% weight) - lack of balance adds bias
            biasScore -= argumentStructure.structureScore * 0.5;
            features.structure = argumentStructure.structureScore;
            
            // Source reliability (5% weight)
            biasScore -= sourcePatterns.sourceScore * 0.2;
            features.sources = sourcePatterns.sourceScore;

            // Apply outlet prior (small influence)
            let outletPrior = 0;
            if (url) {
                try {
                    const hostname = new URL(url).hostname.toLowerCase().replace('www.', '');
                    outletPrior = OUTLET_PRIORS[hostname] || 0;
                    biasScore += outletPrior;
                } catch (error) {
                    // Invalid URL, no prior
                }
            }

            // Title analysis (1.5x multiplier)
            if (title) {
                const titleSentiment = title.toLowerCase();
                let titleBias = 0;
                
                // Check for loaded language in title
                if (/\b(slams|blasts|destroys|demolishes|attacks|hits|strikes)\b/.test(titleSentiment)) titleBias += 2;
                if (/\b(defends|supports|champions|stands up|fights for)\b/.test(titleSentiment)) titleBias -= 2;
                if (/\b(crisis|disaster|chaos|failure|threatens)\b/.test(titleSentiment)) titleBias += 1.5;
                if (/\b(progress|success|achievement|breakthrough|delivers)\b/.test(titleSentiment)) titleBias -= 1.5;
                
                biasScore += titleBias * 1.5;
                features.titleBias = titleBias;
            }

            // Normalize to [-100, 100] scale with natural curve
            // Use tanh for smooth natural scaling instead of hard caps
            const normalizedScore = Math.round(Math.tanh(biasScore / 15) * 100);
            
            // CONFIDENCE CALCULATION
            // Based on signal strength and content analysis depth
            const wordCount = text.split(/\s+/).length;
            const politicalDensity = evidenceTerms.length / Math.max(sentences.length, 1);
            const signalStrength = Math.abs(sentimentScore) + Math.abs(topicFraming.framingBias) + Math.abs(linguisticBias);
            
            let confidence = 0;
            confidence += Math.min(30, wordCount / 30); // Content length
            confidence += Math.min(25, politicalDensity * 200); // Political content density
            confidence += Math.min(20, signalStrength); // Signal strength
            confidence += Math.min(15, sourcePatterns.namedCount * 2); // Source quality
            confidence += Math.min(10, argumentStructure.balanceCount); // Reporting balance
            
            confidence = Math.round(Math.max(5, Math.min(100, confidence)));

            // Generate natural explanation
            const explanation = generateNaturalExplanation(normalizedScore, confidence, features, evidenceTerms);
            
            const analysis = {
                score: normalizedScore,
                confidence,
                explanation,
                evidence: evidenceTerms.slice(0, 8), // Top evidence
                biasSentences: biasSentences.sort((a, b) => b.strength - a.strength).slice(0, 5), // Top 5 biased sentences
                features,
                outletPrior,
                timing: Date.now() - startTime,
                rawScore: biasScore,
                wordCount,
                url,
                title
            };

            updateDevPanel(analysis);
            return analysis;
        }

        function generateNaturalExplanation(score, confidence, features, evidenceTerms) {
            let explanation = '';
            
            // Primary bias assessment
            if (Math.abs(score) < 10) {
                explanation = 'This article maintains relatively balanced reporting with neutral tone and framing.';
            } else if (score < -30) {
                explanation = 'This article displays strong liberal bias through sympathetic coverage of left-leaning positions and critical framing of conservative viewpoints.';
            } else if (score < -10) {
                explanation = 'This article shows moderate liberal bias with somewhat favorable treatment of progressive policies and politicians.';
            } else if (score > 30) {
                explanation = 'This article displays strong conservative bias through sympathetic coverage of right-leaning positions and critical framing of liberal viewpoints.';
            } else if (score > 10) {
                explanation = 'This article shows moderate conservative bias with somewhat favorable treatment of traditional policies and politicians.';
            }

            // Add specific reasoning based on strongest signals
            const sentimentSignal = Math.abs(features.sentiment || 0);
            const framingSignal = Math.abs(features.framing || 0);
            const linguisticSignal = Math.abs(features.linguistic || 0);

            if (sentimentSignal > framingSignal && sentimentSignal > linguisticSignal) {
                explanation += ' This is primarily driven by the emotional tone used when discussing political figures and policies.';
            } else if (framingSignal > linguisticSignal) {
                explanation += ' This bias appears mainly in how issues are framed and contextualized rather than explicit opinion.';
            } else if (linguisticSignal > 1) {
                explanation += ' The bias is evident in the certainty of language and emotional word choices used throughout.';
            }

            // Source and structure commentary
            if (features.sources && features.sources < -2) {
                explanation += ' Heavy reliance on anonymous sources may indicate speculative reporting.';
            } else if (features.structure && features.structure < -2) {
                explanation += ' The article lacks balanced perspectives from multiple viewpoints.';
            }

            // Confidence reasoning
            if (confidence < 40) {
                explanation += ' Confidence is low due to limited political content or weak bias indicators.';
            } else if (confidence > 80) {
                explanation += ' High confidence due to consistent bias patterns throughout the article.';
            }

            return explanation;
        }

        function updateDevPanel(analysis) {
            if (!analysis) return;
            
            elements.devProxy.textContent = analysis.proxy || 'N/A';
            elements.devFeatures.textContent = analysis.features ? 
                Object.entries(analysis.features).map(([k, v]) => `${k}: ${v.toFixed(1)}`).join(', ') : 'N/A';
            elements.devLexicon.textContent = analysis.evidence ? 
                `${analysis.evidence.length} contextual signals found` : 'N/A';
            elements.devOutlet.textContent = analysis.outletPrior ? 
                `${analysis.outletPrior > 0 ? '+' : ''}${analysis.outletPrior}` : '0';
            elements.devNorm.textContent = analysis.rawScore !== undefined ? 
                `Raw: ${analysis.rawScore.toFixed(1)} → Normalized: ${analysis.score}` : 'N/A';
            elements.devTiming.textContent = analysis.timing ? `${analysis.timing}ms` : 'N/A';
        }

        // Display results
        function displayResults(analysis) {
            currentAnalysis = analysis;
            
            // Update score display
            elements.scoreNumber.textContent = analysis.score > 0 ? `+${analysis.score}` : analysis.score;
            elements.scoreNumber.style.color = analysis.score > 0 ? 'var(--accent-red)' : 
                                               analysis.score < 0 ? 'var(--accent-blue)' : 'var(--text-primary)';
            
            elements.confidenceValue.textContent = analysis.confidence;
            
            // Update bias scale marker position
            const markerPosition = ((analysis.score + 100) / 200) * 100; // Convert [-100,100] to [0,100]%
            elements.scaleMarker.style.left = `${markerPosition}%`;
            
            // Update explanation
            elements.explanationText.textContent = analysis.explanation;
            
            // Update evidence chips
            if (analysis.evidence && analysis.evidence.length > 0) {
                elements.evidenceChips.innerHTML = analysis.evidence.map(item => {
                    const className = item.bias === 'left' ? 'negative' : 'positive';
                    const contextLabel = item.context === 'positive' ? '+' : item.context === 'negative' ? '-' : '';
                    return `<span class="evidence-chip ${className}">${item.term} ${contextLabel}</span>`;
                }).join('');
            } else {
                elements.evidenceChips.innerHTML = '<span class="evidence-chip">No significant evidence found</span>';
            }
            
            // Update bias sentences
            if (analysis.biasSentences && analysis.biasSentences.length > 0) {
                elements.biasSentencesList.innerHTML = analysis.biasSentences.map(sentence => {
                    let labelText = '';
                    switch (sentence.bias) {
                        case 'left-positive': labelText = 'Positive toward left'; break;
                        case 'left-negative': labelText = 'Negative toward left'; break;
                        case 'right-positive': labelText = 'Positive toward right'; break;
                        case 'right-negative': labelText = 'Negative toward right'; break;
                        case 'left-framing': labelText = 'Liberal framing'; break;
                        case 'right-framing': labelText = 'Conservative framing'; break;
                        case 'emotional-language': labelText = 'Emotional language'; break;
                        default: labelText = 'Biased language';
                    }
                    
                    return `
                        <div class="bias-sentence ${sentence.bias}">
                            <div class="sentence-label ${sentence.bias}">${labelText}</div>
                            <div class="sentence-text">"${sentence.text}"</div>
                        </div>
                    `;
                }).join('');
            } else {
                elements.biasSentencesList.innerHTML = '<div style="color: var(--text-muted); font-style: italic;">No clearly biased sentences detected</div>';
            }
            
            // Show results with animation
            elements.resultSection.style.display = 'block';
            setTimeout(() => {
                elements.resultSection.classList.add('visible');
            }, 100);
            
            // Save to history
            saveToStorage(analysis);
        }

        // Main analysis functions
        async function analyzeUrl() {
            const url = sanitizeUrl(elements.urlInput.value);
            if (!url) {
                showError('Please enter a valid URL');
                return;
            }

            setLoading(true);
            
            try {
                const html = await fetchWithProxies(url);
                const extracted = extractContent(html, url);
                
                if (!extracted.content || extracted.content.length < 100) {
                    throw new Error('Could not extract meaningful content from the page');
                }

                const analysis = analyzeBias(extracted.content, extracted.title, url);
                displayResults(analysis);
                
            } catch (error) {
                console.error('Analysis failed:', error);
                showError(`Failed to analyze URL: ${error.message}. Try using "Paste Article Text" instead.`);
            } finally {
                setLoading(false);
            }
        }

        async function analyzeText() {
            const text = elements.articleText.value.trim();
            if (!text || text.length < 50) {
                showError('Please paste article text (at least 50 characters)');
                return;
            }

            setLoading(true);
            
            try {
                const analysis = analyzeBias(text, '', 'Manual Text');
                displayResults(analysis);
            } catch (error) {
                console.error('Text analysis failed:', error);
                showError('Failed to analyze text. Please try again.');
            } finally {
                setLoading(false);
            }
        }

        // Event listeners
        elements.analyzeBtn.addEventListener('click', analyzeUrl);
        elements.analyzeTextBtn.addEventListener('click', analyzeText);

        // URL input handling
        elements.urlInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                analyzeUrl();
            }
        });

        // Collapsible text area
        document.querySelector('.collapsible-header').addEventListener('click', function() {
            const content = document.querySelector('.collapsible-content');
            const chevron = this.querySelector('.chevron');
            const isOpen = content.classList.contains('open');
            
            content.classList.toggle('open');
            chevron.textContent = isOpen ? '▼' : '▲';
            this.setAttribute('aria-expanded', !isOpen);
        });

        // Keyboard navigation for collapsible
        document.querySelector('.collapsible-header').addEventListener('keydown', function(event) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                this.click();
            }
        });

        // Dev panel toggle
        elements.aboutTitle.addEventListener('click', () => {
            devPanelTaps++;
            if (devPanelTaps >= 5) {
                devPanelVisible = !devPanelVisible;
                elements.devPanel.classList.toggle('visible', devPanelVisible);
                devPanelTaps = 0;
            }
            
            // Reset counter after 2 seconds
            setTimeout(() => {
                if (devPanelTaps < 5) devPanelTaps = 0;
            }, 2000);
        });

        // Initialize app
        function initApp() {
            renderHistory();
            
            // Hide results initially
            elements.resultSection.style.display = 'none';
            elements.resultSection.classList.remove('visible');
        }

        // Start the app
        initApp();
    </script>
</body>
</html>
