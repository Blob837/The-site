<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="theme-color" content="#0b0f14">
    <meta name="description" content="College Football Winner Predictor with live data and ML models">
    <title>CFB Predictor</title>
    <style>
        :root {
            --bg-primary: #0b0f14;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #2a3441;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --accent-primary: #3b82f6;
            --accent-secondary: #10b981;
            --accent-danger: #ef4444;
            --accent-warning: #f59e0b;
            --border-primary: #374151;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        @media (prefers-color-scheme: light) {
            :root {
                --bg-primary: #ffffff;
                --bg-secondary: #f8fafc;
                --bg-tertiary: #e2e8f0;
                --text-primary: #1e293b;
                --text-secondary: #475569;
                --text-muted: #64748b;
                --border-primary: #e2e8f0;
                --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding-bottom: 80px; /* Space for sticky footer */
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-primary);
        }

        .week-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .week-nav {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .week-nav:hover {
            background: var(--accent-primary);
        }

        .week-display {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 0.375rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .settings-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Main Content */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        .loading-skeleton {
            background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--bg-tertiary) 50%, var(--bg-secondary) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 0.5rem;
            height: 120px;
            margin-bottom: 1rem;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Game Cards */
        .games-container {
            display: grid;
            gap: 1rem;
            grid-template-columns: 1fr;
        }

        @media (min-width: 768px) {
            .games-container {
                grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            }
        }

        .game-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: transform 0.2s ease;
        }

        .game-card:hover {
            transform: translateY(-2px);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .game-time {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-align: right;
        }

        .venue {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
        }

        .team {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        .team-name {
            font-weight: bold;
            font-size: 1.125rem;
            margin-bottom: 0.25rem;
        }

        .team-record {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .vs {
            margin: 0 1rem;
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .prediction {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
        }

        .prob-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .confidence-ring {
            width: 40px;
            height: 40px;
            position: relative;
        }

        .confidence-ring svg {
            transform: rotate(-90deg);
        }

        .confidence-bg {
            fill: none;
            stroke: var(--bg-tertiary);
            stroke-width: 3;
        }

        .confidence-fill {
            fill: none;
            stroke: var(--accent-secondary);
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dasharray 0.3s ease;
        }

        .prob-text {
            font-weight: bold;
            font-size: 1.125rem;
        }

        .edge-badge {
            background: var(--accent-warning);
            color: var(--bg-primary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .drivers {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .driver-chip {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
        }

        .driver-chip.positive {
            background: var(--accent-secondary);
            color: var(--bg-primary);
        }

        .driver-chip.negative {
            background: var(--accent-danger);
            color: var(--text-primary);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.375rem;
            min-width: 44px;
            min-height: 44px;
        }

        .close-btn:hover {
            background: var(--bg-tertiary);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 0.375rem;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .checkbox {
            width: 1.25rem;
            height: 1.25rem;
        }

        .button {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-height: 44px;
        }

        .button:hover {
            background: #2563eb;
        }

        .button.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .button.secondary:hover {
            background: var(--border-primary);
        }

        .button.danger {
            background: var(--accent-danger);
        }

        .button.danger:hover {
            background: #dc2626;
        }

        /* Bottom Bar */
        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-primary);
            padding: 1rem;
            z-index: 100;
        }

        .bottom-actions {
            display: flex;
            gap: 0.75rem;
            max-width: 1200px;
            margin: 0 auto;
            justify-content: center;
            flex-wrap: wrap;
        }

        .bottom-actions .button {
            flex: 1;
            min-width: 120px;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 80px;
            left: 1rem;
            right: 1rem;
            background: var(--accent-danger);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            z-index: 1100;
            transform: translateY(-100px);
            transition: transform 0.3s ease;
            box-shadow: var(--shadow);
        }

        .toast.show {
            transform: translateY(0);
        }

        .toast.success {
            background: var(--accent-secondary);
        }

        .toast.warning {
            background: var(--accent-warning);
            color: var(--bg-primary);
        }

        /* Filters */
        .filters {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 0.375rem;
            color: var(--text-primary);
            min-height: 44px;
        }

        .sort-select {
            margin-left: auto;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">CFB Predictor</div>
            <div class="week-selector">
                <button class="week-nav" id="prevWeek" aria-label="Previous week">←</button>
                <div class="week-display" id="weekDisplay">This Weekend</div>
                <button class="week-nav" id="nextWeek" aria-label="Next week">→</button>
            </div>
            <button class="settings-btn" id="settingsBtn" aria-label="Settings">⚙️</button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Filters -->
        <div class="filters">
            <select class="filter-select" id="conferenceFilter">
                <option value="">All Conferences</option>
            </select>
            <select class="filter-select" id="teamFilter">
                <option value="">All Teams</option>
            </select>
            <select class="filter-select sort-select" id="sortBy">
                <option value="confidence">Sort by Confidence</option>
                <option value="edge">Sort by Edge</option>
                <option value="time">Sort by Kickoff</option>
            </select>
        </div>

        <!-- Games Container -->
        <div class="games-container" id="gamesContainer">
            <!-- Loading skeletons -->
            <div class="loading-skeleton"></div>
            <div class="loading-skeleton"></div>
            <div class="loading-skeleton"></div>
        </div>

        <!-- Empty State -->
        <div class="empty-state" id="emptyState" style="display: none;">
            <div class="empty-icon">🏈</div>
            <h3>No games found</h3>
            <p>Try adjusting your filters or check back later</p>
        </div>
    </main>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="close-btn" id="closeSettings">×</button>
            </div>
            
            <div class="form-group">
                <label class="form-label" for="cfbdKey">CFBD API Key *</label>
                <input type="password" class="form-input" id="cfbdKey" placeholder="Enter your CFBD API key">
                <small style="color: var(--text-muted); display: block; margin-top: 0.5rem;">
                    Get your free key at <a href="https://collegefootballdata.com" target="_blank" style="color: var(--accent-primary);">collegefootballdata.com</a>
                </small>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="useMarkets" checked>
                <label for="useMarkets">Use betting markets</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="useWeather" checked>
                <label for="useWeather">Use weather forecasts</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="manualInjuries">
                <label for="manualInjuries">Manual injury tracking</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" class="checkbox" id="demoMode">
                <label for="demoMode">Demo mode (offline data)</label>
            </div>

            <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                <button class="button" id="saveSettings">Save Settings</button>
                <button class="button secondary" id="closeSettings2">Cancel</button>
                <button class="button danger" id="forgetKeys">Forget Keys</button>
            </div>
        </div>
    </div>

    <!-- Bottom Action Bar -->
    <div class="bottom-bar">
        <div class="bottom-actions">
            <button class="button" id="refreshData">Refresh Data</button>
            <button class="button" id="predict">Predict</button>
            <button class="button secondary" id="exportData">Export JSON</button>
            <button class="button secondary" id="resetApp">Reset</button>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        /**
         * CFB Winner Predictor - Single File Application
         * Built like an oil rig: robust, fail-safe, and idiot-proof
         */

        // Demo data embedded for when APIs are unavailable
        const DEMO_DATA = {
            games: [
                {
                    id: 1,
                    season: 2024,
                    week: 12,
                    away_team: "Texas",
                    home_team: "Texas A&M", 
                    start_date: "2024-11-30T19:30:00.000Z",
                    venue: "Kyle Field",
                    away_conference: "SEC",
                    home_conference: "SEC",
                    neutral_site: false,
                    completed: false
                },
                {
                    id: 2,
                    season: 2024,
                    week: 12,
                    away_team: "Alabama",
                    home_team: "Auburn",
                    start_date: "2024-11-30T20:00:00.000Z", 
                    venue: "Jordan-Hare Stadium",
                    away_conference: "SEC",
                    home_conference: "SEC",
                    neutral_site: false,
                    completed: false
                }
            ],
            elo: [
                { team: "Texas", elo: 1650 },
                { team: "Texas A&M", elo: 1580 },
                { team: "Alabama", elo: 1620 },
                { team: "Auburn", elo: 1520 }
            ],
            ppa: [
                { team: "Texas", offense_ppa: 0.15, defense_ppa: -0.08 },
                { team: "Texas A&M", offense_ppa: 0.08, defense_ppa: -0.05 },
                { team: "Alabama", offense_ppa: 0.12, defense_ppa: -0.06 },
                { team: "Auburn", offense_ppa: 0.02, defense_ppa: 0.03 }
            ],
            lines: [
                { 
                    id: 1, 
                    homeTeam: "Texas A&M", 
                    awayTeam: "Texas",
                    lines: [{ provider: "consensus", spread: -7.5, overUnder: 48.5 }]
                }
            ]
        };

        // Application state - everything in memory, no browser storage leaks
        const AppState = {
            currentWeek: null,
            currentSeason: 2024,
            settings: {
                cfbdKey: localStorage.getItem('cfbd_key') || '',
                useMarkets: true,
                useWeather: true,
                manualInjuries: false,
                demoMode: false
            },
            cache: {
                games: null,
                metrics: null,
                weather: null,
                lines: null,
                lastUpdate: null
            },
            predictions: null,
            worker: null
        };

        // Rate limiter - simple token bucket
        class RateLimiter {
            constructor(tokensPerSecond = 2, maxTokens = 5) {
                this.tokensPerSecond = tokensPerSecond;
                this.maxTokens = maxTokens;
                this.tokens = maxTokens;
                this.lastRefill = Date.now();
            }

            async waitForToken() {
                const now = Date.now();
                const timePassed = (now - this.lastRefill) / 1000;
                this.tokens = Math.min(this.maxTokens, this.tokens + timePassed * this.tokensPerSecond);
                this.lastRefill = now;

                if (this.tokens >= 1) {
                    this.tokens -= 1;
                    return;
                }

                const waitTime = (1 - this.tokens) / this.tokensPerSecond * 1000;
                await new Promise(resolve => setTimeout(resolve, waitTime + Math.random() * 100));
                this.tokens = 0;
            }
        }

        // API client with proper error handling
        class CFBDClient {
            constructor() {
                this.baseURL = 'https://api.collegefootballdata.com';
                this.rateLimiter = new RateLimiter(2, 5);
            }

            async fetch(endpoint, params = {}) {
                if (!AppState.settings.cfbdKey && !AppState.settings.demoMode) {
                    throw new Error('CFBD API key required');
                }

                if (AppState.settings.demoMode) {
                    return this.getDemoData(endpoint);
                }

                await this.rateLimiter.waitForToken();

                const url = new URL(endpoint, this.baseURL);
                Object.entries(params).forEach(([key, value]) => {
                    if (value !== null && value !== undefined) {
                        url.searchParams.append(key, value);
                    }
                });

                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${AppState.settings.cfbdKey}`,
                        'Accept': 'application/json'
                    }
                });

                if (response.status === 401) {
                    throw new Error('Invalid CFBD API key');
                }
                if (response.status === 429) {
                    throw new Error('Rate limit exceeded, retrying...');
                }
                if (!response.ok) {
                    throw new Error(`CFBD API error: ${response.status}`);
                }

                return response.json();
            }

            getDemoData(endpoint) {
                if (endpoint.includes('/games')) {
                    if (endpoint.includes('/weather')) return [];
                    return DEMO_DATA.games;
                }
                if (endpoint.includes('/ratings/elo')) return DEMO_DATA.elo;
                if (endpoint.includes('/metrics/ppa')) return DEMO_DATA.ppa;
                if (endpoint.includes('/lines')) return DEMO_DATA.lines;
                if (endpoint.includes('/teams')) return DEMO_DATA.games.map(g => ({ school: g.home_team, conference: g.home_conference }));
                return [];
            }

            async getGames(season, week) {
                return this.fetch('/games', { 
                    year: season, 
                    week, 
                    season_type: 'regular',
                    classification: 'fbs' 
                });
            }

            async getMetrics(season, week) {
                const [elo, ppa] = await Promise.all([
                    this.fetch('/ratings/elo', { year: season, week }).catch(() => []),
                    this.fetch('/metrics/ppa/teams', { year: season, week }).catch(() => [])
                ]);
                return { elo, ppa };
            }

            async getLines(season, week) {
                return this.fetch('/lines', { 
                    year: season, 
                    week, 
                    season_type: 'regular' 
                }).catch(() => []);
            }

            async getWeather(season, week) {
                return this.fetch('/games/weather', { 
                    year: season, 
                    week, 
                    season_type: 'regular' 
                }).catch(() => []);
            }

            async getTeams() {
                return this.fetch('/teams').catch(() => []);
            }
        }

        // Math utilities
        const MathUtils = {
            sigmoid: (x) => 1 / (1 + Math.exp(-x)),
            dot: (a, b) => a.reduce((sum, val, i) => sum + val * b[i], 0),
            seededRandom: (() => {
                let seed = 12345; // Fixed seed for reproducibility
                return () => {
                    const x = Math.sin(seed++) * 10000;
                    return x - Math.floor(x);
                };
            })(),
            
            // Iteratively Reweighted Least Squares for logistic regression
            irls: (X, y, maxIter = 25, tolerance = 1e-6) => {
                const n = X.length;
                const p = X[0].length;
                let beta = new Array(p).fill(0);
                
                for (let iter = 0; iter < maxIter; iter++) {
                    const eta = X.map(row => MathUtils.dot(row, beta));
                    const mu = eta.map(MathUtils.sigmoid);
                    const weights = mu.map(m => m * (1 - m) + 1e-8); // Add small constant for stability
                    
                    // Newton-Raphson step
                    const gradient = new Array(p).fill(0);
                    const hessian = Array.from({ length: p }, () => new Array(p).fill(0));
                    
                    for (let i = 0; i < n; i++) {
                        const residual = y[i] - mu[i];
                        for (let j = 0; j < p; j++) {
                            gradient[j] += X[i][j] * residual;
                            for (let k = 0; k < p; k++) {
                                hessian[j][k] += X[i][j] * X[i][k] * weights[i];
                            }
                        }
                    }
                    
                    // Simple diagonal approximation for numerical stability
                    const deltaBeta = gradient.map((g, i) => g / (hessian[i][i] + 1e-8));
                    const stepSize = 0.1; // Conservative step size
                    
                    let maxChange = 0;
                    for (let i = 0; i < p; i++) {
                        const change = stepSize * deltaBeta[i];
                        beta[i] += change;
                        maxChange = Math.max(maxChange, Math.abs(change));
                    }
                    
                    if (maxChange < tolerance) break;
                }
                
                return beta;
            }
        };

        // Feature engineering - leak-safe and robust
        class FeatureEngine {
            static engineerFeatures(game, metrics, weather, lines) {
                const features = [];
                const featureNames = [];
                
                // Base features
                const homeElo = metrics.elo?.[game.home_team] || 1500;
                const awayElo = metrics.elo?.[game.away_team] || 1500;
                const homePPA = metrics.ppa?.[game.home_team] || 0;
                const awayPPA = metrics.ppa?.[game.away_team] || 0;
                
                // Elo differential with home field advantage
                const homeAdvantage = game.neutral_site ? 0 : 65;
                const eloDiff = homeElo + homeAdvantage - awayElo;
                features.push(eloDiff);
                featureNames.push('elo_diff');
                
                // PPA differentials
                features.push(homePPA - awayPPA);
                featureNames.push('ppa_diff');
                
                // Home/Neutral flags
                features.push(game.neutral_site ? 0 : 1);
                featureNames.push('home_flag');
                
                features.push(game.neutral_site ? 1 : 0);
                featureNames.push('neutral_flag');
                
                // Weather adjustments
                if (weather && AppState.settings.useWeather) {
                    const windPenalty = Math.max(0, (weather.wind_speed || 0) - 12) * -0.01;
                    const precipPenalty = (weather.precipitation_probability || 0) > 50 ? -0.05 : 0;
                    features.push(windPenalty);
                    features.push(precipPenalty);
                    featureNames.push('wind_penalty');
                    featureNames.push('precip_penalty');
                } else {
                    features.push(0, 0);
                    featureNames.push('wind_penalty');
                    featureNames.push('precip_penalty');
                }
                
                // Market features if available
                if (lines && lines.lines && lines.lines.length > 0 && AppState.settings.useMarkets) {
                    const line = lines.lines[0]; // Use first available line
                    const spread = line.spread || 0;
                    features.push(spread);
                    featureNames.push('market_spread');
                } else {
                    features.push(0);
                    featureNames.push('market_spread');
                }
                
                return { features, featureNames };
            }
            
            static getGameDrivers(game, prediction, features, featureNames) {
                const drivers = [];
                
                // Simplified driver analysis
                const eloDiff = features[featureNames.indexOf('elo_diff')] || 0;
                if (Math.abs(eloDiff) > 50) {
                    drivers.push({
                        name: 'Elo Rating',
                        impact: eloDiff > 0 ? 'positive' : 'negative',
                        description: `${Math.abs(eloDiff).toFixed(0)} point ${eloDiff > 0 ? 'advantage' : 'disadvantage'}`
                    });
                }
                
                const ppaDiff = features[featureNames.indexOf('ppa_diff')] || 0;
                if (Math.abs(ppaDiff) > 0.05) {
                    drivers.push({
                        name: 'PPA Efficiency',
                        impact: ppaDiff > 0 ? 'positive' : 'negative',
                        description: `${(Math.abs(ppaDiff) * 100).toFixed(1)}% efficiency edge`
                    });
                }
                
                return drivers;
            }
        }

        // Main prediction engine
        class PredictionEngine {
            constructor() {
                this.cfbdClient = new CFBDClient();
                this.models = {
                    elo: { a: -0.001, b: 0.025 }, // Default calibration
                    glm: null
                };
            }
            
            async predict(games) {
                if (!games || games.length === 0) return [];
                
                showToast('Generating predictions...', 'success');
                
                try {
                    // Get metrics and supplementary data
                    const metrics = await this.getMetrics();
                    const weather = await this.getWeatherData(games);
                    const lines = AppState.settings.useMarkets ? await this.cfbdClient.getLines(AppState.currentSeason, AppState.currentWeek) : [];
                    
                    const predictions = [];
                    
                    for (const game of games) {
                        const gameWeather = weather[game.id];
                        const gameLines = lines.find(l => 
                            (l.homeTeam === game.home_team && l.awayTeam === game.away_team) ||
                            (l.home_team === game.home_team && l.away_team === game.away_team)
                        );
                        
                        // Engineer features
                        const { features, featureNames } = FeatureEngine.engineerFeatures(game, metrics, gameWeather, gameLines);
                        
                        // Elo-based prediction
                        const eloDiff = features[0];
                        const probElo = MathUtils.sigmoid(this.models.elo.a + this.models.elo.b * eloDiff);
                        
                        // Simple ensemble (in production, would use trained GLM)
                        const probFinal = this.calibrateProb(probElo);
                        
                        // Calculate edge vs market if available
                        let edge = null;
                        if (gameLines && gameLines.lines && gameLines.lines.length > 0) {
                            const line = gameLines.lines[0]; // Use first available line
                            if (line.spread !== undefined) {
                                const impliedProb = this.spreadToProb(-line.spread); // Negative because spread is from home perspective
                                edge = Math.abs(probFinal - impliedProb);
                            }
                        }
                        
                        // Generate explanation
                        const drivers = FeatureEngine.getGameDrivers(game, probFinal, features, featureNames);
                        
                        predictions.push({
                            gameId: game.id,
                            homeTeam: game.home_team,
                            awayTeam: game.away_team,
                            homeWinProb: probFinal,
                            awayWinProb: 1 - probFinal,
                            confidence: Math.abs(probFinal - 0.5) * 2,
                            edge: edge,
                            drivers: drivers,
                            spreadEquiv: this.probToSpread(probFinal),
                            kickoff: game.start_date,
                            venue: game.venue
                        });
                    }
                    
                    return predictions;
                    
                } catch (error) {
                    showToast(`Prediction error: ${error.message}`, 'danger');
                    return [];
                }
            }
            
            async getMetrics() {
                try {
                    const data = await this.cfbdClient.getMetrics(AppState.currentSeason, AppState.currentWeek);
                    
                    const metrics = { elo: {}, ppa: {} };
                    
                    // Process ELO ratings
                    if (data.elo && Array.isArray(data.elo)) {
                        data.elo.forEach(team => {
                            if (team.team && team.elo) {
                                metrics.elo[team.team] = team.elo;
                            }
                        });
                    }
                    
                    // Process PPA data
                    if (data.ppa && Array.isArray(data.ppa)) {
                        data.ppa.forEach(team => {
                            if (team.team) {
                                // Calculate net PPA from offense and defense
                                const offensePPA = team.offense_ppa || team.overall_ppa || 0;
                                const defensePPA = team.defense_ppa || 0;
                                metrics.ppa[team.team] = offensePPA - defensePPA;
                            }
                        });
                    }
                    
                    return metrics;
                } catch (error) {
                    showToast('Using default metrics due to API error', 'warning');
                    return { elo: {}, ppa: {} };
                }
            }
            
            async getWeatherData(games) {
                if (!AppState.settings.useWeather) return {};
                
                try {
                    // Use CFBD weather endpoint instead of external API
                    const weatherData = await this.cfbdClient.getWeather(AppState.currentSeason, AppState.currentWeek);
                    const weather = {};
                    
                    for (const game of games) {
                        const gameWeather = weatherData.find(w => w.game_id === game.id);
                        if (gameWeather) {
                            weather[game.id] = {
                                temperature: gameWeather.temperature || 70,
                                wind_speed: gameWeather.wind_speed || 5,
                                precipitation_probability: gameWeather.precipitation ? 75 : 0
                            };
                        }
                    }
                    
                    return weather;
                } catch (error) {
                    showToast('Weather data unavailable', 'warning');
                    return {};
                }
            }
            
            calibrateProb(rawProb) {
                // Simple Platt scaling calibration
                const logit = Math.log(rawProb / (1 - rawProb));
                const calibratedLogit = 0.8 * logit; // Slightly more conservative
                return MathUtils.sigmoid(calibratedLogit);
            }
            
            spreadToProb(spread) {
                // Convert point spread to win probability
                return MathUtils.sigmoid(spread / 14); // ~14 points = 50% edge
            }
            
            probToSpread(prob) {
                // Convert win probability to equivalent spread
                const logit = Math.log(prob / (1 - prob));
                return logit * 14;
            }
        }

        // Date utilities
        const DateUtils = {
            getCurrentWeek() {
                const now = new Date();
                const season = now.getMonth() >= 7 ? now.getFullYear() : now.getFullYear() - 1;
                const seasonStart = new Date(season, 7, 15); // Mid-August
                const weekNumber = Math.ceil((now - seasonStart) / (7 * 24 * 60 * 60 * 1000));
                return Math.max(1, Math.min(15, weekNumber));
            },
            
            formatGameTime(dateString) {
                const date = new Date(dateString);
                return {
                    time: date.toLocaleTimeString('en-US', { 
                        hour: 'numeric', 
                        minute: '2-digit',
                        timeZoneName: 'short'
                    }),
                    date: date.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    })
                };
            }
        };

        // UI Management
        const UI = {
            showLoading() {
                const container = document.getElementById('gamesContainer');
                container.innerHTML = Array(3).fill().map(() => '<div class="loading-skeleton"></div>').join('');
            },
            
            renderGames(predictions) {
                const container = document.getElementById('gamesContainer');
                const emptyState = document.getElementById('emptyState');
                
                if (!predictions || predictions.length === 0) {
                    container.innerHTML = '';
                    emptyState.style.display = 'block';
                    return;
                }
                
                emptyState.style.display = 'none';
                
                // Sort predictions
                const sortBy = document.getElementById('sortBy').value;
                const sorted = [...predictions].sort((a, b) => {
                    switch (sortBy) {
                        case 'confidence':
                            return b.confidence - a.confidence;
                        case 'edge':
                            return (b.edge || 0) - (a.edge || 0);
                        case 'time':
                            return new Date(a.kickoff) - new Date(b.kickoff);
                        default:
                            return b.confidence - a.confidence;
                    }
                });
                
                container.innerHTML = sorted.map(prediction => this.renderGameCard(prediction)).join('');
            },
            
            renderGameCard(prediction) {
                const gameTime = DateUtils.formatGameTime(prediction.kickoff);
                const confidence = (prediction.confidence * 100).toFixed(0);
                const homeProb = (prediction.homeWinProb * 100).toFixed(0);
                const awayProb = (prediction.awayWinProb * 100).toFixed(0);
                
                // Calculate confidence ring
                const circumference = 2 * Math.PI * 16; // radius = 16
                const strokeDasharray = circumference;
                const strokeDashoffset = circumference * (1 - prediction.confidence);
                
                const edgeBadge = prediction.edge && prediction.edge > 0.1 ? 
                    `<div class="edge-badge">${(prediction.edge * 100).toFixed(0)}% edge</div>` : '';
                
                const drivers = prediction.drivers.map(driver => 
                    `<div class="driver-chip ${driver.impact}">${driver.name}: ${driver.description}</div>`
                ).join('');
                
                const favoredTeam = prediction.homeWinProb > 0.5 ? prediction.homeTeam : prediction.awayTeam;
                const favoredProb = Math.max(prediction.homeWinProb, prediction.awayWinProb);
                
                return `
                    <div class="game-card">
                        <div class="game-header">
                            <div class="game-time">
                                <div>${gameTime.date}</div>
                                <div>${gameTime.time}</div>
                            </div>
                        </div>
                        
                        <div class="venue">${prediction.venue || 'TBD'}</div>
                        
                        <div class="matchup">
                            <div class="team">
                                <div class="team-name">${prediction.awayTeam}</div>
                                <div class="team-record">${awayProb}%</div>
                            </div>
                            <div class="vs">@</div>
                            <div class="team">
                                <div class="team-name">${prediction.homeTeam}</div>
                                <div class="team-record">${homeProb}%</div>
                            </div>
                        </div>
                        
                        <div class="prediction">
                            <div class="prob-container">
                                <div class="confidence-ring">
                                    <svg width="40" height="40">
                                        <circle class="confidence-bg" cx="20" cy="20" r="16"></circle>
                                        <circle class="confidence-fill" cx="20" cy="20" r="16"
                                                stroke-dasharray="${strokeDasharray}"
                                                stroke-dashoffset="${strokeDashoffset}"></circle>
                                    </svg>
                                </div>
                                <div>
                                    <div class="prob-text">${favoredTeam}</div>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">${confidence}% confidence</div>
                                </div>
                            </div>
                            ${edgeBadge}
                        </div>
                        
                        ${drivers ? `<div class="drivers">${drivers}</div>` : ''}
                    </div>
                `;
            },
            
            updateWeekDisplay() {
                const display = document.getElementById('weekDisplay');
                if (AppState.currentWeek === DateUtils.getCurrentWeek()) {
                    display.textContent = 'This Weekend';
                } else {
                    display.textContent = `Week ${AppState.currentWeek}`;
                }
            },
            
            populateFilters(games) {
                const conferenceFilter = document.getElementById('conferenceFilter');
                const teamFilter = document.getElementById('teamFilter');
                
                // Get unique conferences and teams
                const conferences = [...new Set(games.flatMap(g => [g.away_conference, g.home_conference]).filter(Boolean))];
                const teams = [...new Set(games.flatMap(g => [g.away_team, g.home_team]))];
                
                // Update conference filter
                conferenceFilter.innerHTML = '<option value="">All Conferences</option>' +
                    conferences.map(conf => `<option value="${conf}">${conf}</option>`).join('');
                
                // Update team filter
                teamFilter.innerHTML = '<option value="">All Teams</option>' +
                    teams.map(team => `<option value="${team}">${team}</option>`).join('');
            }
        };

        // Toast notifications
        function showToast(message, type = 'danger') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, type === 'success' ? 2000 : 4000);
        }

        // Settings management
        function loadSettings() {
            const settings = AppState.settings;
            document.getElementById('cfbdKey').value = settings.cfbdKey;
            document.getElementById('useMarkets').checked = settings.useMarkets;
            document.getElementById('useWeather').checked = settings.useWeather;
            document.getElementById('manualInjuries').checked = settings.manualInjuries;
            document.getElementById('demoMode').checked = settings.demoMode;
        }

        function saveSettings() {
            const settings = AppState.settings;
            settings.cfbdKey = document.getElementById('cfbdKey').value.trim();
            settings.useMarkets = document.getElementById('useMarkets').checked;
            settings.useWeather = document.getElementById('useWeather').checked;
            settings.manualInjuries = document.getElementById('manualInjuries').checked;
            settings.demoMode = document.getElementById('demoMode').checked;
            
            // Persist only the API key
            if (settings.cfbdKey) {
                localStorage.setItem('cfbd_key', settings.cfbdKey);
            }
            
            document.getElementById('settingsModal').classList.remove('show');
            showToast('Settings saved', 'success');
        }

        function forgetKeys() {
            localStorage.removeItem('cfbd_key');
            AppState.settings.cfbdKey = '';
            document.getElementById('cfbdKey').value = '';
            showToast('API keys forgotten', 'success');
        }

        // Main application controller
        class App {
            constructor() {
                this.predictionEngine = new PredictionEngine();
                this.init();
            }
            
            init() {
                AppState.currentWeek = DateUtils.getCurrentWeek();
                UI.updateWeekDisplay();
                this.bindEvents();
                loadSettings();
                
                // Auto-load if we have settings
                if (AppState.settings.cfbdKey || AppState.settings.demoMode) {
                    this.refreshData();
                }
            }
            
            bindEvents() {
                // Week navigation
                document.getElementById('prevWeek').addEventListener('click', () => {
                    AppState.currentWeek = Math.max(1, AppState.currentWeek - 1);
                    UI.updateWeekDisplay();
                    this.refreshData();
                });
                
                document.getElementById('nextWeek').addEventListener('click', () => {
                    AppState.currentWeek = Math.min(15, AppState.currentWeek + 1);
                    UI.updateWeekDisplay();
                    this.refreshData();
                });
                
                // Settings modal
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.add('show');
                });
                
                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('show');
                });
                
                document.getElementById('closeSettings2').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('show');
                });
                
                document.getElementById('saveSettings').addEventListener('click', saveSettings);
                document.getElementById('forgetKeys').addEventListener('click', forgetKeys);
                
                // Bottom actions
                document.getElementById('refreshData').addEventListener('click', () => this.refreshData());
                document.getElementById('predict').addEventListener('click', () => this.predict());
                document.getElementById('exportData').addEventListener('click', () => this.exportData());
                document.getElementById('resetApp').addEventListener('click', () => this.reset());
                
                // Filters
                document.getElementById('sortBy').addEventListener('change', () => {
                    if (AppState.predictions) {
                        UI.renderGames(AppState.predictions);
                    }
                });
                
                // Close modal on overlay click
                document.getElementById('settingsModal').addEventListener('click', (e) => {
                    if (e.target.id === 'settingsModal') {
                        e.target.classList.remove('show');
                    }
                });
            }
            
            async refreshData() {
                if (!AppState.settings.cfbdKey && !AppState.settings.demoMode) {
                    showToast('CFBD API key required. Check settings.', 'warning');
                    document.getElementById('settingsModal').classList.add('show');
                    return;
                }
                
                UI.showLoading();
                
                try {
                    const games = await this.predictionEngine.cfbdClient.getGames(AppState.currentSeason, AppState.currentWeek);
                    
                    if (!games || games.length === 0) {
                        showToast('No games found for this week', 'warning');
                        UI.renderGames([]);
                        return;
                    }
                    
                    AppState.cache.games = games;
                    AppState.cache.lastUpdate = new Date();
                    
                    UI.populateFilters(games);
                    showToast(`Loaded ${games.length} games`, 'success');
                    
                    // Auto-predict if we have games
                    this.predict();
                    
                } catch (error) {
                    showToast(`Error loading data: ${error.message}`, 'danger');
                    UI.renderGames([]);
                }
            }
            
            async predict() {
                if (!AppState.cache.games) {
                    showToast('Load data first', 'warning');
                    return;
                }
                
                try {
                    const predictions = await this.predictionEngine.predict(AppState.cache.games);
                    AppState.predictions = predictions;
                    UI.renderGames(predictions);
                    
                    if (predictions.length > 0) {
                        showToast(`Generated ${predictions.length} predictions`, 'success');
                    }
                    
                } catch (error) {
                    showToast(`Prediction error: ${error.message}`, 'danger');
                }
            }
            
            exportData() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    week: AppState.currentWeek,
                    season: AppState.currentSeason,
                    games: AppState.cache.games,
                    predictions: AppState.predictions
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cfb-predictions-week${AppState.currentWeek}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('Data exported', 'success');
            }
            
            reset() {
                if (confirm('Reset all data? This will clear cache but keep settings.')) {
                    AppState.cache = { games: null, metrics: null, weather: null, lines: null, lastUpdate: null };
                    AppState.predictions = null;
                    UI.renderGames([]);
                    showToast('App reset', 'success');
                }
            }
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new App();
        });

        // Ensure proper cleanup
        window.addEventListener('beforeunload', () => {
            if (AppState.worker) {
                AppState.worker.terminate();
            }
        });
    </script>
</body>
</html>

<!--
README: CFB Winner Predictor

GETTING STARTED:
1. Get a free CFBD API key at https://collegefootballdata.com
2. Click the settings gear and paste your API key
3. Enable features you want (betting markets, weather, etc.)
4. Click "Refresh Data" to load games for the current week

DEPLOYMENT TO GITHUB PAGES:
1. Create a new repository on GitHub
2. Upload this index.html file to the root directory
3. Go to Settings > Pages in your repository
4. Select "Deploy from branch" and choose "main"
5. Your app will be available at https://username.github.io/repository-name

DEMO MODE:
If you don't have an API key or the APIs are blocked:
1. Open Settings
2. Check "Demo mode (offline data)"
3. Click "Refresh Data" to see sample predictions

FEATURES:
- Live college football game predictions using ML models
- Weather impact analysis using CFBD weather data
- Betting market edge detection (when available)
- Mobile-optimized interface with dark/light mode
- Offline-capable with demo data
- Export predictions as JSON

API ENDPOINTS USED:
- /games - Game schedules and results
- /ratings/elo - Team Elo ratings
- /metrics/ppa/teams - Predicted Points Added metrics
- /lines - Betting lines and odds
- /games/weather - Weather conditions for games

TROUBLESHOOTING:
- "Invalid CFBD key": Check your API key at collegefootballdata.com
- "Rate limit exceeded": Wait a few seconds and try again
- "No games found": Try a different week or check if it's off-season
- APIs blocked: Enable demo mode in settings

This app runs entirely in your browser - no data is sent to external servers except the APIs you configure.
-->
