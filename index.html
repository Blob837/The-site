<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>BiasLens - AI-Powered Bias Detection</title>
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --bg-card: #1e1e3f;
            --text-primary: #ffffff;
            --text-secondary: #b4b4d1;
            --text-muted: #8b8ba7;
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #10b981;
            --accent-orange: #f59e0b;
            --border-primary: #2d2d5a;
            --border-secondary: #3a3a6b;
            --glow-primary: rgba(99, 102, 241, 0.4);
            --glow-secondary: rgba(59, 130, 246, 0.3);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --gradient-accent: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --shadow-card: 0 10px 40px rgba(0, 0, 0, 0.4);
            --shadow-button: 0 4px 20px rgba(99, 102, 241, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, sans-serif;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-top: env(safe-area-inset-top, 20px);
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: var(--gradient-primary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            color: white;
            box-shadow: var(--shadow-button);
        }

        .title {
            font-size: 32px;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 16px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .main-card {
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow: var(--shadow-card);
            backdrop-filter: blur(10px);
        }

        .input-section {
            margin-bottom: 24px;
        }

        .input-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            display: block;
        }

        .input-group {
            position: relative;
            margin-bottom: 20px;
        }

        .input-field {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid var(--border-primary);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            font-family: inherit;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 4px var(--glow-primary);
        }

        .input-field::placeholder {
            color: var(--text-muted);
        }

        .btn {
            width: 100%;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            -webkit-tap-highlight-color: transparent;
            font-family: inherit;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: var(--shadow-button);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-secondary);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .collapsible {
            margin-bottom: 20px;
        }

        .collapsible-header {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .collapsible-header:hover {
            background: var(--bg-secondary);
            border-color: var(--border-secondary);
        }

        .chevron {
            transition: transform 0.3s ease;
            color: var(--accent-primary);
        }

        .collapsible-header[aria-expanded="true"] .chevron {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.open {
            max-height: 600px;
        }

        .collapsible-inner {
            padding: 20px;
            border: 1px solid var(--border-primary);
            border-top: none;
            border-radius: 0 0 12px 12px;
            background: var(--bg-secondary);
        }

        .textarea {
            width: 100%;
            min-height: 120px;
            padding: 16px;
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            resize: vertical;
            font-family: inherit;
            transition: border-color 0.3s ease;
        }

        .textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .result-card {
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow: var(--shadow-card);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s ease;
            backdrop-filter: blur(10px);
        }

        .result-card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .score-section {
            text-align: center;
            margin-bottom: 32px;
        }

        .score-number {
            font-size: 64px;
            font-weight: 800;
            margin-bottom: 8px;
            line-height: 1;
        }

        .score-label {
            font-size: 16px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .bias-scale {
            position: relative;
            height: 50px;
            background: linear-gradient(90deg, #3b82f6 0%, #6b7280 50%, #ef4444 100%);
            border-radius: 25px;
            margin: 32px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .scale-ticks {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
        }

        .scale-tick {
            width: 3px;
            height: 25px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 2px;
        }

        .scale-marker {
            position: absolute;
            top: 50%;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: left 1s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            border: 3px solid var(--bg-card);
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 12px;
            font-weight: 500;
        }

        .explanation-section {
            margin-top: 24px;
        }

        .section-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .explanation-text {
            font-size: 15px;
            line-height: 1.7;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        .evidence-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 24px;
        }

        .evidence-chip {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 20px;
            padding: 8px 14px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }

        .evidence-chip.positive {
            border-color: var(--accent-red);
            color: var(--accent-red);
            background: rgba(239, 68, 68, 0.1);
        }

        .evidence-chip.negative {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.1);
        }

        .bias-sentences {
            margin-top: 24px;
        }

        .bias-sentence {
            background: var(--bg-secondary);
            border-left: 4px solid var(--border-secondary);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .bias-sentence:hover {
            background: var(--bg-tertiary);
        }

        .bias-sentence.left-positive {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.08);
        }

        .bias-sentence.left-negative {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.08);
        }

        .bias-sentence.right-positive {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.08);
        }

        .bias-sentence.right-negative {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.08);
        }

        .bias-sentence.left-framing {
            border-left-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.08);
        }

        .bias-sentence.right-framing {
            border-left-color: var(--accent-red);
            background: rgba(239, 68, 68, 0.08);
        }

        .bias-sentence.emotional-language {
            border-left-color: var(--accent-orange);
            background: rgba(245, 158, 11, 0.08);
        }

        .sentence-label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .sentence-label.left-positive { color: var(--accent-blue); }
        .sentence-label.left-negative { color: var(--accent-red); }
        .sentence-label.right-positive { color: var(--accent-red); }
        .sentence-label.right-negative { color: var(--accent-blue); }
        .sentence-label.left-framing { color: var(--accent-blue); }
        .sentence-label.right-framing { color: var(--accent-red); }
        .sentence-label.emotional-language { color: var(--accent-orange); }

        .sentence-text {
            font-size: 14px;
            line-height: 1.6;
            font-style: italic;
        }

        .history-section {
            margin-bottom: 32px;
        }

        .history-card {
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow-card);
        }

        .history-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
            transform: translateX(4px);
        }

        .history-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .history-score {
            font-weight: 700;
            font-size: 16px;
        }

        .history-time {
            font-size: 12px;
            color: var(--text-muted);
        }

        .history-url {
            font-size: 13px;
            color: var(--text-secondary);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            color: var(--accent-red);
            text-align: center;
            font-weight: 500;
        }

        .about-section {
            background: var(--bg-card);
            border: 1px solid var(--border-primary);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 32px;
            box-shadow: var(--shadow-card);
        }

        .about-title {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .about-title::after {
            content: "🤖";
            font-size: 16px;
        }

        .dev-panel {
            background: var(--bg-primary);
            border: 2px solid var(--accent-green);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .dev-panel.visible {
            display: block;
        }

        .dev-section {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-primary);
        }

        .dev-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .dev-label {
            color: var(--accent-green);
            font-weight: bold;
            display: block;
            margin-bottom: 4px;
        }

        .safe-area-bottom {
            height: env(safe-area-inset-bottom, 20px);
        }

        /* iOS specific optimizations */
        @supports (-webkit-touch-callout: none) {
            .input-field {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus indicators */
        .btn:focus,
        .input-field:focus,
        .collapsible-header:focus,
        .history-item:focus {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        /* Mobile responsiveness */
        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }
            
            .main-card {
                padding: 24px;
            }
            
            .title {
                font-size: 28px;
            }
            
            .score-number {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon">BL</div>
                <div>
                    <h1 class="title">BiasLens</h1>
                    <p class="subtitle">AI-Powered Media Bias Detection</p>
                </div>
            </div>
        </header>

        <main>
            <div class="main-card">
                <div class="input-section">
                    <label for="url-input" class="input-label">Article URL</label>
                    <div class="input-group">
                        <input 
                            type="url" 
                            id="url-input" 
                            class="input-field" 
                            placeholder="https://example.com/news-article" 
                            aria-describedby="url-help"
                        >
                    </div>
                    <button id="analyze-btn" class="btn btn-primary" aria-describedby="analyze-help">
                        <span id="analyze-text">Analyze with AI</span>
                        <span id="analyze-loading" class="loading" style="display: none;" aria-hidden="true"></span>
                    </button>
                    <div id="url-help" class="sr-only">Enter the URL of a news article to analyze for political bias</div>
                    <div id="analyze-help" class="sr-only">Click to start AI bias analysis</div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" tabindex="0" role="button" aria-expanded="false" aria-controls="paste-content">
                        <span>Alternative: Paste Article Text</span>
                        <span class="chevron">▼</span>
                    </div>
                    <div class="collapsible-content" id="paste-content">
                        <div class="collapsible-inner">
                            <label for="article-text" class="input-label">Article Content</label>
                            <textarea 
                                id="article-text" 
                                class="textarea" 
                                placeholder="Paste the full article text here for direct analysis..."
                                aria-label="Article text for manual analysis"
                            ></textarea>
                            <button id="analyze-text-btn" class="btn btn-secondary" style="margin-top: 16px;">
                                Analyze Text
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="error-container"></div>

            <div id="result-section" class="result-card" style="display: none;" role="region" aria-label="Analysis results">
                <div class="score-section">
                    <div id="score-number" class="score-number" aria-label="Bias score">0</div>
                    <div class="score-label">Political Bias Score</div>
                </div>
                
                <div class="bias-scale" role="img" aria-label="Political bias scale">
                    <div class="scale-ticks">
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                        <div class="scale-tick"></div>
                    </div>
                    <div id="scale-marker" class="scale-marker"></div>
                </div>
                <div class="scale-labels">
                    <span>Liberal -100</span>
                    <span>-50</span>
                    <span>Neutral</span>
                    <span>+50</span>
                    <span>Conservative +100</span>
                </div>

                <div class="explanation-section">
                    <h3 class="section-title">AI Analysis</h3>
                    <div id="explanation-text" class="explanation-text"></div>
                    <div id="evidence-chips" class="evidence-chips" aria-label="Evidence keywords"></div>
                    
                    <div class="bias-sentences">
                        <h3 class="section-title">Key Evidence Sentences</h3>
                        <div id="bias-sentences-list" aria-label="Sentences that demonstrate bias"></div>
                    </div>
                </div>
            </div>

            <div class="history-section">
                <div class="history-card">
                    <h2 class="section-title">Recent Analyses</h2>
                    <div id="history-list" aria-label="Analysis history">
                        <p id="no-history" class="history-item" style="opacity: 0.6; cursor: default; text-align: center;">No analyses yet - try analyzing your first article!</p>
                    </div>
                </div>
            </div>

            <div class="about-section">
                <h2 class="section-title about-title" id="about-title">How BiasLens Works</h2>
                <p style="font-size: 14px; line-height: 1.7; color: var(--text-secondary);">
                    BiasLens uses advanced natural language processing to analyze news articles for political bias. 
                    Our AI examines contextual sentiment around political entities, linguistic patterns, argument structure, 
                    source attribution, and topic framing to estimate bias on a liberal-conservative scale. The analysis focuses 
                    on <em>how</em> things are said rather than just <em>what</em> is said. 
                    <strong>Results are AI estimates</strong> - always use your critical thinking.
                </p>
                
                <div id="dev-panel" class="dev-panel">
                    <div class="dev-section">
                        <span class="dev-label">Proxy Used:</span>
                        <div id="dev-proxy">None</div>
                    </div>
                    <div class="dev-section">
                        <span class="dev-label">Feature Scores:</span>
                        <div id="dev-features">N/A</div>
                    </div>
                    <div class="dev-section">
                        <span class="dev-label">Evidence Signals:</span>
                        <div id="dev-lexicon">N/A</div>
                    </div>
                    <div class="dev-section">
                        <span class="dev-label">Outlet Prior:</span>
                        <div id="dev-outlet">N/A</div>
                    </div>
                    <div class="dev-section">
                        <span class="dev-label">Score Normalization:</span>
                        <div id="dev-norm">N/A</div>
                    </div>
                    <div class="dev-section">
                        <span class="dev-label">Processing Time:</span>
                        <div id="dev-timing">N/A</div>
                    </div>
                </div>
            </div>
        </main>

        <div class="safe-area-bottom"></div>
    </div>

    <script>
        'use strict';

        // Configuration
        const CONFIG = {
            maxWordCount: 2500,
            proxyTimeout: 7000,
            maxRetries: 3,
            storageVersion: 1,
            storageKey: 'biaslens_v1',
            maxHistoryItems: 5
        };

        // CORS Proxy rotation - Add more proxies as needed
        const PROXIES = [
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/',
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/'
        ];

        // Outlet bias priors (small influence, max ±8)
        const OUTLET_PRIORS = {
            'cnn.com': -5,
            'msnbc.com': -6,
            'nytimes.com': -3,
            'washingtonpost.com': -3,
            'huffpost.com': -7,
            'foxnews.com': 6,
            'breitbart.com': 8,
            'dailywire.com': 7,
            'nypost.com': 4,
            'wsj.com': 2,
            'reuters.com': 0,
            'ap.org': 0,
            'apnews.com': 0,
            'bbc.com': -1,
            'npr.org': -2
        };

        // Application state
        let currentAnalysis = null;
        let devPanelTaps = 0;
        let devPanelVisible = false;

        // DOM elements
        const elements = {
            urlInput: document.getElementById('url-input'),
            analyzeBtn: document.getElementById('analyze-btn'),
            analyzeText: document.getElementById('analyze-text'),
            analyzeLoading: document.getElementById('analyze-loading'),
            articleText: document.getElementById('article-text'),
            analyzeTextBtn: document.getElementById('analyze-text-btn'),
            errorContainer: document.getElementById('error-container'),
            resultSection: document.getElementById('result-section'),
            scoreNumber: document.getElementById('score-number'),
            scaleMarker: document.getElementById('scale-marker'),
            explanationText: document.getElementById('explanation-text'),
            evidenceChips: document.getElementById('evidence-chips'),
            biasSentencesList: document.getElementById('bias-sentences-list'),
            historyList: document.getElementById('history-list'),
            noHistory: document.getElementById('no-history'),
            aboutTitle: document.getElementById('about-title'),
            devPanel: document.getElementById('dev-panel'),
            devProxy: document.getElementById('dev-proxy'),
            devFeatures: document.getElementById('dev-features'),
            devLexicon: document.getElementById('dev-lexicon'),
            devOutlet: document.getElementById('dev-outlet'),
            devNorm: document.getElementById('dev-norm'),
            devTiming: document.getElementById('dev-timing')
        };

        // Utility functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function isValidUrl(string) {
            try {
                const url = new URL(string);
                return ['http:', 'https:'].includes(url.protocol);
            } catch {
                return false;
            }
        }

        function sanitizeUrl(url) {
            if (!url) return null;
            url = url.trim();
            if (!url.startsWith('http')) {
                url = 'https://' + url;
            }
            return isValidUrl(url) ? url : null;
        }

        function showError(message) {
            elements.errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
            setTimeout(() => {
                elements.errorContainer.innerHTML = '';
            }, 5000);
        }

        function setLoading(isLoading) {
            elements.analyzeBtn.disabled = isLoading;
            elements.analyzeTextBtn.disabled = isLoading;
            elements.analyzeText.style.display = isLoading ? 'none' : 'inline';
            elements.analyzeLoading.style.display = isLoading ? 'inline-block' : 'none';
        }

        // Storage functions
        function saveToStorage(analysis) {
            try {
                const stored = localStorage.getItem(CONFIG.storageKey);
                let history = stored ? JSON.parse(stored) : { version: CONFIG.storageVersion, analyses: [] };
                
                if (history.version !== CONFIG.storageVersion) {
                    history = { version: CONFIG.storageVersion, analyses: [] };
                }

                history.analyses.unshift({
                    timestamp: Date.now(),
                    url: analysis.url || 'Manual Text',
                    title: analysis.title || 'Untitled',
                    score: analysis.score
                });

                // Keep only last 5 analyses
                history.analyses = history.analyses.slice(0, CONFIG.maxHistoryItems);
                
                localStorage.setItem(CONFIG.storageKey, JSON.stringify(history));
                renderHistory();
            } catch (error) {
                console.warn('Failed to save to localStorage:', error);
            }
        }

        function loadFromStorage() {
            try {
                const stored = localStorage.getItem(CONFIG.storageKey);
                if (!stored) return [];
                
                const history = JSON.parse(stored);
                if (history.version !== CONFIG.storageVersion) return [];
                
                return history.analyses || [];
            } catch (error) {
                console.warn('Failed to load from localStorage:', error);
                return [];
            }
        }

        function renderHistory() {
            const history = loadFromStorage();
            
            if (history.length === 0) {
                elements.noHistory.style.display = 'block';
                return;
            }

            elements.noHistory.style.display = 'none';
            
            const historyItems = history.map(item => {
                const date = new Date(item.timestamp).toLocaleDateString();
                const scoreColor = item.score > 0 ? 'var(--accent-red)' : item.score < 0 ? 'var(--accent-blue)' : 'var(--text-secondary)';
                
                return `
                    <div class="history-item" tabindex="0" role="button" onclick="restoreAnalysis(${item.timestamp})" onkeydown="handleHistoryKeydown(event, ${item.timestamp})">
                        <div class="history-meta">
                            <span class="history-score" style="color: ${scoreColor}">${item.score > 0 ? '+' : ''}${item.score}</span>
                            <span class="history-time">${date}</span>
                        </div>
                        <div class="history-url">${item.url}</div>
                    </div>
                `;
            }).join('');

            elements.historyList.innerHTML = historyItems;
        }

        window.restoreAnalysis = function(timestamp) {
            const history = loadFromStorage();
            const item = history.find(h => h.timestamp === timestamp);
            if (!item) return;

            if (item.url !== 'Manual Text') {
                elements.urlInput.value = item.url;
            }
            
            showError(`Restored: ${item.title} (Score: ${item.score})`);
        };

        window.handleHistoryKeydown = function(event, timestamp) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                restoreAnalysis(timestamp);
            }
        };

        // Content extraction from HTML
        function extractContent(html, url) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Remove scripts, styles, and other unwanted elements
                const unwanted = doc.querySelectorAll('script, style, nav, footer, aside, header, .ad, .advertisement, .sidebar, .related, .comments, .social, .share');
                unwanted.forEach(el => el.remove());

                // Extract title
                let title = '';
                const titleEl = doc.querySelector('title, h1, .title, .headline');
                if (titleEl) {
                    title = titleEl.textContent.trim();
                }

                // Extract main content
                const contentSelectors = [
                    'article',
                    '.article-content',
                    '.content',
                    '.post-content',
                    '.entry-content',
                    'main',
                    '.main-content',
                    '.story-body',
                    '.article-body'
                ];

                let content = '';
                for (const selector of contentSelectors) {
                    const element = doc.querySelector(selector);
                    if (element) {
                        content = element.textContent;
                        break;
                    }
                }

                // Fallback to body if no specific content found
                if (!content) {
                    const body = doc.querySelector('body');
                    if (body) {
                        content = body.textContent;
                    }
                }

                // Clean and normalize text
                content = content
                    .replace(/\s+/g, ' ')
                    .replace(/[""'']/g, '"')
                    .replace(/[–—]/g, '-')
                    .trim();

                // Limit word count
                const words = content.split(/\s+/);
                if (words.length > CONFIG.maxWordCount) {
                    content = words.slice(0, CONFIG.maxWordCount).join(' ') + '...';
                }

                return { title, content, wordCount: words.length };
            } catch (error) {
                throw new Error('Failed to parse HTML content');
            }
        }

        // Proxy rotation with timeout and error handling
        async function fetchWithProxies(url) {
            const startTime = Date.now();
            let lastError = null;
            let proxyUsed = 'Direct';

            // Try direct fetch first (for CORS-enabled sites)
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), CONFIG.proxyTimeout);
                
                const response = await fetch(url, {
                    signal: controller.signal,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const text = await response.text();
                    updateDevPanel({ proxy: 'Direct', timing: Date.now() - startTime });
                    return text;
                }
            } catch (error) {
                lastError = error;
            }

            // Try proxies
            for (let i = 0; i < PROXIES.length; i++) {
                const proxy = PROXIES[i];
                proxyUsed = `Proxy ${i + 1}`;
                
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), CONFIG.proxyTimeout);
                    
                    const proxyUrl = proxy + encodeURIComponent(url);
                    const response = await fetch(proxyUrl, {
                        signal: controller.signal,
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const text = await response.text();
                        updateDevPanel({ proxy: proxyUsed, timing: Date.now() - startTime });
                        return text;
                    }
                } catch (error) {
                    lastError = error;
                    console.warn(`Proxy ${i + 1} failed:`, error.message);
                }
            }

            throw new Error(`All proxies failed. Last error: ${lastError?.message || 'Unknown error'}`);
        }

        // Natural bias detection algorithm - analyzes context, tone, and argumentation patterns
        function analyzeBias(text, title = '', url = '') {
            const startTime = Date.now();
            
            // Normalize and prepare text
            const normalizedText = text.toLowerCase();
            const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 10);
            
            // Political entities for contextual analysis
            const politicalEntities = {
                left: ['democrats', 'biden', 'harris', 'pelosi', 'schumer', 'aoc', 'sanders', 'warren'],
                right: ['republicans', 'trump', 'desantis', 'mcconnell', 'cruz', 'hawley', 'greene'],
                neutral: ['congress', 'senate', 'house', 'government', 'administration', 'officials']
            };

            // Initialize scoring components
            let features = {};
            let evidenceTerms = [];
            let contextualSignals = 0;
            let biasSentences = []; // Store sentences that show bias

            // 1. CONTEXTUAL SENTIMENT ANALYSIS
            // Analyze sentiment around political entities and capture biased sentences
            function analyzeContextualSentiment() {
                let leftSentiment = 0;
                let rightSentiment = 0;
                const contextWindow = 20; // words around entity
                
                sentences.forEach(sentence => {
                    const words = sentence.toLowerCase().split(/\s+/);
                    let sentenceBias = 0;
                    let sentenceDirection = null;
                    let foundEntities = [];
                    
                    // Find political entities in sentence
                    words.forEach((word, index) => {
                        let entityBias = null;
                        if (politicalEntities.left.some(entity => word.includes(entity))) {
                            entityBias = 'left';
                            foundEntities.push(word);
                        }
                        if (politicalEntities.right.some(entity => word.includes(entity))) {
                            entityBias = 'right';
                            foundEntities.push(word);
                        }
                        
                        if (entityBias) {
                            // Analyze context around entity
                            const start = Math.max(0, index - contextWindow);
                            const end = Math.min(words.length, index + contextWindow);
                            const context = words.slice(start, end).join(' ');
                            
                            // Positive sentiment indicators
                            const positiveContext = /\b(successful|effective|strong|praised|support|defend|champion|fight for|stand up|deliver|accomplish|achieve|brilliant|outstanding|excellent)\b/g;
                            const negativeContext = /\b(failed|ineffective|weak|criticized|attack|oppose|undermine|damage|hurt|threaten|dangerous|extreme|ridiculous|absurd|disaster)\b/g;
                            
                            const positiveMatches = (context.match(positiveContext) || []).length;
                            const negativeMatches = (context.match(negativeContext) || []).length;
                            const sentimentScore = positiveMatches - negativeMatches;
                            
                            // Track sentence-level bias
                            if (Math.abs(sentimentScore) > 0) {
                                sentenceBias += sentimentScore;
                                sentenceDirection = entityBias;
                            }
                            
                            // Apply sentiment based on entity bias
                            if (entityBias === 'left') {
                                leftSentiment += sentimentScore;
                            } else {
                                rightSentiment += sentimentScore;
                            }
                            
                            if (Math.abs(sentimentScore) > 0) {
                                evidenceTerms.push({
                                    term: word,
                                    context: sentimentScore > 0 ? 'positive' : 'negative',
                                    strength: Math.abs(sentimentScore),
                                    bias: entityBias
                                });
                            }
                        }
                    });
                    
                    // Store biased sentences for display
                    if (Math.abs(sentenceBias) > 0 && foundEntities.length > 0) {
                        const finalBias = sentenceBias > 0 ? 
                            (sentenceDirection === 'left' ? 'left-positive' : 'right-positive') :
                            (sentenceDirection === 'left' ? 'left-negative' : 'right-negative');
                            
                        biasSentences.push({
                            text: sentence.trim(),
                            bias: finalBias,
                            strength: Math.abs(sentenceBias),
                            entities: foundEntities,
                            type: 'contextual'
                        });
                    }
                });
                
                return { leftSentiment, rightSentiment };
            }

            // 2. LINGUISTIC PATTERN ANALYSIS
            // Detect rhetorical patterns that indicate bias and capture sentences
            function analyzeLinguisticPatterns() {
                let patterns = { certainty: 0, hedging: 0, emotional: 0, factual: 0 };
                
                // Certainty vs hedging language
                const certaintyMarkers = /\b(clearly|obviously|undoubtedly|definitely|certainly|without question|no doubt|absolutely)\b/gi;
                const hedgingMarkers = /\b(might|could|perhaps|possibly|allegedly|reportedly|sources say|appears to|seems to|may have)\b/gi;
                
                patterns.certainty = (normalizedText.match(certaintyMarkers) || []).length;
                patterns.hedging = (normalizedText.match(hedgingMarkers) || []).length;
                
                // Emotional vs factual language
                const emotionalMarkers = /\b(outrageous|shocking|devastating|alarming|dangerous|disaster|crisis|betrayal|attack|defend|fight|slams|blasts|destroys)\b/gi;
                const factualMarkers = /\b(according to|data shows|study found|research indicates|statistics|analysis|report|survey)\b/gi;
                
                patterns.emotional = (normalizedText.match(emotionalMarkers) || []).length;
                patterns.factual = (normalizedText.match(factualMarkers) || []).length;
                
                // Find sentences with strong emotional or certainty language
                sentences.forEach(sentence => {
                    const sentenceLower = sentence.toLowerCase();
                    const emotionalMatches = (sentenceLower.match(emotionalMarkers) || []).length;
                    const certaintyMatches = (sentenceLower.match(certaintyMarkers) || []).length;
                    
                    if (emotionalMatches > 1 || certaintyMatches > 1) {
                        const biasStrength = emotionalMatches + certaintyMatches;
                        biasSentences.push({
                            text: sentence.trim(),
                            bias: 'emotional-language',
                            strength: biasStrength,
                            type: 'linguistic',
                            indicators: emotionalMatches > 0 ? 'emotional' : 'certainty'
                        });
                    }
                });
                
                return patterns;
            }

            // 3. SOURCE AND ATTRIBUTION ANALYSIS
            function analyzeSourcePatterns() {
                let sourceScore = 0;
                
                // Anonymous sources (can indicate speculation)
                const anonymousSources = /\b(sources say|unnamed official|according to sources|insiders report|leaked|off the record)\b/gi;
                const namedSources = /\b(said|stated|announced|declared|confirmed|according to [A-Z][a-z]+ [A-Z][a-z]+)\b/gi;
                
                const anonymousCount = (normalizedText.match(anonymousSources) || []).length;
                const namedCount = (normalizedText.match(namedSources) || []).length;
                
                // More anonymous sources may indicate less reliable reporting
                sourceScore = namedCount - (anonymousCount * 0.5);
                
                return { sourceScore, anonymousCount, namedCount };
            }

            // 4. ARGUMENT STRUCTURE ANALYSIS
            function analyzeArgumentStructure() {
                let structureScore = 0;
                
                // Look for balanced reporting indicators
                const balanceIndicators = /\b(however|but|on the other hand|meanwhile|in contrast|alternatively|critics argue|supporters say|both sides)\b/gi;
                const onesided = /\b(all|every|always|never|completely|totally|entirely|absolutely no|zero|none)\b/gi;
                
                const balanceCount = (normalizedText.match(balanceIndicators) || []).length;
                const onesidedCount = (normalizedText.match(onesided) || []).length;
                
                structureScore = balanceCount - (onesidedCount * 0.3);
                
                return { structureScore, balanceCount, onesidedCount };
            }

            // 5. TOPIC FRAMING ANALYSIS
            // Analyze how topics are framed and capture biased framing sentences
            function analyzeTopicFraming() {
                let framingBias = 0;
                
                // Economic framing
                const economicLeft = /\b(inequality|corporate greed|tax the rich|worker rights|minimum wage|wealth gap)\b/gi;
                const economicRight = /\b(job creators|free market|economic growth|business friendly|tax burden|regulation hurts)\b/gi;
                
                // Social framing  
                const socialLeft = /\b(social justice|systemic racism|reproductive rights|lgbtq rights|inclusion|equity)\b/gi;
                const socialRight = /\b(traditional values|family values|religious freedom|law and order|personal responsibility)\b/gi;
                
                // Government framing
                const govLeft = /\b(public investment|government programs|safety net|public option|infrastructure)\b/gi;
                const govRight = /\b(government overreach|bureaucracy|red tape|states rights|limited government)\b/gi;
                
                const leftFraming = (normalizedText.match(economicLeft) || []).length + 
                                  (normalizedText.match(socialLeft) || []).length +
                                  (normalizedText.match(govLeft) || []).length;
                
                const rightFraming = (normalizedText.match(economicRight) || []).length + 
                                   (normalizedText.match(socialRight) || []).length +
                                   (normalizedText.match(govRight) || []).length;
                
                framingBias = rightFraming - leftFraming;
                
                // Find sentences with strong framing language
                sentences.forEach(sentence => {
                    const sentenceLower = sentence.toLowerCase();
                    const leftMatches = (sentenceLower.match(economicLeft) || []).length +
                                       (sentenceLower.match(socialLeft) || []).length +
                                       (sentenceLower.match(govLeft) || []).length;
                    const rightMatches = (sentenceLower.match(economicRight) || []).length +
                                        (sentenceLower.match(socialRight) || []).length +
                                        (sentenceLower.match(govRight) || []).length;
                    
                    if (leftMatches > 0 || rightMatches > 0) {
                        const netBias = rightMatches - leftMatches;
                        if (Math.abs(netBias) > 0) {
                            biasSentences.push({
                                text: sentence.trim(),
                                bias: netBias > 0 ? 'right-framing' : 'left-framing',
                                strength: Math.abs(netBias),
                                type: 'framing'
                            });
                        }
                    }
                });
                
                return { framingBias, leftFraming, rightFraming };
            }

            // Execute all analyses
            const sentimentAnalysis = analyzeContextualSentiment();
            const linguisticPatterns = analyzeLinguisticPatterns();
            const sourcePatterns = analyzeSourcePatterns();
            const argumentStructure = analyzeArgumentStructure();
            const topicFraming = analyzeTopicFraming();

            // COMPOSITE SCORING
            // Weight different aspects of bias detection
            let biasScore = 0;
            
            // Contextual sentiment (40% weight) - most important
            const sentimentScore = sentimentAnalysis.rightSentiment - sentimentAnalysis.leftSentiment;
            biasScore += sentimentScore * 4;
            features.sentiment = sentimentScore;
            
            // Topic framing (25% weight)
            biasScore += topicFraming.framingBias * 2.5;
            features.framing = topicFraming.framingBias;
            
            // Linguistic patterns (20% weight)
            const linguisticBias = (linguisticPatterns.certainty - linguisticPatterns.hedging) + 
                                 (linguisticPatterns.emotional - linguisticPatterns.factual) * 0.5;
            biasScore += linguisticBias * 0.8;
            features.linguistic = linguisticBias;
            
            // Argument structure (10% weight) - lack of balance adds bias
            biasScore -= argumentStructure.structureScore * 0.5;
            features.structure = argumentStructure.structureScore;
            
            // Source reliability (5% weight)
            biasScore -= sourcePatterns.sourceScore * 0.2;
            features.sources = sourcePatterns.sourceScore;

            // Apply outlet prior (small influence)
            let outletPrior = 0;
            if (url) {
                try {
                    const hostname = new URL(url).hostname.toLowerCase().replace('www.', '');
                    outletPrior = OUTLET_PRIORS[hostname] || 0;
                    biasScore += outletPrior;
                } catch (error) {
                    // Invalid URL, no prior
                }
            }

            // Title analysis (1.5x multiplier)
            if (title) {
                const titleSentiment = title.toLowerCase();
                let titleBias = 0;
                
                // Check for loaded language in title
                if (/\b(slams|blasts|destroys|demolishes|attacks|hits|strikes)\b/.test(titleSentiment)) titleBias += 2;
                if (/\b(defends|supports|champions|stands up|fights for)\b/.test(titleSentiment)) titleBias -= 2;
                if (/\b(crisis|disaster|chaos|failure|threatens)\b/.test(titleSentiment)) titleBias += 1.5;
                if (/\b(progress|success|achievement|breakthrough|delivers)\b/.test(titleSentiment)) titleBias -= 1.5;
                
                biasScore += titleBias * 1.5;
                features.titleBias = titleBias;
            }

            // Normalize to [-100, 100] scale with natural curve
            // Use tanh for smooth natural scaling instead of hard caps
            const normalizedScore = Math.round(Math.tanh(biasScore / 15) * 100);
            
            // Generate natural explanation
            const explanation = generateNaturalExplanation(normalizedScore, features, evidenceTerms);
            
            const analysis = {
                score: normalizedScore,
                explanation,
                evidence: evidenceTerms.slice(0, 8), // Top evidence
                biasSentences: biasSentences.sort((a, b) => b.strength - a.strength).slice(0, 5), // Top 5 biased sentences
                features,
                outletPrior,
                timing: Date.now() - startTime,
                rawScore: biasScore,
                wordCount: text.split(/\s+/).length,
                url,
                title
            };

            updateDevPanel(analysis);
            return analysis;
        }

        function generateNaturalExplanation(score, features, evidenceTerms) {
            let explanation = '';
            
            // Primary bias assessment
            if (Math.abs(score) < 10) {
                explanation = 'BiasLens detected relatively balanced reporting with neutral tone and framing throughout the article.';
            } else if (score < -30) {
                explanation = 'BiasLens detected strong liberal bias through sympathetic coverage of progressive positions and critical framing of conservative viewpoints.';
            } else if (score < -10) {
                explanation = 'BiasLens detected moderate liberal bias with somewhat favorable treatment of progressive policies and politicians.';
            } else if (score > 30) {
                explanation = 'BiasLens detected strong conservative bias through sympathetic coverage of right-leaning positions and critical framing of liberal viewpoints.';
            } else if (score > 10) {
                explanation = 'BiasLens detected moderate conservative bias with somewhat favorable treatment of traditional policies and politicians.';
            }

            // Add specific reasoning based on strongest signals
            const sentimentSignal = Math.abs(features.sentiment || 0);
            const framingSignal = Math.abs(features.framing || 0);
            const linguisticSignal = Math.abs(features.linguistic || 0);

            if (sentimentSignal > framingSignal && sentimentSignal > linguisticSignal) {
                explanation += ' This assessment is primarily driven by the emotional tone used when discussing political figures and policies.';
            } else if (framingSignal > linguisticSignal) {
                explanation += ' This bias appears mainly in how issues are framed and contextualized rather than explicit opinion.';
            } else if (linguisticSignal > 1) {
                explanation += ' The bias is evident in the certainty of language and emotional word choices used throughout.';
            }

            // Source and structure commentary
            if (features.sources && features.sources < -2) {
                explanation += ' Heavy reliance on anonymous sources may indicate speculative reporting.';
            } else if (features.structure && features.structure < -2) {
                explanation += ' The article lacks balanced perspectives from multiple viewpoints.';
            }

            return explanation;
        }

        function updateDevPanel(analysis) {
            if (!analysis) return;
            
            elements.devProxy.textContent = analysis.proxy || 'N/A';
            elements.devFeatures.textContent = analysis.features ? 
                Object.entries(analysis.features).map(([k, v]) => `${k}: ${v.toFixed(1)}`).join(', ') : 'N/A';
            elements.devLexicon.textContent = analysis.evidence ? 
                `${analysis.evidence.length} contextual signals found` : 'N/A';
            elements.devOutlet.textContent = analysis.outletPrior ? 
                `${analysis.outletPrior > 0 ? '+' : ''}${analysis.outletPrior}` : '0';
            elements.devNorm.textContent = analysis.rawScore !== undefined ? 
                `Raw: ${analysis.rawScore.toFixed(1)} → Normalized: ${analysis.score}` : 'N/A';
            elements.devTiming.textContent = analysis.timing ? `${analysis.timing}ms` : 'N/A';
        }

        // Display results
        function displayResults(analysis) {
            currentAnalysis = analysis;
            
            // Update score display
            elements.scoreNumber.textContent = analysis.score > 0 ? `+${analysis.score}` : analysis.score;
            elements.scoreNumber.style.color = analysis.score > 0 ? 'var(--accent-red)' : 
                                               analysis.score < 0 ? 'var(--accent-blue)' : 'var(--text-primary)';
            
            // Update bias scale marker position
            const markerPosition = ((analysis.score + 100) / 200) * 100; // Convert [-100,100] to [0,100]%
            elements.scaleMarker.style.left = `${markerPosition}%`;
            
            // Update explanation
            elements.explanationText.textContent = analysis.explanation;
            
            // Update evidence chips
            if (analysis.evidence && analysis.evidence.length > 0) {
                elements.evidenceChips.innerHTML = analysis.evidence.map(item => {
                    const className = item.bias === 'left' ? 'negative' : 'positive';
                    const contextLabel = item.context === 'positive' ? '+' : item.context === 'negative' ? '-' : '';
                    return `<span class="evidence-chip ${className}">${item.term} ${contextLabel}</span>`;
                }).join('');
            } else {
                elements.evidenceChips.innerHTML = '<span class="evidence-chip">No significant evidence found</span>';
            }
            
            // Update bias sentences
            if (analysis.biasSentences && analysis.biasSentences.length > 0) {
                elements.biasSentencesList.innerHTML = analysis.biasSentences.map(sentence => {
                    let labelText = '';
                    switch (sentence.bias) {
                        case 'left-positive': labelText = 'Positive toward liberals'; break;
                        case 'left-negative': labelText = 'Negative toward liberals'; break;
                        case 'right-positive': labelText = 'Positive toward conservatives'; break;
                        case 'right-negative': labelText = 'Negative toward conservatives'; break;
                        case 'left-framing': labelText = 'Liberal framing'; break;
                        case 'right-framing': labelText = 'Conservative framing'; break;
                        case 'emotional-language': labelText = 'Emotional language'; break;
                        default: labelText = 'Biased language';
                    }
                    
                    return `
                        <div class="bias-sentence ${sentence.bias}">
                            <div class="sentence-label ${sentence.bias}">${labelText}</div>
                            <div class="sentence-text">"${sentence.text}"</div>
                        </div>
                    `;
                }).join('');
            } else {
                elements.biasSentencesList.innerHTML = '<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 20px;">No clearly biased sentences detected by our AI</div>';
            }
            
            // Show results with animation
            elements.resultSection.style.display = 'block';
            setTimeout(() => {
                elements.resultSection.classList.add('visible');
            }, 100);
            
            // Save to history
            saveToStorage(analysis);
        }

        // Main analysis functions
        async function analyzeUrl() {
            const url = sanitizeUrl(elements.urlInput.value);
            if (!url) {
                showError('Please enter a valid URL');
                return;
            }

            setLoading(true);
            
            try {
                const html = await fetchWithProxies(url);
                const extracted = extractContent(html, url);
                
                if (!extracted.content || extracted.content.length < 100) {
                    throw new Error('Could not extract meaningful content from the page');
                }

                const analysis = analyzeBias(extracted.content, extracted.title, url);
                displayResults(analysis);
                
            } catch (error) {
                console.error('Analysis failed:', error);
                showError(`Failed to analyze URL: ${error.message}. Try using "Paste Article Text" instead.`);
            } finally {
                setLoading(false);
            }
        }

        async function analyzeText() {
            const text = elements.articleText.value.trim();
            if (!text || text.length < 50) {
                showError('Please paste article text (at least 50 characters)');
                return;
            }

            setLoading(true);
            
            try {
                const analysis = analyzeBias(text, '', 'Manual Text');
                displayResults(analysis);
            } catch (error) {
                console.error('Text analysis failed:', error);
                showError('Failed to analyze text. Please try again.');
            } finally {
                setLoading(false);
            }
        }

        // Event listeners
        elements.analyzeBtn.addEventListener('click', analyzeUrl);
        elements.analyzeTextBtn.addEventListener('click', analyzeText);

        // URL input handling
        elements.urlInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                analyzeUrl();
            }
        });

        // Collapsible text area
        document.querySelector('.collapsible-header').addEventListener('click', function() {
            const content = document.querySelector('.collapsible-content');
            const chevron = this.querySelector('.chevron');
            const isOpen = content.classList.contains('open');
            
            content.classList.toggle('open');
            this.setAttribute('aria-expanded', !isOpen);
        });

        // Keyboard navigation for collapsible
        document.querySelector('.collapsible-header').addEventListener('keydown', function(event) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                this.click();
            }
        });

        // Dev panel toggle
        elements.aboutTitle.addEventListener('click', () => {
            devPanelTaps++;
            if (devPanelTaps >= 5) {
                devPanelVisible = !devPanelVisible;
                elements.devPanel.classList.toggle('visible', devPanelVisible);
                devPanelTaps = 0;
            }
            
            // Reset counter after 2 seconds
            setTimeout(() => {
                if (devPanelTaps < 5) devPanelTaps = 0;
            }, 2000);
        });

        // Initialize app
        function initApp() {
            renderHistory();
            
            // Hide results initially
            elements.resultSection.style.display = 'none';
            elements.resultSection.classList.remove('visible');
        }

        // Start the app
        initApp();
    </script>
</body>
</html>
