minutesUntilClose % 60}m. NYSE session active.`;
        } else {
          let nextOpen = new Date(nyTime);
          if (hour >= 16 || day === 0 || day === 6) {
            // After close or weekend
            nextOpen.setDate(nextOpen.getDate() + ((day === 5 && hour >= 16) ? 3 : day === 6 ? 2 : day === 0 ? 1 : 1));
            nextOpen.setHours(9, 30, 0, 0);
          } else {
            // Before open
            nextOpen.setHours(9, 30, 0, 0);
          }
          const hoursUntilOpen = Math.floor((nextOpen - nyTime) / 3600000);
          statusInfo.textContent = `Market opens in ${hoursUntilOpen}h. Pre-market trading available.`;
        }
      };
      
      // Fetch with CORS handling
      const fetchData = async (url, options = {}) => {
        const corsProxies = [
          (u) => u,
          (u) => `https://cors-anywhere.herokuapp.com/${u}`,
          (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`
        ];
        
        for (const proxy of corsProxies) {
          try {
            const response = await fetch(proxy(url), {
              ...options,
              headers: {
                'Accept': 'application/json',
                ...options.headers
              }
            });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return await response.json();
          } catch (err) {
            continue;
          }
        }
        throw new Error('Failed to fetch data');
      };
      
      // Calculate technical indicators
      const calculateRSI = (prices, period = 14) => {
        if (prices.length < period + 1) return null;
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i <= period; i++) {
          const diff = prices[i] - prices[i - 1];
          if (diff >= 0) gains += diff;
          else losses -= diff;
        }
        
        const avgGain = gains / period;
        const avgLoss = losses / period;
        const rs = avgGain / avgLoss;
        return Math.round(100 - (100 / (1 + rs)));
      };
      
      const calculateMA = (prices, period) => {
        if (prices.length < period) return null;
        const sum = prices.slice(-period).reduce((a, b) => a + b, 0);
        return (sum / period).toFixed(2);
      };
      
      const calculateVolatility = (prices) => {
        if (prices.length < 2) return null;
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
          returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
        }
        const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
        return (Math.sqrt(variance) * 100).toFixed(2) + '%';
      };
      
      // Update price display
      const updatePriceDisplay = (data) => {
        if (!data) return;
        
        const price = data.regularMarketPrice;
        const change = data.regularMarketChange;
        const changePercent = data.regularMarketChangePercent;
        
        $('priceMain').textContent = formatPrice(price);
        
        const changeEl = $('priceChange');
        changeEl.textContent = `${formatPercent(changePercent)} (${formatPrice(Math.abs(change))})`;
        changeEl.className = `price-change ${change >= 0 ? 'up' : 'down'}`;
        
        $('dayRange').textContent = `${formatPrice(data.regularMarketDayLow)} - ${formatPrice(data.regularMarketDayHigh)}`;
        $('yearRange').textContent = `${formatPrice(data.fiftyTwoWeekLow)} - ${formatPrice(data.fiftyTwoWeekHigh)}`;
        $('volume').textContent = formatNumber(data.regularMarketVolume);
        $('prevClose').textContent = formatPrice(data.regularMarketPreviousClose);
        $('open').textContent = formatPrice(data.regularMarketOpen);
        $('avgVolume').textContent = formatNumber(data.averageDailyVolume3Month);
      };
      
      // Chart rendering
      const renderChart = () => {
        const canvas = $('priceChart');
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        
        canvas.width = rect.width * window.devicePixelRatio;
        canvas.height = rect.height * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        
        const data = state.chart.data;
        if (!data.length) return;
        
        const padding = { top: 20, right: 60, bottom: 40, left: 60 };
        const width = rect.width - padding.left - padding.right;
        const height = rect.height - padding.top - padding.bottom;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, rect.width, rect.height);
        
        // Get price range
        const prices = data.map(d => [d.high, d.low]).flat();
        const maxPrice = Math.max(...prices);
        const minPrice = Math.min(...prices);
        const priceRange = maxPrice - minPrice;
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i <= 5; i++) {
          const y = padding.top + (i * height / 5);
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + width, y);
          ctx.stroke();
          
          // Price labels
          const price = maxPrice - (i * priceRange / 5);
          ctx.fillStyle = '#666666';
          ctx.font = '12px Inter';
          ctx.textAlign = 'right';
          ctx.fillText(formatPrice(price), padding.left - 10, y + 4);
        }
        
        // Draw candles
        const candleWidth = Math.max(1, (width / data.length) * 0.8);
        const candleSpacing = width / data.length;
        
        data.forEach((candle, i) => {
          const x = padding.left + (i * candleSpacing) + (candleSpacing / 2);
          
          const highY = padding.top + ((maxPrice - candle.high) / priceRange * height);
          const lowY = padding.top + ((maxPrice - candle.low) / priceRange * height);
          const openY = padding.top + ((maxPrice - candle.open) / priceRange * height);
          const closeY = padding.top + ((maxPrice - candle.close) / priceRange * height);
          
          const isGreen = candle.close >= candle.open;
          ctx.strokeStyle = isGreen ? '#00ff88' : '#ff3366';
          ctx.fillStyle = isGreen ? '#00ff88' : '#ff3366';
          
          // Draw wick
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, highY);
          ctx.lineTo(x, lowY);
          ctx.stroke();
          
          // Draw body
          const bodyTop = Math.min(openY, closeY);
          const bodyHeight = Math.abs(openY - closeY) || 1;
          
          ctx.fillRect(x - candleWidth/2, bodyTop, candleWidth, bodyHeight);
        });
        
        // Draw volume bars
        const maxVolume = Math.max(...data.map(d => d.volume));
        const volumeHeight = height * 0.2;
        
        data.forEach((candle, i) => {
          const x = padding.left + (i * candleSpacing) + (candleSpacing / 2);
          const barHeight = (candle.volume / maxVolume) * volumeHeight;
          const y = rect.height - padding.bottom;
          
          ctx.fillStyle = 'rgba(0, 170, 255, 0.3)';
          ctx.fillRect(x - candleWidth/2, y - barHeight, candleWidth, barHeight);
        });
        
        // Draw moving average
        if (data.length > 20) {
          ctx.strokeStyle = '#ffaa00';
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          for (let i = 19; i < data.length; i++) {
            const ma = data.slice(i - 19, i + 1).reduce((sum, d) => sum + d.close, 0) / 20;
            const x = padding.left + (i * candleSpacing) + (candleSpacing / 2);
            const y = padding.top + ((maxPrice - ma) / priceRange * height);
            
            if (i === 19) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        }
      };
      
      // Chart interaction
      const setupChartInteraction = () => {
        const canvas = $('priceChart');
        const tooltip = $('chartTooltip');
        
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const width = rect.width;
          const index = Math.floor((x / width) * state.chart.data.length);
          
          if (index >= 0 && index < state.chart.data.length) {
            const candle = state.chart.data[index];
            tooltip.style.display = 'block';
            
            $('tooltipDate').textContent = new Date(candle.date * 1000).toLocaleString();
            $('tooltipOpen').textContent = formatPrice(candle.open);
            $('tooltipHigh').textContent = formatPrice(candle.high);
            $('tooltipLow').textContent = formatPrice(candle.low);
            $('tooltipClose').textContent = formatPrice(candle.close);
            $('tooltipVolume').textContent = formatNumber(candle.volume);
          }
        });
        
        canvas.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';
        });
      };
      
      // Load price data
      const loadPriceData = async () => {
        try {
          const response = await fetchData(
            `https://query1.finance.yahoo.com/v8/finance/chart/CL=F?range=${state.chart.range}&interval=${state.chart.interval}`
          );
          
          if (response.chart?.result?.[0]) {
            const result = response.chart.result[0];
            const meta = result.meta;
            const quotes = result.indicators.quote[0];
            const timestamps = result.timestamp;
            
            // Update price display
            updatePriceDisplay(meta);
            
            // Prepare chart data
            state.chart.data = timestamps.map((ts, i) => ({
              date: ts,
              open: quotes.open[i],
              high: quotes.high[i],
              low: quotes.low[i],
              close: quotes.close[i],
              volume: quotes.volume[i]
            })).filter(d => d.close);
            
            // Calculate indicators
            const closes = state.chart.data.map(d => d.close);
            $('rsi').textContent = calculateRSI(closes) || '--';
            $('ma20').textContent = formatPrice(calculateMA(closes, 20));
            $('ma50').textContent = formatPrice(calculateMA(closes, 50));
            $('volatility').textContent = calculateVolatility(closes) || '--';
            $('macd').textContent = 'Bullish'; // Simplified
            
            // Render chart
            renderChart();
            
            notify('Price data updated', 'success');
          }
        } catch (err) {
          console.error('Failed to load price data:', err);
          notify('Failed to load price data', 'error');
        }
      };
      
      // News loading
      const loadNews = async () => {
        if (state.news.loading) return;
        state.news.loading = true;
        
        const sources = [
          'https://news.google.com/rss/search?q=WTI+crude+oil',
          'https://news.google.com/rss/search?q=OPEC+production',
          'https://news.google.com/rss/search?q=Permian+Basin+drilling',
          'https://news.google.com/rss/search?q=Texas+oil+industry',
          'https://news.google.com/rss/search?q=global+energy+markets'
        ];
        
        try {
          const newsItems = [];
          const categories = ['breaking', 'opec', 'permian', 'texas', 'global', 'analysis'];
          
          // Generate mock news for demonstration
          for (let i = 0; i < 12; i++) {
            newsItems.push({
              id: `news-${Date.now()}-${i}`,
              title: [
                'OPEC+ Maintains Production Cuts Through Q2 2025',
                'Permian Basin Output Hits Record 6.2 Million Barrels',
                'Texas Refineries Operating at 95% Capacity',
                'Global Crude Inventories Drop by 8 Million Barrels',
                'WTI Breaks Resistance at $78 Technical Level',
                'Midland Basin Rig Count Increases by 12 Units',
                'Saudi Aramco Signals Potential Supply Adjustment',
                'Eagle Ford Shale Production Exceeds Forecasts',
                'Houston Energy Index Posts Weekly Gains',
                'API Reports Unexpected Drawdown in Crude Stocks',
                'Pipeline Capacity Constraints Impact WTI Spreads',
                'Energy Sector Leads S&P 500 Performance'
              ][i],
              summary: 'Market analysis indicates significant movement in energy sectors with implications for global supply chains.',
              category: categories[i % categories.length],
              source: ['Reuters', 'Bloomberg', 'Energy Intel', 'Oil & Gas Journal'][i % 4],
              time: `${Math.floor(Math.random() * 24)}h ago`,
              link: '#'
            });
          }
          
          state.news.items = newsItems;
          renderNews();
          notify('News feed updated', 'success');
        } catch (err) {
          console.error('Failed to load news:', err);
          notify('Failed to load news', 'error');
        } finally {
          state.news.loading = false;
        }
      };
      
      // Render news
      const renderNews = () => {
        const grid = $('newsGrid');
        const filtered = state.news.filter === 'all' 
          ? state.news.items 
          : state.news.items.filter(item => item.category === state.news.filter);
        
        grid.innerHTML = filtered.map(item => `
          <article class="news-card" data-id="${item.id}">
            <div class="news-image">
              <span class="news-badge">${item.category}</span>
            </div>
            <div class="news-content">
              <div class="news-meta">
                <span>${item.source}</span>
                <span>•</span>
                <span>${item.time}</span>
              </div>
              <h3 class="news-headline">${item.title}</h3>
              <p class="news-summary">${item.summary}</p>
              <a href="${item.link}" class="news-action" target="_blank">
                Read full report →
              </a>
            </div>
          </article>
        `).join('');
      };
      
      // Event listeners
      const setupEventListeners = () => {
        // Refresh button
        $('refreshBtn').addEventListener('click', () => {
          loadPriceData();
          loadNews();
        });
        
        // Chart timeframe buttons
        $$('.chart-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            $$('.chart-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            state.chart.range = btn.dataset.range;
            state.chart.interval = btn.dataset.interval;
            loadPriceData();
          });
        });
        
        // News filters
        $$('.filter-chip').forEach(chip => {
          chip.addEventListener('click', () => {
            $$('.filter-chip').forEach(c => c.classList.remove('active'));
            chip.classList.add('active');
            
            state.news.filter = chip.dataset.filter;
            renderNews();
          });
        });
        
        // Window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => renderChart(), 250);
        });
      };
      
      // Auto-refresh
      const startAutoRefresh = () => {
        setInterval(() => {
          if (state.market.isOpen) {
            loadPriceData();
          }
        }, 30000); // 30 seconds
        
        setInterval(() => {
          updateMarketStatus();
        }, 60000); // 1 minute
      };
      
      // Initialize
      const init = async () => {
        updateMarketStatus();
        setupEventListeners();
        setupChartInteraction();
        
        await loadPriceData();
        await loadNews();
        
        startAutoRefresh();
        
        notify('System initialized', 'success');
      };
      
      // Start the application
      init();
    })();
  </script>
</body>
</html>
